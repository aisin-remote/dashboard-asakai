!(function (t, e) {
	"object" == typeof module && module.exports
		? ((e.default = e), (module.exports = t.document ? e(t) : e))
		: "function" == typeof define && define.amd
		? define("highcharts/highcharts", function () {
				return e(t);
		  })
		: (t.Highcharts && t.Highcharts.error(16, !0), (t.Highcharts = e(t)));
})("undefined" != typeof window ? window : this, function (r) {
	"use strict";
	var t = {};
	function e(t, e, i, o) {
		t.hasOwnProperty(e) ||
			((t[e] = o.apply(null, i)),
			"function" == typeof CustomEvent &&
				r.dispatchEvent(
					new CustomEvent("HighchartsModuleLoaded", {
						detail: { path: e, module: t[e] },
					})
				));
	}
	return (
		e(t, "Core/Globals.js", [], function () {
			var t, e, i, o;
			return (
				((e = t = t || {}).SVG_NS = "http://www.w3.org/2000/svg"),
				(e.product = "Highcharts"),
				(e.version = "10.3.3"),
				(e.win = void 0 !== r ? r : {}),
				(e.doc = e.win.document),
				(e.svg =
					e.doc &&
					e.doc.createElementNS &&
					!!e.doc.createElementNS(e.SVG_NS, "svg").createSVGRect),
				(e.userAgent = (e.win.navigator && e.win.navigator.userAgent) || ""),
				(e.isChrome = -1 !== e.userAgent.indexOf("Chrome")),
				(e.isFirefox = -1 !== e.userAgent.indexOf("Firefox")),
				(e.isMS = /(edge|msie|trident)/i.test(e.userAgent) && !e.win.opera),
				(e.isSafari = !e.isChrome && -1 !== e.userAgent.indexOf("Safari")),
				(e.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(e.userAgent)),
				(e.isWebKit = -1 !== e.userAgent.indexOf("AppleWebKit")),
				(e.deg2rad = (2 * Math.PI) / 360),
				(e.hasBidiBug =
					e.isFirefox && parseInt(e.userAgent.split("Firefox/")[1], 10) < 4),
				(e.hasTouch = !!e.win.TouchEvent),
				(e.marginNames = [
					"plotTop",
					"marginRight",
					"marginBottom",
					"plotLeft",
				]),
				(e.noop = function () {}),
				(e.supportsPassiveEvents =
					((o = !1),
					e.isMS ||
						((i = Object.defineProperty({}, "passive", {
							get: function () {
								o = !0;
							},
						})),
						e.win.addEventListener &&
							e.win.removeEventListener &&
							(e.win.addEventListener("testPassive", e.noop, i),
							e.win.removeEventListener("testPassive", e.noop, i))),
					o)),
				(e.charts = []),
				(e.dateFormats = {}),
				(e.seriesTypes = {}),
				(e.symbolSizes = {}),
				(e.chartCount = 0),
				t
			);
		}),
		e(t, "Core/Utilities.js", [t["Core/Globals.js"]], function (h) {
			var e = h.charts,
				l = h.doc,
				c = h.win;
			function d(t, e, i, o) {
				var r,
					s = e ? "Highcharts error" : "Highcharts warning",
					n = f((t = 32 === t ? s + ": Deprecated member" : t)),
					a = n
						? s + " #" + t + ": www.highcharts.com/errors/" + t + "/"
						: t.toString();
				void 0 !== o &&
					((r = ""),
					n && (a += "?"),
					S(o, function (t, e) {
						(r += "\n - ".concat(e, ": ").concat(t)),
							n && (a += encodeURI(e) + "=" + encodeURI(t));
					}),
					(a += r)),
					C(
						h,
						"displayError",
						{ chart: i, code: t, message: a, params: o },
						function () {
							if (e) throw new Error(a);
							c.console && -1 === d.messages.indexOf(a) && console.warn(a);
						}
					),
					d.messages.push(a);
			}
			function p(t, e) {
				return parseInt(t, e || 10);
			}
			function n(t) {
				return "string" == typeof t;
			}
			function i(t) {
				t = Object.prototype.toString.call(t);
				return "[object Array]" === t || "[object Array Iterator]" === t;
			}
			function a(t, e) {
				return !(!t || "object" != typeof t || (e && i(t)));
			}
			function s(t) {
				return a(t) && "number" == typeof t.nodeType;
			}
			function u(t) {
				var e = t && t.constructor;
				return !(!a(t, !0) || s(t) || !e || !e.name || "Object" === e.name);
			}
			function f(t) {
				return "number" == typeof t && !isNaN(t) && t < 1 / 0 && -1 / 0 < t;
			}
			function g(t) {
				return null != t;
			}
			function o(i, t, e) {
				function o(t, e) {
					g(t)
						? i.setAttribute(e, t)
						: s
						? (r = i.getAttribute(e)) ||
						  "class" !== e ||
						  (r = i.getAttribute(e + "Name"))
						: i.removeAttribute(e);
				}
				var r,
					s = n(t) && !g(e);
				return n(t) ? o(e, t) : S(t, o), r;
			}
			function m(t, e) {
				for (var i in ((t = t || {}), e)) t[i] = e[i];
				return t;
			}
			function y() {
				for (var t = arguments, e = t.length, i = 0; i < e; i++) {
					var o = t[i];
					if (null != o) return o;
				}
			}
			function v(t, e) {
				h.isMS &&
					!h.svg &&
					e &&
					g(e.opacity) &&
					(e.filter = "alpha(opacity=".concat(100 * e.opacity, ")")),
					m(t.style, e);
			}
			function x(t) {
				return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));
			}
			function b(t, e) {
				return 1e14 < t ? t : parseFloat(t.toPrecision(e || 14));
			}
			(d = d || {}).messages = [];
			Math.easeInOutSine = function (t) {
				return -0.5 * (Math.cos(Math.PI * t) - 1);
			};
			var r,
				t = Array.prototype.find
					? function (t, e) {
							return t.find(e);
					  }
					: function (t, e) {
							for (var i = t.length, o = 0; o < i; o++)
								if (e(t[o], o)) return t[o];
					  };
			function S(t, e, i) {
				for (var o in t)
					Object.hasOwnProperty.call(t, o) && e.call(i || t[o], t[o], o, t);
			}
			function k(r, e, i) {
				function s(t, e) {
					var i = r.removeEventListener || h.removeEventListenerPolyfill;
					i && i.call(r, t, e, !1);
				}
				function t(i) {
					var t, o;
					r.nodeName &&
						(e ? ((t = {})[e] = !0) : (t = i),
						S(t, function (t, e) {
							if (i[e]) for (o = i[e].length; o--; ) s(e, i[e][o].fn);
						}));
				}
				var o,
					n,
					a = ("function" == typeof r && r.prototype) || r;
				Object.hasOwnProperty.call(a, "hcEvents") &&
					((o = a.hcEvents),
					e
						? ((n = o[e] || []),
						  i
								? ((o[e] = n.filter(function (t) {
										return i !== t.fn;
								  })),
								  s(e, i))
								: (t(o), (o[e] = [])))
						: (t(o), delete a.hcEvents));
			}
			function C(e, t, i, o) {
				var r;
				if (
					((i = i || {}),
					l.createEvent && (e.dispatchEvent || (e.fireEvent && e !== h)))
				)
					(r = l.createEvent("Events")).initEvent(t, !0, !0),
						(i = m(r, i)),
						e.dispatchEvent ? e.dispatchEvent(i) : e.fireEvent(t, i);
				else if (e.hcEvents) {
					i.target ||
						m(i, {
							preventDefault: function () {
								i.defaultPrevented = !0;
							},
							target: e,
							type: t,
						});
					for (var s = [], n = e, a = !1; n.hcEvents; )
						Object.hasOwnProperty.call(n, "hcEvents") &&
							n.hcEvents[t] &&
							(s.length && (a = !0), s.unshift.apply(s, n.hcEvents[t])),
							(n = Object.getPrototypeOf(n));
					a &&
						s.sort(function (t, e) {
							return t.order - e.order;
						}),
						s.forEach(function (t) {
							!1 === t.fn.call(e, i) && i.preventDefault();
						});
				}
				o && !i.defaultPrevented && o.call(e, i);
			}
			S(
				{
					map: "map",
					each: "forEach",
					grep: "filter",
					reduce: "reduce",
					some: "some",
				},
				function (i, o) {
					h[o] = function (t) {
						var e;
						return (
							d(
								32,
								!1,
								void 0,
								(((e = {})["Highcharts.".concat(o)] = "use Array.".concat(i)),
								e)
							),
							Array.prototype[i].apply(t, [].slice.call(arguments, 1))
						);
					};
				}
			);
			function M() {
				return "highcharts-" + (r ? "" : w) + T++;
			}
			var w, T;
			(w = Math.random().toString(36).substring(2, 9) + "-"), (T = 0);
			return (
				c.jQuery &&
					(c.jQuery.fn.highcharts = function () {
						var t = [].slice.call(arguments);
						if (this[0])
							return t[0]
								? (new h[n(t[0]) ? t.shift() : "Chart"](this[0], t[0], t[1]),
								  this)
								: e[o(this[0], "data-highcharts-chart")];
					}),
				{
					addEvent: function (t, e, i, o) {
						void 0 === o && (o = {});
						var r = ("function" == typeof t && t.prototype) || t,
							r =
								(Object.hasOwnProperty.call(r, "hcEvents") || (r.hcEvents = {}),
								r.hcEvents);
						h.Point &&
							t instanceof h.Point &&
							t.series &&
							t.series.chart &&
							(t.series.chart.runTrackerClick = !0);
						(s = t.addEventListener || h.addEventListenerPolyfill) &&
							s.call(
								t,
								e,
								i,
								!!h.supportsPassiveEvents && {
									passive:
										void 0 === o.passive
											? -1 !== e.indexOf("touch")
											: o.passive,
									capture: !1,
								}
							),
							r[e] || (r[e] = []);
						var s = {
							fn: i,
							order: "number" == typeof o.order ? o.order : 1 / 0,
						};
						return (
							r[e].push(s),
							r[e].sort(function (t, e) {
								return t.order - e.order;
							}),
							function () {
								k(t, e, i);
							}
						);
					},
					arrayMax: function (t) {
						for (var e = t.length, i = t[0]; e--; ) t[e] > i && (i = t[e]);
						return i;
					},
					arrayMin: function (t) {
						for (var e = t.length, i = t[0]; e--; ) t[e] < i && (i = t[e]);
						return i;
					},
					attr: o,
					clamp: function (t, e, i) {
						return e < t ? (t < i ? t : i) : e;
					},
					cleanRecursively: function o(r, s) {
						var n = {};
						return (
							S(r, function (t, e) {
								var i;
								a(r[e], !0) && !r.nodeType && s[e]
									? ((i = o(r[e], s[e])), Object.keys(i).length && (n[e] = i))
									: (a(r[e]) || r[e] !== s[e] || (e in r && !(e in s))) &&
									  (n[e] = r[e]);
							}),
							n
						);
					},
					clearTimeout: function (t) {
						g(t) && clearTimeout(t);
					},
					correctFloat: b,
					createElement: function (t, e, i, o, r) {
						return (
							(t = l.createElement(t)),
							e && m(t, e),
							r && v(t, { padding: "0", border: "none", margin: "0" }),
							i && v(t, i),
							o && o.appendChild(t),
							t
						);
					},
					css: v,
					defined: g,
					destroyObjectProperties: function (i, o) {
						S(i, function (t, e) {
							t && t !== o && t.destroy && t.destroy(), delete i[e];
						});
					},
					discardElement: function (t) {
						t && t.parentElement && t.parentElement.removeChild(t);
					},
					erase: function (t, e) {
						for (var i = t.length; i--; )
							if (t[i] === e) {
								t.splice(i, 1);
								break;
							}
					},
					error: d,
					extend: m,
					extendClass: function (t, e) {
						function i() {}
						return m((i.prototype = new t()), e), i;
					},
					find: t,
					fireEvent: C,
					getMagnitude: x,
					getNestedProperty: function (t, e) {
						for (var i = t.split("."); i.length && g(e); ) {
							var o = i.shift();
							if (void 0 === o || "__proto__" === o) return;
							o = e[o];
							if (
								!g(o) ||
								"function" == typeof o ||
								"number" == typeof o.nodeType ||
								o === c
							)
								return;
							e = o;
						}
						return e;
					},
					getStyle: function t(e, i, o) {
						var r,
							s,
							n = h.getStyle || t;
						if ("width" === i)
							return (
								(s = Math.min(e.offsetWidth, e.scrollWidth)),
								(a =
									e.getBoundingClientRect && e.getBoundingClientRect().width) <
									s &&
									s - 1 <= a &&
									(s = Math.floor(a)),
								Math.max(
									0,
									s -
										(n(e, "padding-left", !0) || 0) -
										(n(e, "padding-right", !0) || 0)
								)
							);
						if ("height" === i)
							return Math.max(
								0,
								Math.min(e.offsetHeight, e.scrollHeight) -
									(n(e, "padding-top", !0) || 0) -
									(n(e, "padding-bottom", !0) || 0)
							);
						c.getComputedStyle || d(27, !0);
						var a = c.getComputedStyle(e, void 0);
						return (
							a &&
								((r = a.getPropertyValue(i)),
								y(o, "opacity" !== i) && (r = p(r))),
							r
						);
					},
					inArray: function (t, e, i) {
						return (
							d(32, !1, void 0, { "Highcharts.inArray": "use Array.indexOf" }),
							e.indexOf(t, i)
						);
					},
					isArray: i,
					isClass: u,
					isDOMElement: s,
					isFunction: function (t) {
						return "function" == typeof t;
					},
					isNumber: f,
					isObject: a,
					isString: n,
					keys: function (t) {
						return (
							d(32, !1, void 0, { "Highcharts.keys": "use Object.keys" }),
							Object.keys(t)
						);
					},
					merge: function () {
						for (
							var t = arguments,
								e = {},
								r = function (i, o) {
									return (
										"object" != typeof i && (i = {}),
										S(o, function (t, e) {
											"__proto__" !== e &&
												"constructor" !== e &&
												(!a(t, !0) || u(t) || s(t)
													? (i[e] = o[e])
													: (i[e] = r(i[e] || {}, t)));
										}),
										i
									);
								},
								i =
									(!0 === t[0] &&
										((e = t[1]), (t = Array.prototype.slice.call(t, 2))),
									t.length),
								o = 0;
							o < i;
							o++
						)
							e = r(e, t[o]);
						return e;
					},
					normalizeTickInterval: function (t, e, i, o, r) {
						var s,
							n = t,
							a = t / (i = y(i, x(t)));
						for (
							e ||
								((e = r
									? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
									: [1, 2, 2.5, 5, 10]),
								!1 === o &&
									(1 === i
										? (e = e.filter(function (t) {
												return t % 1 == 0;
										  }))
										: i <= 0.1 && (e = [1 / i]))),
								s = 0;
							s < e.length &&
							((n = e[s]),
							!(
								(r && t <= n * i) ||
								(!r && a <= (e[s] + (e[s + 1] || e[s])) / 2)
							));
							s++
						);
						return (n = b(n * i, -Math.round(Math.log(0.001) / Math.LN10)));
					},
					objectEach: S,
					offset: function (t) {
						var e = l.documentElement;
						return {
							top:
								(t =
									t.parentElement || t.parentNode
										? t.getBoundingClientRect()
										: { top: 0, left: 0, width: 0, height: 0 }).top +
								(c.pageYOffset || e.scrollTop) -
								(e.clientTop || 0),
							left:
								t.left + (c.pageXOffset || e.scrollLeft) - (e.clientLeft || 0),
							width: t.width,
							height: t.height,
						};
					},
					pad: function (t, e, i) {
						return (
							new Array((e || 2) + 1 - String(t).replace("-", "").length).join(
								i || "0"
							) + t
						);
					},
					pick: y,
					pInt: p,
					relativeLength: function (t, e, i) {
						return /%$/.test(t)
							? (e * parseFloat(t)) / 100 + (i || 0)
							: parseFloat(t);
					},
					removeEvent: k,
					splat: function (t) {
						return i(t) ? t : [t];
					},
					stableSort: function (t, i) {
						for (var o, e = t.length, r = 0; r < e; r++) t[r].safeI = r;
						for (
							t.sort(function (t, e) {
								return 0 === (o = i(t, e)) ? t.safeI - e.safeI : o;
							}),
								r = 0;
							r < e;
							r++
						)
							delete t[r].safeI;
					},
					syncTimeout: function (t, e, i) {
						return 0 < e ? setTimeout(t, e, i) : (t.call(0, i), -1);
					},
					timeUnits: {
						millisecond: 1,
						second: 1e3,
						minute: 6e4,
						hour: 36e5,
						day: 864e5,
						week: 6048e5,
						month: 24192e5,
						year: 314496e5,
					},
					uniqueKey: M,
					useSerialIds: function (t) {
						return (r = y(t, r));
					},
					wrap: function (t, e, i) {
						var o = t[e];
						t[e] = function () {
							var t = arguments,
								e = this;
							return i.apply(
								this,
								[
									function () {
										return o.apply(e, arguments.length ? arguments : t);
									},
								].concat([].slice.call(arguments))
							);
						};
					},
				}
			);
		}),
		e(t, "Core/Chart/ChartDefaults.js", [], function () {
			return {
				alignThresholds: !1,
				panning: { enabled: !1, type: "x" },
				styledMode: !1,
				borderRadius: 0,
				colorCount: 10,
				allowMutatingData: !0,
				defaultSeriesType: "line",
				ignoreHiddenSeries: !0,
				spacing: [10, 10, 15, 10],
				resetZoomButton: {
					theme: { zIndex: 6 },
					position: { align: "right", x: -10, y: 10 },
				},
				zoomBySingleTouch: !1,
				zooming: {
					singleTouch: !1,
					resetButton: {
						theme: { zIndex: 6 },
						position: { align: "right", x: -10, y: 10 },
					},
				},
				width: null,
				height: null,
				borderColor: "#335cad",
				backgroundColor: "#ffffff",
				plotBorderColor: "#cccccc",
			};
		}),
		e(
			t,
			"Core/Color/Color.js",
			[t["Core/Globals.js"], t["Core/Utilities.js"]],
			function (i, t) {
				var r = t.isNumber,
					s = t.merge,
					o = t.pInt;
				function a(t) {
					(this.rgba = [NaN, NaN, NaN, NaN]), (this.input = t);
					var e = i.Color;
					return e && e !== a
						? new e(t)
						: this instanceof a
						? void this.init(t)
						: new a(t);
				}
				return (
					(a.parse = function (t) {
						return t ? new a(t) : a.None;
					}),
					(a.prototype.init = function (t) {
						var e, i, o, r, s, n;
						if ("object" == typeof t && void 0 !== t.stops)
							this.stops = t.stops.map(function (t) {
								return new a(t[1]);
							});
						else if ("string" == typeof t)
							if (
								((this.input = t = a.names[t.toLowerCase()] || t),
								"#" === t.charAt(0) &&
									((s = t.length),
									(n = parseInt(t.substr(1), 16)),
									7 === s
										? (i = [(16711680 & n) >> 16, (65280 & n) >> 8, 255 & n, 1])
										: 4 === s &&
										  (i = [
												((3840 & n) >> 4) | ((3840 & n) >> 8),
												((240 & n) >> 4) | (240 & n),
												((15 & n) << 4) | (15 & n),
												1,
										  ])),
								!i)
							)
								for (o = a.parsers.length; o-- && !i; )
									(e = (r = a.parsers[o]).regex.exec(t)) && (i = r.parse(e));
						i && (this.rgba = i);
					}),
					(a.prototype.get = function (i) {
						var o,
							t = this.input,
							e = this.rgba;
						return "object" == typeof t && void 0 !== this.stops
							? (((o = s(t)).stops = [].slice.call(o.stops)),
							  this.stops.forEach(function (t, e) {
									o.stops[e] = [o.stops[e][0], t.get(i)];
							  }),
							  o)
							: e && r(e[0])
							? "rgb" === i || (!i && 1 === e[3])
								? "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")"
								: "a" === i
								? "".concat(e[3])
								: "rgba(" + e.join(",") + ")"
							: t;
					}),
					(a.prototype.brighten = function (e) {
						var t = this.rgba;
						if (this.stops)
							this.stops.forEach(function (t) {
								t.brighten(e);
							});
						else if (r(e) && 0 !== e)
							for (var i = 0; i < 3; i++)
								(t[i] += o(255 * e)),
									t[i] < 0 && (t[i] = 0),
									255 < t[i] && (t[i] = 255);
						return this;
					}),
					(a.prototype.setOpacity = function (t) {
						return (this.rgba[3] = t), this;
					}),
					(a.prototype.tweenTo = function (t, e) {
						var i = this.rgba,
							o = t.rgba;
						if (!r(i[0]) || !r(o[0])) return t.input || "none";
						t = 1 !== o[3] || 1 !== i[3];
						return (
							(t ? "rgba(" : "rgb(") +
							Math.round(o[0] + (i[0] - o[0]) * (1 - e)) +
							"," +
							Math.round(o[1] + (i[1] - o[1]) * (1 - e)) +
							"," +
							Math.round(o[2] + (i[2] - o[2]) * (1 - e)) +
							(t ? "," + (o[3] + (i[3] - o[3]) * (1 - e)) : "") +
							")"
						);
					}),
					(a.names = { white: "#ffffff", black: "#000000" }),
					(a.parsers = [
						{
							regex:
								/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
							parse: function (t) {
								return [o(t[1]), o(t[2]), o(t[3]), parseFloat(t[4], 10)];
							},
						},
						{
							regex:
								/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
							parse: function (t) {
								return [o(t[1]), o(t[2]), o(t[3]), 1];
							},
						},
					]),
					(a.None = new a("")),
					a
				);
			}
		),
		e(t, "Core/Color/Palettes.js", [], function () {
			return {
				colors: [
					"#7cb5ec",
					"#434348",
					"#90ed7d",
					"#f7a35c",
					"#8085e9",
					"#f15c80",
					"#e4d354",
					"#2b908f",
					"#f45b5b",
					"#91e8e1",
				],
			};
		}),
		e(
			t,
			"Core/Time.js",
			[t["Core/Globals.js"], t["Core/Utilities.js"]],
			function (u, t) {
				var r = u.win,
					v = t.defined,
					s = t.error,
					x = t.extend,
					e = t.isObject,
					i = t.merge,
					f = t.objectEach,
					g = t.pad,
					b = t.pick,
					o = t.splat,
					S = t.timeUnits,
					n =
						u.isSafari && r.Intl && r.Intl.DateTimeFormat.prototype.formatRange,
					l =
						u.isSafari &&
						r.Intl &&
						!r.Intl.DateTimeFormat.prototype.formatRange;
				function a(t) {
					(this.options = {}),
						(this.useUTC = !1),
						(this.variableTimezone = !1),
						(this.Date = r.Date),
						(this.getTimezoneOffset = this.timezoneOffsetFunction()),
						this.update(t);
				}
				return (
					(a.prototype.get = function (t, e) {
						var i, o;
						return this.variableTimezone || this.timezoneOffset
							? ((o = (i = e.getTime()) - this.getTimezoneOffset(e)),
							  e.setTime(o),
							  (o = e["getUTC" + t]()),
							  e.setTime(i),
							  o)
							: this.useUTC
							? e["getUTC" + t]()
							: e["get" + t]();
					}),
					(a.prototype.set = function (t, e, i) {
						if (this.variableTimezone || this.timezoneOffset) {
							if (
								"Milliseconds" === t ||
								"Seconds" === t ||
								("Minutes" === t && this.getTimezoneOffset(e) % 36e5 == 0)
							)
								return e["setUTC" + t](i);
							var o = this.getTimezoneOffset(e),
								o = e.getTime() - o,
								r =
									(e.setTime(o), e["setUTC" + t](i), this.getTimezoneOffset(e)),
								o = e.getTime() + r;
							return e.setTime(o);
						}
						return this.useUTC || (n && "FullYear" === t)
							? e["setUTC" + t](i)
							: e["set" + t](i);
					}),
					(a.prototype.update = function (t) {
						var e = b((t = void 0 === t ? {} : t).useUTC, !0);
						(this.options = t = i(!0, this.options, t)),
							(this.Date = t.Date || r.Date || Date),
							(this.useUTC = e),
							(this.timezoneOffset = (e && t.timezoneOffset) || void 0),
							(this.getTimezoneOffset = this.timezoneOffsetFunction()),
							(this.variableTimezone =
								e && !(!t.getTimezoneOffset && !t.timezone));
					}),
					(a.prototype.makeTime = function (t, e, i, o, r, s) {
						var n, a, h;
						return (
							this.useUTC
								? ((n = this.Date.UTC.apply(0, arguments)),
								  (a = this.getTimezoneOffset(n)) !==
								  (h = this.getTimezoneOffset((n += a)))
										? (n += h - a)
										: a - 36e5 !== this.getTimezoneOffset(n - 36e5) ||
										  l ||
										  (n -= 36e5))
								: (n = new this.Date(
										t,
										e,
										b(i, 1),
										b(o, 0),
										b(r, 0),
										b(s, 0)
								  ).getTime()),
							n
						);
					}),
					(a.prototype.timezoneOffsetFunction = function () {
						var t = this,
							e = this.options,
							i = e.getTimezoneOffset,
							o = e.moment || r.moment;
						if (!this.useUTC)
							return function (t) {
								return 6e4 * new Date(t.toString()).getTimezoneOffset();
							};
						if (e.timezone) {
							if (o)
								return function (t) {
									return 6e4 * -o.tz(t, e.timezone).utcOffset();
								};
							s(25);
						}
						return this.useUTC && i
							? function (t) {
									return 6e4 * i(t.valueOf());
							  }
							: function () {
									return 6e4 * (t.timezoneOffset || 0);
							  };
					}),
					(a.prototype.dateFormat = function (i, o, t) {
						if (!v(o) || isNaN(o))
							return (
								(u.defaultOptions.lang && u.defaultOptions.lang.invalidDate) ||
								""
							);
						i = b(i, "%Y-%m-%d %H:%M:%S");
						var r = this,
							e = new this.Date(o),
							s = this.get("Hours", e),
							n = this.get("Day", e),
							a = this.get("Date", e),
							h = this.get("Month", e),
							l = this.get("FullYear", e),
							c = u.defaultOptions.lang,
							d = c && c.weekdays,
							p = c && c.shortWeekdays,
							p = x(
								{
									a: p ? p[n] : d[n].substr(0, 3),
									A: d[n],
									d: g(a),
									e: g(a, 2, " "),
									w: n,
									b: c.shortMonths[h],
									B: c.months[h],
									m: g(h + 1),
									o: h + 1,
									y: l.toString().substr(2, 2),
									Y: l,
									H: g(s),
									k: s,
									I: g(s % 12 || 12),
									l: s % 12 || 12,
									M: g(this.get("Minutes", e)),
									p: s < 12 ? "AM" : "PM",
									P: s < 12 ? "am" : "pm",
									S: g(e.getSeconds()),
									L: g(Math.floor(o % 1e3), 3),
								},
								u.dateFormats
							);
						return (
							f(p, function (t, e) {
								for (; -1 !== i.indexOf("%" + e); )
									i = i.replace(
										"%" + e,
										"function" == typeof t ? t.call(r, o) : t
									);
							}),
							t ? i.substr(0, 1).toUpperCase() + i.substr(1) : i
						);
					}),
					(a.prototype.resolveDTLFormat = function (t) {
						return e(t, !0) ? t : { main: (t = o(t))[0], from: t[1], to: t[2] };
					}),
					(a.prototype.getTimeTicks = function (t, e, i, o) {
						var r,
							s,
							n = this,
							a = n.Date,
							h = [],
							l = {},
							a = new a(e),
							c = t.unitRange,
							d = t.count || 1;
						if (((o = b(o, 1)), v(e))) {
							n.set(
								"Milliseconds",
								a,
								c >= S.second ? 0 : d * Math.floor(n.get("Milliseconds", a) / d)
							),
								c >= S.second &&
									n.set(
										"Seconds",
										a,
										c >= S.minute ? 0 : d * Math.floor(n.get("Seconds", a) / d)
									),
								c >= S.minute &&
									n.set(
										"Minutes",
										a,
										c >= S.hour ? 0 : d * Math.floor(n.get("Minutes", a) / d)
									),
								c >= S.hour &&
									n.set(
										"Hours",
										a,
										c >= S.day ? 0 : d * Math.floor(n.get("Hours", a) / d)
									),
								c >= S.day &&
									n.set(
										"Date",
										a,
										c >= S.month
											? 1
											: Math.max(1, d * Math.floor(n.get("Date", a) / d))
									),
								c >= S.month &&
									(n.set(
										"Month",
										a,
										c >= S.year ? 0 : d * Math.floor(n.get("Month", a) / d)
									),
									(p = n.get("FullYear", a))),
								c >= S.year && n.set("FullYear", a, (p -= p % d)),
								c === S.week &&
									((s = n.get("Day", a)),
									n.set(
										"Date",
										a,
										n.get("Date", a) - s + o + (s < o ? -7 : 0)
									));
							for (
								var p = n.get("FullYear", a),
									u = n.get("Month", a),
									f = n.get("Date", a),
									g = n.get("Hours", a),
									m =
										((e = a.getTime()),
										(!n.variableTimezone && n.useUTC) ||
											!v(i) ||
											(r =
												i - e > 4 * S.month ||
												n.getTimezoneOffset(e) !== n.getTimezoneOffset(i)),
										a.getTime()),
									y = 1;
								m < i;

							)
								h.push(m),
									c === S.year
										? (m = n.makeTime(p + y * d, 0))
										: c === S.month
										? (m = n.makeTime(p, u + y * d))
										: !r || (c !== S.day && c !== S.week)
										? r && c === S.hour && 1 < d
											? (m = n.makeTime(p, u, f, g + y * d))
											: (m += c * d)
										: (m = n.makeTime(p, u, f + y * d * (c === S.day ? 1 : 7))),
									y++;
							h.push(m),
								c <= S.hour &&
									h.length < 1e4 &&
									h.forEach(function (t) {
										t % 18e5 == 0 &&
											"000000000" === n.dateFormat("%H%M%S%L", t) &&
											(l[t] = "day");
									});
						}
						return (h.info = x(t, { higherRanks: l, totalRange: c * d })), h;
					}),
					(a.prototype.getDateFormat = function (t, e, i, o) {
						var r = this.dateFormat("%m-%d %H:%M:%S.%L", e),
							s = "01-01 00:00:00.000",
							n = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 },
							a = "millisecond",
							h = a;
						for (a in S) {
							if (
								t === S.week &&
								+this.dateFormat("%w", e) === i &&
								r.substr(6) === s.substr(6)
							) {
								a = "week";
								break;
							}
							if (S[a] > t) {
								a = h;
								break;
							}
							if (n[a] && r.substr(n[a]) !== s.substr(n[a])) break;
							"week" !== a && (h = a);
						}
						return this.resolveDTLFormat(o[a]).main;
					}),
					a
				);
			}
		),
		e(
			t,
			"Core/Defaults.js",
			[
				t["Core/Chart/ChartDefaults.js"],
				t["Core/Color/Color.js"],
				t["Core/Globals.js"],
				t["Core/Color/Palettes.js"],
				t["Core/Time.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, o, r, s) {
				var e = e.parse,
					n = i.isTouchDevice,
					a = i.svg,
					h = s.merge,
					l = {
						colors: o.colors,
						symbols: [
							"circle",
							"diamond",
							"square",
							"triangle",
							"triangle-down",
						],
						lang: {
							loading: "Loading...",
							months: [
								"January",
								"February",
								"March",
								"April",
								"May",
								"June",
								"July",
								"August",
								"September",
								"October",
								"November",
								"December",
							],
							shortMonths: [
								"Jan",
								"Feb",
								"Mar",
								"Apr",
								"May",
								"Jun",
								"Jul",
								"Aug",
								"Sep",
								"Oct",
								"Nov",
								"Dec",
							],
							weekdays: [
								"Sunday",
								"Monday",
								"Tuesday",
								"Wednesday",
								"Thursday",
								"Friday",
								"Saturday",
							],
							decimalPoint: ".",
							numericSymbols: ["k", "M", "G", "T", "P", "E"],
							resetZoom: "Reset zoom",
							resetZoomTitle: "Reset zoom level 1:1",
							thousandsSep: " ",
						},
						global: {},
						time: {
							Date: void 0,
							getTimezoneOffset: void 0,
							timezone: void 0,
							timezoneOffset: 0,
							useUTC: !0,
						},
						chart: t,
						title: {
							text: "Chart title",
							align: "center",
							margin: 15,
							widthAdjust: -44,
						},
						subtitle: { text: "", align: "center", widthAdjust: -44 },
						caption: {
							margin: 15,
							text: "",
							align: "left",
							verticalAlign: "bottom",
						},
						plotOptions: {},
						labels: { style: { position: "absolute", color: "#333333" } },
						legend: {
							enabled: !0,
							align: "center",
							alignColumns: !0,
							className: "highcharts-no-tooltip",
							layout: "horizontal",
							labelFormatter: function () {
								return this.name;
							},
							borderColor: "#999999",
							borderRadius: 0,
							navigation: { activeColor: "#003399", inactiveColor: "#cccccc" },
							itemStyle: {
								color: "#333333",
								cursor: "pointer",
								fontSize: "12px",
								fontWeight: "bold",
								textOverflow: "ellipsis",
							},
							itemHoverStyle: { color: "#000000" },
							itemHiddenStyle: { color: "#cccccc" },
							shadow: !1,
							itemCheckboxStyle: {
								position: "absolute",
								width: "13px",
								height: "13px",
							},
							squareSymbol: !0,
							symbolPadding: 5,
							verticalAlign: "bottom",
							x: 0,
							y: 0,
							title: { style: { fontWeight: "bold" } },
						},
						loading: {
							labelStyle: {
								fontWeight: "bold",
								position: "relative",
								top: "45%",
							},
							style: {
								position: "absolute",
								backgroundColor: "#ffffff",
								opacity: 0.5,
								textAlign: "center",
							},
						},
						tooltip: {
							enabled: !0,
							animation: a,
							borderRadius: 3,
							dateTimeLabelFormats: {
								millisecond: "%A, %b %e, %H:%M:%S.%L",
								second: "%A, %b %e, %H:%M:%S",
								minute: "%A, %b %e, %H:%M",
								hour: "%A, %b %e, %H:%M",
								day: "%A, %b %e, %Y",
								week: "Week from %A, %b %e, %Y",
								month: "%B %Y",
								year: "%Y",
							},
							footerFormat: "",
							headerShape: "callout",
							hideDelay: 500,
							padding: 8,
							shape: "callout",
							shared: !1,
							snap: n ? 25 : 10,
							headerFormat:
								'<span style="font-size: 10px">{point.key}</span><br/>',
							pointFormat:
								'<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
							backgroundColor: e("#f7f7f7").setOpacity(0.85).get(),
							borderWidth: 1,
							shadow: !0,
							stickOnContact: !1,
							style: {
								color: "#333333",
								cursor: "default",
								fontSize: "12px",
								whiteSpace: "nowrap",
							},
							useHTML: !1,
						},
						credits: {
							enabled: !0,
							href: "https://www.highcharts.com?credits",
							position: {
								align: "right",
								x: -10,
								verticalAlign: "bottom",
								y: -5,
							},
							style: { cursor: "pointer", color: "#999999", fontSize: "9px" },
							text: "Highcharts.com",
						},
					},
					c = ((l.chart.styledMode = !1), new r(h(l.global, l.time)));
				return {
					defaultOptions: l,
					defaultTime: c,
					getOptions: function () {
						return l;
					},
					setOptions: function (t) {
						return (
							h(!0, l, t),
							(t.time || t.global) &&
								(i.time
									? i.time.update(h(l.global, l.time, t.global, t.time))
									: (i.time = c)),
							l
						);
					},
				};
			}
		),
		e(
			t,
			"Core/Animation/Fx.js",
			[t["Core/Color/Color.js"], t["Core/Globals.js"], t["Core/Utilities.js"]],
			function (t, e, i) {
				var o = t.parse,
					h = e.win,
					u = i.isNumber,
					l = i.objectEach;
				function c(t, e, i) {
					(this.pos = NaN),
						(this.options = e),
						(this.elem = t),
						(this.prop = i);
				}
				return (
					(c.prototype.dSetter = function () {
						var t = this.paths,
							e = t && t[0],
							i = t && t[1],
							o = this.now || 0,
							r = [];
						if (1 !== o && e && i)
							if (e.length === i.length && o < 1)
								for (var s = 0; s < i.length; s++) {
									for (
										var n = e[s], a = i[s], h = [], l = 0;
										l < a.length;
										l++
									) {
										var c = n[l],
											d = a[l];
										u(c) && u(d) && ("A" !== a[0] || (4 !== l && 5 !== l))
											? (h[l] = c + o * (d - c))
											: (h[l] = d);
									}
									r.push(h);
								}
							else r = i;
						else r = this.toD || [];
						this.elem.attr("d", r, void 0, !0);
					}),
					(c.prototype.update = function () {
						var t = this.elem,
							e = this.prop,
							i = this.now,
							o = this.options.step;
						this[e + "Setter"]
							? this[e + "Setter"]()
							: t.attr
							? t.element && t.attr(e, i, null, !0)
							: (t.style[e] = i + this.unit),
							o && o.call(t, i, this);
					}),
					(c.prototype.run = function (t, e, i) {
						var o = this,
							r = o.options,
							s = function (t) {
								return !s.stopped && o.step(t);
							},
							n =
								h.requestAnimationFrame ||
								function (t) {
									setTimeout(t, 13);
								},
							a = function () {
								for (var t = 0; t < c.timers.length; t++)
									c.timers[t]() || c.timers.splice(t--, 1);
								c.timers.length && n(a);
							};
						t !== e || this.elem["forceAnimate:" + this.prop]
							? ((this.startTime = +new Date()),
							  (this.start = t),
							  (this.end = e),
							  (this.unit = i),
							  (this.now = this.start),
							  (this.pos = 0),
							  (s.elem = this.elem),
							  (s.prop = this.prop),
							  s() && 1 === c.timers.push(s) && n(a))
							: (delete r.curAnim[this.prop],
							  r.complete &&
									0 === Object.keys(r.curAnim).length &&
									r.complete.call(this.elem));
					}),
					(c.prototype.step = function (t) {
						var e,
							i = +new Date(),
							o = this.options,
							r = this.elem,
							s = o.complete,
							n = o.duration,
							a = o.curAnim,
							t =
								!(r.attr && !r.element) &&
								(t || i >= n + this.startTime
									? ((this.now = this.end),
									  (this.pos = 1),
									  this.update(),
									  (a[this.prop] = !0),
									  (e = !0),
									  l(a, function (t) {
											!0 !== t && (e = !1);
									  }),
									  e && s && s.call(r),
									  !1)
									: ((this.pos = o.easing((i - this.startTime) / n)),
									  (this.now =
											this.start + (this.end - this.start) * this.pos),
									  this.update(),
									  !0));
						return t;
					}),
					(c.prototype.initPath = function (t, e, i) {
						var o,
							r,
							s,
							n,
							a = t.startX,
							h = t.endX,
							i = i.slice(),
							l = t.isArea,
							c = l ? 2 : 1,
							t = e && e.slice();
						if (!t) return [i, i];
						function d(t, e) {
							for (; t.length < r; ) {
								var i = t[0],
									o = e[r - t.length];
								o &&
									"M" === i[0] &&
									("C" === o[0]
										? (t[0] = ["C", i[1], i[2], i[1], i[2], i[1], i[2]])
										: (t[0] = ["L", i[1], i[2]])),
									t.unshift(i),
									l && ((o = t.pop()), t.push(t[t.length - 1], o));
							}
						}
						function p(t) {
							for (; t.length < r; ) {
								var e,
									i = t[Math.floor(t.length / c) - 1].slice();
								"C" === i[0] && ((i[1] = i[5]), (i[2] = i[6])),
									l
										? ((e = t[Math.floor(t.length / c)].slice()),
										  t.splice(t.length / 2, 0, i, e))
										: t.push(i);
							}
						}
						if (a && h && h.length) {
							for (s = 0; s < a.length; s++) {
								if (a[s] === h[0]) {
									o = s;
									break;
								}
								if (a[0] === h[h.length - a.length + s]) {
									(o = s), (n = !0);
									break;
								}
								if (a[a.length - 1] === h[h.length - a.length + s]) {
									o = a.length - s;
									break;
								}
							}
							void 0 === o && (t = []);
						}
						return (
							t.length &&
								u(o) &&
								((r = i.length + o * c), n ? (d(t, i), p(i)) : (d(i, t), p(t))),
							[t, i]
						);
					}),
					(c.prototype.fillSetter = function () {
						c.prototype.strokeSetter.apply(this, arguments);
					}),
					(c.prototype.strokeSetter = function () {
						this.elem.attr(
							this.prop,
							o(this.start).tweenTo(o(this.end), this.pos),
							void 0,
							!0
						);
					}),
					(c.timers = []),
					c
				);
			}
		),
		e(
			t,
			"Core/Animation/AnimationUtilities.js",
			[t["Core/Animation/Fx.js"], t["Core/Utilities.js"]],
			function (l, t) {
				var n = t.defined,
					c = t.getStyle,
					d = t.isArray,
					e = t.isNumber,
					p = t.isObject,
					u = t.merge,
					f = t.objectEach,
					i = t.pick;
				function a(t) {
					return p(t)
						? u({ duration: 500, defer: 0 }, t)
						: { duration: t ? 500 : 0, defer: 0 };
				}
				function g(t, e) {
					for (var i = l.timers.length; i--; )
						l.timers[i].elem !== t ||
							(e && e !== l.timers[i].prop) ||
							(l.timers[i].stopped = !0);
				}
				return {
					animate: function (i, o, r) {
						var s,
							n,
							a,
							t,
							h = "";
						p(r) ||
							(r = {
								duration: (t = arguments)[2],
								easing: t[3],
								complete: t[4],
							}),
							e(r.duration) || (r.duration = 400),
							(r.easing =
								"function" == typeof r.easing
									? r.easing
									: Math[r.easing] || Math.easeInOutSine),
							(r.curAnim = u(o)),
							f(o, function (t, e) {
								g(i, e),
									(a = new l(i, r, e)),
									(n = void 0),
									"d" === e && d(o.d)
										? ((a.paths = a.initPath(i, i.pathArray, o.d)),
										  (a.toD = o.d),
										  (s = 0),
										  (n = 1))
										: i.attr
										? (s = i.attr(e))
										: ((s = parseFloat(c(i, e)) || 0),
										  "opacity" !== e && (h = "px")),
									"string" == typeof (n = n || t) &&
										n.match("px") &&
										(n = n.replace(/px/g, "")),
									a.run(s, n, h);
							});
					},
					animObject: a,
					getDeferredAnimation: function (t, e, i) {
						var o = a(e),
							i = i ? [i] : t.series,
							r = 0,
							s = 0;
						return (
							i.forEach(function (t) {
								t = a(t.options.animation);
								(r =
									e && n(e.defer)
										? o.defer
										: Math.max(r, t.duration + t.defer)),
									(s = Math.min(o.duration, t.duration));
							}),
							t.renderer.forExport && (r = 0),
							{ defer: Math.max(0, r - s), duration: Math.min(r, s) }
						);
					},
					setAnimation: function (t, e) {
						e.renderer.globalAnimation = i(t, e.options.chart.animation, !0);
					},
					stop: g,
				};
			}
		),
		e(
			t,
			"Core/Renderer/HTML/AST.js",
			[t["Core/Globals.js"], t["Core/Utilities.js"]],
			function (c, t) {
				var d = c.SVG_NS,
					e = c.win,
					p = t.attr,
					o = t.createElement,
					u = t.css,
					f = t.error,
					i = t.isFunction,
					r = t.isString,
					g = t.objectEach,
					s = t.splat,
					t = e.trustedTypes,
					a =
						t &&
						i(t.createPolicy) &&
						t.createPolicy("highcharts", {
							createHTML: function (t) {
								return t;
							},
						}),
					n = a ? a.createHTML("") : "",
					h = (function () {
						try {
							return Boolean(new DOMParser().parseFromString(n, "text/html"));
						} catch (t) {
							return !1;
						}
					})();
				function m(t) {
					this.nodes = "string" == typeof t ? this.parseMarkup(t) : t;
				}
				return (
					(m.filterUserAttributes = function (o) {
						return (
							g(o, function (e, t) {
								var i = !0;
								-1 === m.allowedAttributes.indexOf(t) && (i = !1),
									(i =
										-1 !==
										["background", "dynsrc", "href", "lowsrc", "src"].indexOf(t)
											? r(e) &&
											  m.allowedReferences.some(function (t) {
													return 0 === e.indexOf(t);
											  })
											: i) ||
										(f(33, !1, void 0, {
											"Invalid attribute in config": "".concat(t),
										}),
										delete o[t]),
									r(e) && o[t] && (o[t] = e.replace(/</g, "&lt;"));
							}),
							o
						);
					}),
					(m.parseStyle = function (t) {
						return t.split(";").reduce(function (t, e) {
							var e = e.split(":").map(function (t) {
									return t.trim();
								}),
								i = e.shift();
							return (
								i &&
									e.length &&
									(t[
										i.replace(/-([a-z])/g, function (t) {
											return t[1].toUpperCase();
										})
									] = e.join(":")),
								t
							);
						}, {});
					}),
					(m.setElementHTML = function (t, e) {
						(t.innerHTML = m.emptyHTML), e && new m(e).addToDOM(t);
					}),
					(m.prototype.addToDOM = function (t) {
						return (function a(t, h) {
							var l;
							return (
								s(t).forEach(function (t) {
									var e,
										i,
										o,
										r = t.tagName,
										s = t.textContent
											? c.doc.createTextNode(t.textContent)
											: void 0,
										n = m.bypassHTMLFiltering;
									r &&
										("#text" === r
											? (e = s)
											: -1 !== m.allowedTags.indexOf(r) || n
											? ((i = ("svg" !== r && h.namespaceURI) || d),
											  (i = c.doc.createElementNS(i, r)),
											  (o = t.attributes || {}),
											  g(t, function (t, e) {
													"tagName" !== e &&
														"attributes" !== e &&
														"children" !== e &&
														"style" !== e &&
														"textContent" !== e &&
														(o[e] = t);
											  }),
											  p(i, n ? o : m.filterUserAttributes(o)),
											  t.style && u(i, t.style),
											  s && i.appendChild(s),
											  a(t.children || [], i),
											  (e = i))
											: f(33, !1, void 0, { "Invalid tagName in config": r })),
										e && h.appendChild(e),
										(l = e);
								}),
								l
							);
						})(this.nodes, t);
					}),
					(m.prototype.parseMarkup = function (t) {
						function n(t, e) {
							var i,
								o,
								r = t.nodeName.toLowerCase(),
								s = { tagName: r };
							"#text" === r && (s.textContent = t.textContent || ""),
								(r = t.attributes) &&
									((i = {}),
									[].forEach.call(r, function (t) {
										"data-style" === t.name
											? (s.style = m.parseStyle(t.value))
											: (i[t.name] = t.value);
									}),
									(s.attributes = i)),
								t.childNodes.length &&
									((o = []),
									[].forEach.call(t.childNodes, function (t) {
										n(t, o);
									}),
									o.length && (s.children = o)),
								e.push(s);
						}
						var e,
							i = [];
						(t = t.trim().replace(/ style=(["'])/g, " data-style=$1")),
							(t = h
								? new DOMParser().parseFromString(
										a ? a.createHTML(t) : t,
										"text/html"
								  )
								: (((e = o("div")).innerHTML = t), { body: e }));
						return (
							[].forEach.call(t.body.childNodes, function (t) {
								return n(t, i);
							}),
							i
						);
					}),
					(m.allowedAttributes = [
						"aria-controls",
						"aria-describedby",
						"aria-expanded",
						"aria-haspopup",
						"aria-hidden",
						"aria-label",
						"aria-labelledby",
						"aria-live",
						"aria-pressed",
						"aria-readonly",
						"aria-roledescription",
						"aria-selected",
						"class",
						"clip-path",
						"color",
						"colspan",
						"cx",
						"cy",
						"d",
						"dx",
						"dy",
						"disabled",
						"fill",
						"height",
						"href",
						"id",
						"in",
						"markerHeight",
						"markerWidth",
						"offset",
						"opacity",
						"orient",
						"padding",
						"paddingLeft",
						"paddingRight",
						"patternUnits",
						"r",
						"refX",
						"refY",
						"role",
						"scope",
						"slope",
						"src",
						"startOffset",
						"stdDeviation",
						"stroke",
						"stroke-linecap",
						"stroke-width",
						"style",
						"tableValues",
						"result",
						"rowspan",
						"summary",
						"target",
						"tabindex",
						"text-align",
						"text-anchor",
						"textAnchor",
						"textLength",
						"title",
						"type",
						"valign",
						"width",
						"x",
						"x1",
						"x2",
						"xlink:href",
						"y",
						"y1",
						"y2",
						"zIndex",
					]),
					(m.allowedReferences = [
						"https://",
						"http://",
						"mailto:",
						"/",
						"../",
						"./",
						"#",
					]),
					(m.allowedTags = [
						"a",
						"abbr",
						"b",
						"br",
						"button",
						"caption",
						"circle",
						"clipPath",
						"code",
						"dd",
						"defs",
						"div",
						"dl",
						"dt",
						"em",
						"feComponentTransfer",
						"feFuncA",
						"feFuncB",
						"feFuncG",
						"feFuncR",
						"feGaussianBlur",
						"feOffset",
						"feMerge",
						"feMergeNode",
						"filter",
						"h1",
						"h2",
						"h3",
						"h4",
						"h5",
						"h6",
						"hr",
						"i",
						"img",
						"li",
						"linearGradient",
						"marker",
						"ol",
						"p",
						"path",
						"pattern",
						"pre",
						"rect",
						"small",
						"span",
						"stop",
						"strong",
						"style",
						"sub",
						"sup",
						"svg",
						"table",
						"text",
						"textPath",
						"thead",
						"title",
						"tbody",
						"tspan",
						"td",
						"th",
						"tr",
						"u",
						"ul",
						"#text",
					]),
					(m.emptyHTML = n),
					(m.bypassHTMLFiltering = !1),
					m
				);
			}
		),
		e(
			t,
			"Core/FormatUtilities.js",
			[t["Core/Defaults.js"], t["Core/Utilities.js"]],
			function (t, e) {
				var g = t.defaultOptions,
					m = t.defaultTime,
					y = e.getNestedProperty,
					c = e.isNumber,
					d = e.pick,
					p = e.pInt;
				function v(t, e, i, o) {
					e = +e;
					var r = g.lang,
						s = ((t = +t || 0).toString().split(".")[1] || "").split("e")[0]
							.length,
						n = t.toString().split("e"),
						a = e,
						h =
							(-1 === e
								? (e = Math.min(s, 20))
								: c(e)
								? e &&
								  n[1] &&
								  n[1] < 0 &&
								  (0 <= (h = e + +n[1])
										? ((n[0] = (+n[0]).toExponential(h).split("e")[0]), (e = h))
										: ((n[0] = n[0].split(".")[0] || 0),
										  (t = e < 20 ? (n[0] * Math.pow(10, n[1])).toFixed(e) : 0),
										  (n[1] = 0)))
								: (e = 2),
							(
								Math.abs(n[1] ? n[0] : t) + Math.pow(10, -Math.max(e, s) - 1)
							).toFixed(e)),
						s = String(p(h)),
						l = 3 < s.length ? s.length % 3 : 0;
					return (
						(i = d(i, r.decimalPoint)),
						(o = d(o, r.thousandsSep)),
						(r = t < 0 ? "-" : ""),
						(r += l ? s.substr(0, l) + o : ""),
						+n[1] < 0 && !a
							? (r = "0")
							: (r += s.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + o)),
						e && (r += i + h.slice(-e)),
						n[1] && 0 != +r && (r += "e" + n[1]),
						r
					);
				}
				return {
					dateFormat: function (t, e, i) {
						return m.dateFormat(t, e, i);
					},
					format: function (t, e, i) {
						for (
							var o,
								r,
								s,
								n,
								a = "{",
								h = !1,
								l = /f$/,
								c = /\.([0-9])/,
								d = g.lang,
								p = (i && i.time) || m,
								u = (i && i.numberFormatter) || v,
								f = [];
							t && -1 !== (o = t.indexOf(a));

						)
							(r = t.slice(0, o)),
								h
									? ((s = r.split(":")),
									  (n = y(s.shift() || "", e)),
									  s.length &&
											"number" == typeof n &&
											((r = s.join(":")),
											l.test(r)
												? ((s = parseInt((r.match(c) || ["", "-1"])[1], 10)),
												  null !== n &&
														(n = u(
															n,
															s,
															d.decimalPoint,
															-1 < r.indexOf(",") ? d.thousandsSep : ""
														)))
												: (n = p.dateFormat(r, n))),
									  f.push(n))
									: f.push(r),
								(t = t.slice(o + 1)),
								(a = (h = !h) ? "}" : "{");
						return f.push(t), f.join("");
					},
					numberFormat: v,
				};
			}
		),
		e(
			t,
			"Core/Renderer/RendererUtilities.js",
			[t["Core/Utilities.js"]],
			function (t) {
				var e,
					u = t.clamp,
					f = t.pick,
					g = t.stableSort;
				return (
					((e || (e = {})).distribute = function i(t, o, r) {
						for (
							var e,
								s,
								n = t,
								a = n.reducedLen || o,
								h = function (t, e) {
									return t.target - e.target;
								},
								l = !0,
								c = [],
								d = 0,
								p = t.length;
							p--;

						)
							d += t[p].size;
						if (a < d) {
							for (
								g(t, function (t, e) {
									return (e.rank || 0) - (t.rank || 0);
								}),
									d = p = 0;
								d <= a;

							)
								(d += t[p].size), p++;
							c = t.splice(p - 1, t.length);
						}
						for (
							g(t, h),
								t = t.map(function (t) {
									return {
										size: t.size,
										targets: [t.target],
										align: f(t.align, 0.5),
									};
								});
							l;

						) {
							for (p = t.length; p--; )
								(e = t[p]),
									(s =
										(Math.min.apply(0, e.targets) +
											Math.max.apply(0, e.targets)) /
										2),
									(e.pos = u(s - e.size * e.align, 0, o - e.size));
							for (p = t.length, l = !1; p--; )
								0 < p &&
									t[p - 1].pos + t[p - 1].size > t[p].pos &&
									((t[p - 1].size += t[p].size),
									(t[p - 1].targets = t[p - 1].targets.concat(t[p].targets)),
									(t[p - 1].align = 0.5),
									t[p - 1].pos + t[p - 1].size > o &&
										(t[p - 1].pos = o - t[p - 1].size),
									t.splice(p, 1),
									(l = !0));
						}
						return (
							n.push.apply(n, c),
							(p = 0),
							t.some(function (t) {
								var e = 0;
								return (t.targets || []).some(function () {
									return (
										(n[p].pos = t.pos + e),
										void 0 !== r && Math.abs(n[p].pos - n[p].target) > r
											? (n.slice(0, p + 1).forEach(function (t) {
													return delete t.pos;
											  }),
											  (n.reducedLen = (n.reducedLen || o) - 0.1 * o),
											  n.reducedLen > 0.1 * o && i(n, o, r),
											  !0)
											: ((e += n[p].size), p++, !1)
									);
								});
							}),
							g(n, h),
							n
						);
					}),
					e
				);
			}
		),
		e(
			t,
			"Core/Renderer/SVG/SVGElement.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Color/Color.js"],
				t["Core/Globals.js"],
				t["Core/Utilities.js"],
			],
			function (t, m, s, e) {
				var n = t.animate,
					a = t.animObject,
					c = t.stop,
					g = s.deg2rad,
					h = s.doc,
					l = (s.noop, s.svg),
					d = s.SVG_NS,
					i = s.win,
					p = e.addEvent,
					y = e.attr,
					o = e.createElement,
					v = e.css,
					x = e.defined,
					u = e.erase,
					b = e.extend,
					S = e.fireEvent,
					k = e.isArray,
					C = e.isFunction,
					f = (e.isNumber, e.isString),
					M = e.merge,
					w = e.objectEach,
					T = e.pick,
					A = e.pInt,
					P = (e.removeEvent, e.syncTimeout),
					L = e.uniqueKey,
					t =
						((O.prototype._defaultGetter = function (t) {
							t = T(
								this[t + "Value"],
								this[t],
								this.element ? this.element.getAttribute(t) : null,
								0
							);
							return (t = /^[\-0-9\.]+$/.test(t) ? parseFloat(t) : t);
						}),
						(O.prototype._defaultSetter = function (t, e, i) {
							i.setAttribute(e, t);
						}),
						(O.prototype.add = function (t) {
							var e,
								i = this.renderer,
								o = this.element;
							return (
								t && (this.parentGroup = t),
								void 0 !== this.textStr &&
									"text" === this.element.nodeName &&
									i.buildText(this),
								(this.added = !0),
								(e =
									t && !t.handleZ && !this.zIndex ? e : this.zIndexSetter()) ||
									(t ? t.element : i.box).appendChild(o),
								this.onAdd && this.onAdd(),
								this
							);
						}),
						(O.prototype.addClass = function (t, e) {
							var i = (!e && this.attr("class")) || "";
							return (
								(t = (t || "")
									.split(/ /g)
									.reduce(
										function (t, e) {
											return -1 === i.indexOf(e) && t.push(e), t;
										},
										i ? [i] : []
									)
									.join(" ")) !== i && this.attr("class", t),
								this
							);
						}),
						(O.prototype.afterSetters = function () {
							this.doTransform &&
								(this.updateTransform(), (this.doTransform = !1));
						}),
						(O.prototype.align = function (t, e, i) {
							var o,
								r,
								s = {},
								n = this.renderer,
								a = n.alignedObjects,
								a =
									(t
										? ((this.alignOptions = t),
										  (this.alignByTranslate = e),
										  (i && !f(i)) ||
												((this.alignTo = h = i || "renderer"),
												u(a, this),
												a.push(this),
												(i = void 0)))
										: ((t = this.alignOptions),
										  (e = this.alignByTranslate),
										  (h = this.alignTo)),
									(i = T(
										i,
										n[h],
										"scrollablePlotBox" === h ? n.plotBox : void 0,
										n
									)),
									t.align),
								h = t.verticalAlign,
								n = (i.x || 0) + (t.x || 0),
								l = (i.y || 0) + (t.y || 0);
							return (
								"right" === a ? (o = 1) : "center" === a && (o = 2),
								o && (n += (i.width - (t.width || 0)) / o),
								(s[e ? "translateX" : "x"] = Math.round(n)),
								"bottom" === h ? (r = 1) : "middle" === h && (r = 2),
								r && (l += (i.height - (t.height || 0)) / r),
								(s[e ? "translateY" : "y"] = Math.round(l)),
								this[this.placed ? "animate" : "attr"](s),
								(this.placed = !0),
								(this.alignAttr = s),
								this
							);
						}),
						(O.prototype.alignSetter = function (t) {
							var e = { left: "start", center: "middle", right: "end" };
							e[t] &&
								((this.alignValue = t),
								this.element.setAttribute("text-anchor", e[t]));
						}),
						(O.prototype.animate = function (t, e, i) {
							var o = this,
								r = a(T(e, this.renderer.globalAnimation, !0)),
								e = r.defer;
							return (
								T(h.hidden, h.msHidden, h.webkitHidden, !1) && (r.duration = 0),
								0 !== r.duration
									? (i && (r.complete = i),
									  P(function () {
											o.element && n(o, t, r);
									  }, e))
									: (this.attr(t, void 0, i || r.complete),
									  w(
											t,
											function (t, e) {
												r.step &&
													r.step.call(this, t, { prop: e, pos: 1, elem: this });
											},
											this
									  )),
								this
							);
						}),
						(O.prototype.applyTextOutline = function (t) {
							var i,
								e,
								o = this.element,
								t = (t =
									-1 !== t.indexOf("contrast")
										? t.replace(
												/contrast/g,
												this.renderer.getContrast(o.style.fill)
										  )
										: t).split(" "),
								r = t[t.length - 1],
								t = t[0];
							t &&
								"none" !== t &&
								s.svg &&
								((this.fakeTS = !0),
								(t = t.replace(/(^[\d\.]+)(.*?)$/g, function (t, e, i) {
									return 2 * Number(e) + i;
								})),
								this.removeTextOutline(),
								(i = h.createElementNS(d, "tspan")),
								y(i, {
									class: "highcharts-text-outline",
									fill: r,
									stroke: r,
									"stroke-width": t,
									"stroke-linejoin": "round",
								}),
								(r = o.querySelector("textPath") || o),
								[].forEach.call(r.childNodes, function (t) {
									var e = t.cloneNode(!0);
									e.removeAttribute &&
										["fill", "stroke", "stroke-width", "stroke"].forEach(
											function (t) {
												return e.removeAttribute(t);
											}
										),
										i.appendChild(e);
								}),
								(e = 0),
								[].forEach.call(r.querySelectorAll("text tspan"), function (t) {
									e += Number(t.getAttribute("dy"));
								}),
								((t = h.createElementNS(d, "tspan")).textContent = "​"),
								y(t, { x: Number(o.getAttribute("x")), dy: -e }),
								i.appendChild(t),
								r.insertBefore(i, r.firstChild));
						}),
						(O.prototype.attr = function (i, t, e, o) {
							var r,
								s,
								n,
								a = this.element,
								h = this.symbolCustomAttribs,
								l = this;
							return (
								"string" == typeof i &&
									void 0 !== t &&
									((r = i), ((i = {})[r] = t)),
								"string" == typeof i
									? (l = (this[i + "Getter"] || this._defaultGetter).call(
											this,
											i,
											a
									  ))
									: (w(
											i,
											function (t, e) {
												(n = !1),
													o || c(this, e),
													this.symbolName &&
														-1 !== h.indexOf(e) &&
														(s || (this.symbolAttr(i), (s = !0)), (n = !0)),
													!this.rotation ||
														("x" !== e && "y" !== e) ||
														(this.doTransform = !0),
													n ||
														((n =
															this[e + "Setter"] || this._defaultSetter).call(
															this,
															t,
															e,
															a
														),
														!this.styledMode &&
															this.shadows &&
															/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(
																e
															) &&
															this.updateShadows(e, t, n));
											},
											this
									  ),
									  this.afterSetters()),
								e && e.call(this),
								l
							);
						}),
						(O.prototype.clip = function (t) {
							return this.attr(
								"clip-path",
								t ? "url(" + this.renderer.url + "#" + t.id + ")" : "none"
							);
						}),
						(O.prototype.crisp = function (t, e) {
							e = e || t.strokeWidth || 0;
							var i = (Math.round(e) % 2) / 2;
							return (
								(t.x = Math.floor(t.x || this.x || 0) + i),
								(t.y = Math.floor(t.y || this.y || 0) + i),
								(t.width = Math.floor((t.width || this.width || 0) - 2 * i)),
								(t.height = Math.floor((t.height || this.height || 0) - 2 * i)),
								x(t.strokeWidth) && (t.strokeWidth = e),
								t
							);
						}),
						(O.prototype.complexColor = function (t, i, o) {
							var r,
								s,
								n,
								a,
								h,
								l,
								c,
								d,
								p,
								u,
								f = this.renderer,
								g = [];
							S(
								this.renderer,
								"complexColor",
								{ args: arguments },
								function () {
									var e;
									t.radialGradient
										? (r = "radialGradient")
										: t.linearGradient && (r = "linearGradient"),
										r &&
											((s = t[r]),
											(a = f.gradients),
											(h = t.stops),
											(d = o.radialReference),
											k(s) &&
												(t[r] = s =
													{
														x1: s[0],
														y1: s[1],
														x2: s[2],
														y2: s[3],
														gradientUnits: "userSpaceOnUse",
													}),
											"radialGradient" === r &&
												d &&
												!x(s.gradientUnits) &&
												(s = M((n = s), f.getRadialAttr(d, n), {
													gradientUnits: "userSpaceOnUse",
												})),
											w(s, function (t, e) {
												"id" !== e && g.push(e, t);
											}),
											w(h, function (t) {
												g.push(t);
											}),
											(g = g.join(",")),
											a[g]
												? (p = a[g].attr("id"))
												: ((s.id = p = L()),
												  ((e = a[g] =
														f.createElement(r).attr(s).add(f.defs)).radAttr =
														n),
												  (e.stops = []),
												  h.forEach(function (t) {
														c =
															0 === t[1].indexOf("rgba")
																? ((c = m.parse(t[1])),
																  (l = c.get("rgb")),
																  c.get("a"))
																: ((l = t[1]), 1);
														t = f
															.createElement("stop")
															.attr({
																offset: t[0],
																"stop-color": l,
																"stop-opacity": c,
															})
															.add(e);
														e.stops.push(t);
												  })),
											(u = "url(" + f.url + "#" + p + ")"),
											o.setAttribute(i, u),
											(o.gradient = g),
											(t.toString = function () {
												return u;
											}));
								}
							);
						}),
						(O.prototype.css = function (t) {
							var e,
								i,
								o = this.styles,
								r = {},
								s = this.element,
								n = !o;
							return (
								t.color && (t.fill = t.color),
								o &&
									w(t, function (t, e) {
										o && o[e] !== t && ((r[e] = t), (n = !0));
									}),
								n &&
									(null === (t = o ? b(o, r) : t).width || "auto" === t.width
										? delete this.textWidth
										: "text" === s.nodeName.toLowerCase() &&
										  t.width &&
										  (e = this.textWidth = A(t.width)),
									(this.styles = t),
									e && !l && this.renderer.forExport && delete t.width,
									(i = M(t)),
									s.namespaceURI === this.SVG_NS &&
										["textOutline", "textOverflow", "width"].forEach(function (
											t
										) {
											return i && delete i[t];
										}),
									v(s, i),
									this.added &&
										("text" === this.element.nodeName &&
											this.renderer.buildText(this),
										t.textOutline && this.applyTextOutline(t.textOutline))),
								this
							);
						}),
						(O.prototype.dashstyleSetter = function (t) {
							var e = this["stroke-width"];
							if (("inherit" === e && (e = 1), (t = t && t.toLowerCase()))) {
								for (
									var i = t
											.replace("shortdashdotdot", "3,1,1,1,1,1,")
											.replace("shortdashdot", "3,1,1,1")
											.replace("shortdot", "1,1,")
											.replace("shortdash", "3,1,")
											.replace("longdash", "8,3,")
											.replace(/dot/g, "1,3,")
											.replace("dash", "4,3,")
											.replace(/,$/, "")
											.split(","),
										o = i.length;
									o--;

								)
									i[o] = "" + A(i[o]) * T(e, NaN);
								(t = i.join(",").replace(/NaN/g, "none")),
									this.element.setAttribute("stroke-dasharray", t);
							}
						}),
						(O.prototype.destroy = function () {
							var t,
								e,
								i,
								o = this,
								r = o.element || {},
								s = o.renderer,
								n = r.ownerSVGElement,
								a =
									(s.isSVG && "SPAN" === r.nodeName && o.parentGroup) || void 0;
							if (
								((r.onclick =
									r.onmouseout =
									r.onmouseover =
									r.onmousemove =
									r.point =
										null),
								c(o),
								o.clipPath &&
									n &&
									((i = o.clipPath),
									[].forEach.call(
										n.querySelectorAll("[clip-path],[CLIP-PATH]"),
										function (t) {
											-1 < t.getAttribute("clip-path").indexOf(i.element.id) &&
												t.removeAttribute("clip-path");
										}
									),
									(o.clipPath = i.destroy())),
								o.stops)
							) {
								for (e = 0; e < o.stops.length; e++) o.stops[e].destroy();
								(o.stops.length = 0), (o.stops = void 0);
							}
							for (
								o.safeRemoveChild(r), s.styledMode || o.destroyShadows();
								a && a.div && 0 === a.div.childNodes.length;

							)
								(t = a.parentGroup),
									o.safeRemoveChild(a.div),
									delete a.div,
									(a = t);
							o.alignTo && u(s.alignedObjects, o),
								w(o, function (t, e) {
									o[e] &&
										o[e].parentGroup === o &&
										o[e].destroy &&
										o[e].destroy(),
										delete o[e];
								});
						}),
						(O.prototype.destroyShadows = function () {
							(this.shadows || []).forEach(function (t) {
								this.safeRemoveChild(t);
							}, this),
								(this.shadows = void 0);
						}),
						(O.prototype.dSetter = function (t, e, i) {
							k(t) &&
								("string" == typeof t[0] &&
									(t = this.renderer.pathToSegments(t)),
								(t = (this.pathArray = t).reduce(function (t, e, i) {
									return e && e.join
										? (i ? t + " " : "") + e.join(" ")
										: (e || "").toString();
								}, ""))),
								/(NaN| {2}|^$)/.test(t) && (t = "M 0 0"),
								this[e] !== t && (i.setAttribute(e, t), (this[e] = t));
						}),
						(O.prototype.fadeOut = function (t) {
							var e = this;
							e.animate(
								{ opacity: 0 },
								{
									duration: T(t, 150),
									complete: function () {
										e.hide();
									},
								}
							);
						}),
						(O.prototype.fillSetter = function (t, e, i) {
							"string" == typeof t
								? i.setAttribute(e, t)
								: t && this.complexColor(t, e, i);
						}),
						(O.prototype.getBBox = function (t, e) {
							var i,
								o,
								r,
								s = this,
								n = s.alignValue,
								a = s.element,
								h = s.renderer,
								l = s.styles,
								c = s.textStr,
								d = h.cache,
								p = h.cacheKeys,
								u = a.namespaceURI === s.SVG_NS,
								e = T(e, s.rotation, 0),
								f = h.styledMode
									? a && O.prototype.getStyle.call(a, "font-size")
									: l && l.fontSize;
							if (
								(x(c) &&
									(-1 === (o = c.toString()).indexOf("<") &&
										(o = o.replace(/[0-9]/g, "0")),
									(o += [
										"",
										e,
										f,
										s.textWidth,
										n,
										l && l.textOverflow,
										l && l.fontWeight,
									].join(","))),
								!(i = o && !t ? d[o] : i))
							) {
								if (u || h.forExport) {
									try {
										(r =
											this.fakeTS &&
											function (t) {
												var e = a.querySelector(".highcharts-text-outline");
												e && v(e, { display: t });
											}),
											C(r) && r("none"),
											(i = a.getBBox
												? b({}, a.getBBox())
												: {
														width: a.offsetWidth,
														height: a.offsetHeight,
														x: 0,
														y: 0,
												  }),
											C(r) && r("");
									} catch (t) {}
									(!i || i.width < 0) &&
										(i = { x: 0, y: 0, width: 0, height: 0 });
								} else i = s.htmlGetBBox();
								if (
									(h.isSVG &&
										((l = i.width),
										(t = i.height),
										u &&
											(i.height = t =
												{ "11px,17": 14, "13px,20": 16 }[
													"" + (f || "") + ",".concat(Math.round(t))
												] || t),
										e &&
											((r = Number(a.getAttribute("y") || 0) - i.y),
											(s = { right: 1, center: 0.5 }[n || 0] || 0),
											(h = e * g),
											(u = (e - 90) * g),
											(f = l * Math.cos(h)),
											(n = l * Math.sin(h)),
											(e = Math.cos(u)),
											(h = Math.sin(u)),
											(f =
												(e =
													(l = (u = i.x + s * (l - f) + r * e) + f) - t * e) -
												f),
											(h =
												(t = (r = (s = i.y + r - s * n + r * h) + n) - t * h) -
												n),
											(i.x = Math.min(u, l, e, f)),
											(i.y = Math.min(s, r, t, h)),
											(i.width = Math.max(u, l, e, f) - i.x),
											(i.height = Math.max(s, r, t, h) - i.y))),
									o && ("" === c || 0 < i.height))
								) {
									for (; 250 < p.length; ) delete d[p.shift()];
									d[o] || p.push(o), (d[o] = i);
								}
							}
							return i;
						}),
						(O.prototype.getStyle = function (t) {
							return i
								.getComputedStyle(this.element || this, "")
								.getPropertyValue(t);
						}),
						(O.prototype.hasClass = function (t) {
							return -1 !== ("" + this.attr("class")).split(" ").indexOf(t);
						}),
						(O.prototype.hide = function () {
							return this.attr({ visibility: "hidden" });
						}),
						(O.prototype.htmlGetBBox = function () {
							return { height: 0, width: 0, x: 0, y: 0 };
						}),
						(O.prototype.init = function (t, e) {
							(this.element =
								"span" === e ? o(e) : h.createElementNS(this.SVG_NS, e)),
								(this.renderer = t),
								S(this, "afterInit");
						}),
						(O.prototype.on = function (t, e) {
							var i = this.onEvents;
							return i[t] && i[t](), (i[t] = p(this.element, t, e)), this;
						}),
						(O.prototype.opacitySetter = function (t, e, i) {
							t = Number(Number(t).toFixed(3));
							(this.opacity = t), i.setAttribute(e, t);
						}),
						(O.prototype.removeClass = function (t) {
							return this.attr(
								"class",
								("" + this.attr("class"))
									.replace(
										f(t) ? new RegExp("(^| )".concat(t, "( |$)")) : t,
										" "
									)
									.replace(/ +/g, " ")
									.trim()
							);
						}),
						(O.prototype.removeTextOutline = function () {
							var t = this.element.querySelector(
								"tspan.highcharts-text-outline"
							);
							t && this.safeRemoveChild(t);
						}),
						(O.prototype.safeRemoveChild = function (t) {
							var e = t.parentNode;
							e && e.removeChild(t);
						}),
						(O.prototype.setRadialReference = function (t) {
							var e =
								this.element.gradient &&
								this.renderer.gradients[this.element.gradient];
							return (
								(this.element.radialReference = t),
								e &&
									e.radAttr &&
									e.animate(this.renderer.getRadialAttr(t, e.radAttr)),
								this
							);
						}),
						(O.prototype.setTextPath = function (o, t) {
							var r = this,
								s =
									((t = M(
										!0,
										{
											enabled: !0,
											attributes: {
												dy: -5,
												startOffset: "50%",
												textAnchor: "middle",
											},
										},
										t
									)),
									this.renderer.url),
								n = this.text || this,
								e = n.textPath,
								a = t.attributes,
								h = t.enabled;
							return (
								(o = o || (e && e.path)),
								e && e.undo(),
								o && h
									? ((t = p(n, "afterModifyTree", function (t) {
											var e, i;
											o &&
												h &&
												((e = o.attr("id")) || o.attr("id", (e = L())),
												(i = { x: 0, y: 0 }),
												x(a.dx) && ((i.dx = a.dx), delete a.dx),
												x(a.dy) && ((i.dy = a.dy), delete a.dy),
												n.attr(i),
												r.attr({ transform: "" }),
												r.box && (r.box = r.box.destroy()),
												(i = t.nodes.slice(0)),
												(t.nodes.length = 0),
												(t.nodes[0] = {
													tagName: "textPath",
													attributes: b(a, {
														"text-anchor": a.textAnchor,
														href: "" + s + "#".concat(e),
													}),
													children: i,
												}));
									  })),
									  (n.textPath = { path: o, undo: t }))
									: (n.attr({ dx: 0, dy: 0 }), delete n.textPath),
								this.added && ((n.textCache = ""), this.renderer.buildText(n)),
								this
							);
						}),
						(O.prototype.shadow = function (t, e, i) {
							var o,
								r,
								s,
								n,
								a,
								h,
								l = [],
								c = this.element,
								d = this.oldShadowOptions,
								p = this.parentGroup,
								p = p && 90 === p.rotation,
								u = {
									color: "#000000",
									offsetX: p ? -1 : 1,
									offsetY: p ? -1 : 1,
									opacity: 0.15,
									width: 3,
								},
								f = !1;
							if (
								(!0 === t ? (h = u) : "object" == typeof t && (h = b(u, t)),
								h &&
									(d &&
										w(h, function (t, e) {
											t !== d[e] && (f = !0);
										}),
									f && this.destroyShadows(),
									(this.oldShadowOptions = h)),
								h)
							) {
								if (!this.shadows) {
									for (
										n = h.opacity / h.width,
											a = p
												? "translate("
														.concat(h.offsetY, ", ")
														.concat(h.offsetX, ")")
												: "translate("
														.concat(h.offsetX, ", ")
														.concat(h.offsetY, ")"),
											o = 1;
										o <= h.width;
										o++
									)
										(r = c.cloneNode(!1)),
											(s = 2 * h.width + 1 - 2 * o),
											y(r, {
												stroke: t.color || "#000000",
												"stroke-opacity": n * o,
												"stroke-width": s,
												transform: a,
												fill: "none",
											}),
											r.setAttribute(
												"class",
												(r.getAttribute("class") || "") + " highcharts-shadow"
											),
											i &&
												(y(r, "height", Math.max(y(r, "height") - s, 0)),
												(r.cutHeight = s)),
											e
												? e.element.appendChild(r)
												: c.parentNode && c.parentNode.insertBefore(r, c),
											l.push(r);
									this.shadows = l;
								}
							} else this.destroyShadows();
							return this;
						}),
						(O.prototype.show = function (t) {
							return this.attr({
								visibility: (t = void 0 === t ? !0 : t) ? "inherit" : "visible",
							});
						}),
						(O.prototype["stroke-widthSetter"] = function (t, e, i) {
							(this[e] = t), i.setAttribute(e, t);
						}),
						(O.prototype.strokeWidth = function () {
							if (!this.renderer.styledMode) return this["stroke-width"] || 0;
							var t,
								e = this.getStyle("stroke-width"),
								i = 0;
							return (
								e.indexOf("px") === e.length - 2
									? (i = A(e))
									: "" !== e &&
									  ((t = h.createElementNS(d, "rect")),
									  y(t, { width: e, "stroke-width": 0 }),
									  this.element.parentNode.appendChild(t),
									  (i = t.getBBox().width),
									  t.parentNode.removeChild(t)),
								i
							);
						}),
						(O.prototype.symbolAttr = function (e) {
							var i = this;
							[
								"x",
								"y",
								"r",
								"start",
								"end",
								"width",
								"height",
								"innerR",
								"anchorX",
								"anchorY",
								"clockwise",
							].forEach(function (t) {
								i[t] = T(e[t], i[t]);
							}),
								i.attr({
									d: i.renderer.symbols[i.symbolName](
										i.x,
										i.y,
										i.width,
										i.height,
										i
									),
								});
						}),
						(O.prototype.textSetter = function (t) {
							t !== this.textStr &&
								(delete this.textPxLength,
								(this.textStr = t),
								this.added && this.renderer.buildText(this));
						}),
						(O.prototype.titleSetter = function (t) {
							var e = this.element,
								i =
									e.getElementsByTagName("title")[0] ||
									h.createElementNS(this.SVG_NS, "title");
							e.insertBefore
								? e.insertBefore(i, e.firstChild)
								: e.appendChild(i),
								(i.textContent = String(T(t, ""))
									.replace(/<[^>]*>/g, "")
									.replace(/&lt;/g, "<")
									.replace(/&gt;/g, ">"));
						}),
						(O.prototype.toFront = function () {
							var t = this.element;
							return t.parentNode.appendChild(t), this;
						}),
						(O.prototype.translate = function (t, e) {
							return this.attr({ translateX: t, translateY: e });
						}),
						(O.prototype.updateShadows = function (t, e, i) {
							var o = this.shadows;
							if (o)
								for (var r = o.length; r--; )
									i.call(
										o[r],
										"height" === t
											? Math.max(e - (o[r].cutHeight || 0), 0)
											: "d" === t
											? this.d
											: e,
										t,
										o[r]
									);
						}),
						(O.prototype.updateTransform = function () {
							var t = this,
								e = t.element,
								i = t.matrix,
								o = t.rotation,
								o = void 0 === o ? 0 : o,
								r = t.scaleX,
								s = t.scaleY,
								n = t.translateX,
								t = t.translateY,
								n = [
									"translate(" +
										(void 0 === n ? 0 : n) +
										"," +
										(void 0 === t ? 0 : t) +
										")",
								];
							x(i) && n.push("matrix(" + i.join(",") + ")"),
								o &&
									n.push(
										"rotate(" +
											o +
											" " +
											T(this.rotationOriginX, e.getAttribute("x"), 0) +
											" " +
											T(this.rotationOriginY, e.getAttribute("y") || 0) +
											")"
									),
								(x(r) || x(s)) &&
									n.push("scale(" + T(r, 1) + " " + T(s, 1) + ")"),
								n.length &&
									!(this.text || this).textPath &&
									e.setAttribute("transform", n.join(" "));
						}),
						(O.prototype.visibilitySetter = function (t, e, i) {
							"inherit" === t
								? i.removeAttribute(e)
								: this[e] !== t && i.setAttribute(e, t),
								(this[e] = t);
						}),
						(O.prototype.xGetter = function (t) {
							return (
								"circle" === this.element.nodeName &&
									("x" === t ? (t = "cx") : "y" === t && (t = "cy")),
								this._defaultGetter(t)
							);
						}),
						(O.prototype.zIndexSetter = function (t, e) {
							var i,
								o,
								r,
								s,
								n,
								a = this.renderer,
								h = this.parentGroup,
								l = (h || a).element || a.box,
								c = this.element,
								d = l === a.box,
								p = !1,
								a = this.added;
							if (
								(x(t)
									? (c.setAttribute("data-z-index", t),
									  this[e] === (t = +t) && (a = !1))
									: x(this[e]) && c.removeAttribute("data-z-index"),
								(this[e] = t),
								a)
							) {
								for (
									(t = this.zIndex) && h && (h.handleZ = !0),
										n = (i = l.childNodes).length - 1;
									0 <= n && !p;
									n--
								)
									(r = (o = i[n]).getAttribute("data-z-index")),
										(s = !x(r)),
										o !== c &&
											(t < 0 && s && !d && !n
												? (l.insertBefore(c, i[n]), (p = !0))
												: (A(r) <= t || (s && (!x(t) || 0 <= t))) &&
												  (l.insertBefore(c, i[n + 1] || null), (p = !0)));
								p || (l.insertBefore(c, i[d ? 3 : 0] || null), (p = !0));
							}
							return p;
						}),
						O);
				function O() {
					(this.element = void 0),
						(this.onEvents = {}),
						(this.opacity = 1),
						(this.renderer = void 0),
						(this.SVG_NS = d),
						(this.symbolCustomAttribs = [
							"x",
							"y",
							"width",
							"height",
							"r",
							"start",
							"end",
							"innerR",
							"anchorX",
							"anchorY",
							"rounded",
						]);
				}
				return (
					(t.prototype.strokeSetter = t.prototype.fillSetter),
					(t.prototype.yGetter = t.prototype.xGetter),
					(t.prototype.matrixSetter =
						t.prototype.rotationOriginXSetter =
						t.prototype.rotationOriginYSetter =
						t.prototype.rotationSetter =
						t.prototype.scaleXSetter =
						t.prototype.scaleYSetter =
						t.prototype.translateXSetter =
						t.prototype.translateYSetter =
						t.prototype.verticalAlignSetter =
							function (t, e) {
								(this[e] = t), (this.doTransform = !0);
							}),
					t
				);
			}
		),
		e(
			t,
			"Core/Renderer/RendererRegistry.js",
			[t["Core/Globals.js"]],
			function (o) {
				var t, r, s;
				return (
					((r = t = t || {}).rendererTypes = {}),
					(r.getRendererType = function (t) {
						return (
							void 0 === t && (t = s), r.rendererTypes[t] || r.rendererTypes[s]
						);
					}),
					(r.registerRendererType = function (t, e, i) {
						(r.rendererTypes[t] = e), (s && !i) || ((s = t), (o.Renderer = e));
					}),
					t
				);
			}
		),
		e(
			t,
			"Core/Renderer/SVG/SVGLabel.js",
			[t["Core/Renderer/SVG/SVGElement.js"], t["Core/Utilities.js"]],
			function (t, e) {
				var o,
					p,
					i =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					s = e.defined,
					n = e.extend,
					a = e.isNumber,
					r = e.merge,
					h = e.pick,
					l = e.removeEvent;
				function u(t, e, i, o, r, s, n, a, h, l) {
					var c,
						d = p.call(this) || this;
					return (
						(d.paddingLeftSetter = d.paddingSetter),
						(d.paddingRightSetter = d.paddingSetter),
						d.init(t, "g"),
						(d.textStr = e),
						(d.x = i),
						(d.y = o),
						(d.anchorX = s),
						(d.anchorY = n),
						(d.baseline = h),
						(d.className = l),
						d.addClass(
							"button" === l ? "highcharts-no-tooltip" : "highcharts-label"
						),
						l && d.addClass("highcharts-" + l),
						(d.text = t.text(void 0, 0, 0, a).attr({ zIndex: 1 })),
						"string" == typeof r &&
							((c = /^url\((.*?)\)$/.test(r)) || d.renderer.symbols[r]) &&
							(d.symbolKey = r),
						(d.bBox = u.emptyBBox),
						(d.padding = 3),
						(d.baselineOffset = 0),
						(d.needsBox = t.styledMode || c),
						(d.deferredAttr = {}),
						(d.alignFactor = 0),
						d
					);
				}
				return (
					i(u, (p = t)),
					(u.prototype.alignSetter = function (t) {
						t = { left: 0, center: 0.5, right: 1 }[t];
						t !== this.alignFactor &&
							((this.alignFactor = t),
							this.bBox && a(this.xSetting) && this.attr({ x: this.xSetting }));
					}),
					(u.prototype.anchorXSetter = function (t, e) {
						(this.anchorX = t),
							this.boxAttr(
								e,
								Math.round(t) - this.getCrispAdjust() - this.xSetting
							);
					}),
					(u.prototype.anchorYSetter = function (t, e) {
						(this.anchorY = t), this.boxAttr(e, t - this.ySetting);
					}),
					(u.prototype.boxAttr = function (t, e) {
						this.box ? this.box.attr(t, e) : (this.deferredAttr[t] = e);
					}),
					(u.prototype.css = function (e) {
						var i;
						return (
							e &&
								((i = {}),
								(e = r(e)),
								u.textProps.forEach(function (t) {
									void 0 !== e[t] && ((i[t] = e[t]), delete e[t]);
								}),
								this.text.css(i),
								"fontSize" in i || "fontWeight" in i
									? this.updateTextPadding()
									: ("width" in i || "textOverflow" in i) &&
									  this.updateBoxSize()),
							t.prototype.css.call(this, e)
						);
					}),
					(u.prototype.destroy = function () {
						l(this.element, "mouseenter"),
							l(this.element, "mouseleave"),
							this.text && this.text.destroy(),
							this.box && (this.box = this.box.destroy()),
							t.prototype.destroy.call(this);
					}),
					(u.prototype.fillSetter = function (t, e) {
						t && (this.needsBox = !0), (this.fill = t), this.boxAttr(e, t);
					}),
					(u.prototype.getBBox = function () {
						this.textStr &&
							0 === this.bBox.width &&
							0 === this.bBox.height &&
							this.updateBoxSize();
						var t = this.padding,
							e = h(this.paddingLeft, t);
						return {
							width: this.width,
							height: this.height,
							x: this.bBox.x - e,
							y: this.bBox.y - t,
						};
					}),
					(u.prototype.getCrispAdjust = function () {
						return this.renderer.styledMode && this.box
							? (this.box.strokeWidth() % 2) / 2
							: ((this["stroke-width"]
									? parseInt(this["stroke-width"], 10)
									: 0) %
									2) /
									2;
					}),
					(u.prototype.heightSetter = function (t) {
						this.heightSetting = t;
					}),
					(u.prototype.onAdd = function () {
						this.text.add(this),
							this.attr({
								text: h(this.textStr, ""),
								x: this.x || 0,
								y: this.y || 0,
							}),
							this.box &&
								s(this.anchorX) &&
								this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
					}),
					(u.prototype.paddingSetter = function (t, e) {
						a(t)
							? t !== this[e] && ((this[e] = t), this.updateTextPadding())
							: (this[e] = void 0);
					}),
					(u.prototype.rSetter = function (t, e) {
						this.boxAttr(e, t);
					}),
					(u.prototype.shadow = function (t) {
						return (
							t &&
								!this.renderer.styledMode &&
								(this.updateBoxSize(), this.box && this.box.shadow(t)),
							this
						);
					}),
					(u.prototype.strokeSetter = function (t, e) {
						(this.stroke = t), this.boxAttr(e, t);
					}),
					(u.prototype["stroke-widthSetter"] = function (t, e) {
						t && (this.needsBox = !0),
							(this["stroke-width"] = t),
							this.boxAttr(e, t);
					}),
					(u.prototype["text-alignSetter"] = function (t) {
						this.textAlign = t;
					}),
					(u.prototype.textSetter = function (t) {
						void 0 !== t && this.text.attr({ text: t }),
							this.updateTextPadding();
					}),
					(u.prototype.updateBoxSize = function () {
						var t = this.text,
							e = t.element.style,
							i = {},
							o = this.padding,
							r = (this.bBox =
								(a(this.widthSetting) &&
									a(this.heightSetting) &&
									!this.textAlign) ||
								!s(t.textStr)
									? u.emptyBBox
									: t.getBBox()),
							e =
								((this.width = this.getPaddedWidth()),
								(this.height = (this.heightSetting || r.height || 0) + 2 * o),
								this.renderer.fontMetrics(e && e.fontSize, t));
						(this.baselineOffset =
							o +
							Math.min((this.text.firstLineMetrics || e).b, r.height || 1 / 0)),
							this.heightSetting &&
								(this.baselineOffset += (this.heightSetting - e.h) / 2),
							this.needsBox &&
								!t.textPath &&
								(this.box ||
									((o = this.box =
										this.symbolKey
											? this.renderer.symbol(this.symbolKey)
											: this.renderer.rect()).addClass(
										("button" === this.className
											? ""
											: "highcharts-label-box") +
											(this.className
												? " highcharts-" + this.className + "-box"
												: "")
									),
									o.add(this)),
								(r = this.getCrispAdjust()),
								(i.x = r),
								(i.y = (this.baseline ? -this.baselineOffset : 0) + r),
								(i.width = Math.round(this.width)),
								(i.height = Math.round(this.height)),
								this.box.attr(n(i, this.deferredAttr)),
								(this.deferredAttr = {}));
					}),
					(u.prototype.updateTextPadding = function () {
						var t,
							e,
							i = this.text;
						i.textPath ||
							(this.updateBoxSize(),
							(t = this.baseline ? 0 : this.baselineOffset),
							(e = h(this.paddingLeft, this.padding)),
							s(this.widthSetting) &&
								this.bBox &&
								("center" === this.textAlign || "right" === this.textAlign) &&
								(e +=
									{ center: 0.5, right: 1 }[this.textAlign] *
									(this.widthSetting - this.bBox.width)),
							(e === i.x && t === i.y) ||
								(i.attr("x", e),
								i.hasBoxWidthChanged && (this.bBox = i.getBBox(!0)),
								void 0 !== t && i.attr("y", t)),
							(i.x = e),
							(i.y = t));
					}),
					(u.prototype.widthSetter = function (t) {
						this.widthSetting = a(t) ? t : void 0;
					}),
					(u.prototype.getPaddedWidth = function () {
						var t = this.padding,
							e = h(this.paddingLeft, t),
							t = h(this.paddingRight, t);
						return (this.widthSetting || this.bBox.width || 0) + e + t;
					}),
					(u.prototype.xSetter = function (t) {
						(this.x = t),
							this.alignFactor &&
								((t -= this.alignFactor * this.getPaddedWidth()),
								(this["forceAnimate:x"] = !0)),
							(this.xSetting = Math.round(t)),
							this.attr("translateX", this.xSetting);
					}),
					(u.prototype.ySetter = function (t) {
						(this.ySetting = this.y = Math.round(t)),
							this.attr("translateY", this.ySetting);
					}),
					(u.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }),
					(u.textProps = [
						"color",
						"direction",
						"fontFamily",
						"fontSize",
						"fontStyle",
						"fontWeight",
						"lineHeight",
						"textAlign",
						"textDecoration",
						"textOutline",
						"textOverflow",
						"width",
					]),
					u
				);
			}
		),
		e(
			t,
			"Core/Renderer/SVG/Symbols.js",
			[t["Core/Utilities.js"]],
			function (t) {
				var f = t.defined,
					l = t.isNumber,
					g = t.pick;
				function r(t, e, i, o, r) {
					var s,
						n,
						a,
						h,
						l,
						c,
						d,
						p,
						u = [];
					return (
						r &&
							((s = r.start || 0),
							(n = g(r.r, i)),
							(o = g(r.r, o || i)),
							(i = Math.abs((r.end || 0) - s - 2 * Math.PI) < 0.001),
							(p = (r.end || 0) - 0.001),
							(a = r.innerR),
							(i = g(r.open, i)),
							(h = Math.cos(s)),
							(l = Math.sin(s)),
							(c = Math.cos(p)),
							(d = Math.sin(p)),
							(p = g(r.longArc, p - s - Math.PI < 0.001 ? 0 : 1)),
							u.push(
								["M", t + n * h, e + o * l],
								["A", n, o, 0, p, g(r.clockwise, 1), t + n * c, e + o * d]
							),
							f(a) &&
								u.push(
									i ? ["M", t + a * c, e + a * d] : ["L", t + a * c, e + a * d],
									[
										"A",
										a,
										a,
										0,
										p,
										f(r.clockwise) ? 1 - r.clockwise : 0,
										t + a * h,
										e + a * l,
									]
								),
							i || u.push(["Z"])),
						u
					);
				}
				function e(t, e, i, o, r) {
					return r && r.r
						? c(t, e, i, o, r)
						: [
								["M", t, e],
								["L", t + i, e],
								["L", t + i, e + o],
								["L", t, e + o],
								["Z"],
						  ];
				}
				function c(t, e, i, o, r) {
					r = (r && r.r) || 0;
					return [
						["M", t + r, e],
						["L", t + i - r, e],
						["C", t + i, e, t + i, e, t + i, e + r],
						["L", t + i, e + o - r],
						["C", t + i, e + o, t + i, e + o, t + i - r, e + o],
						["L", t + r, e + o],
						["C", t, e + o, t, e + o, t, e + o - r],
						["L", t, e + r],
						["C", t, e, t, e, t + r, e],
					];
				}
				return {
					arc: r,
					callout: function (t, e, i, o, r) {
						var s = Math.min((r && r.r) || 0, i, o),
							n = s + 6,
							a = r && r.anchorX,
							r = (r && r.anchorY) || 0,
							h = c(t, e, i, o, { r: s });
						return (
							l(a) &&
								(i <= t + a
									? e + n < r && r < e + o - n
										? h.splice(
												3,
												1,
												["L", t + i, r - 6],
												["L", t + i + 6, r],
												["L", t + i, r + 6],
												["L", t + i, e + o - s]
										  )
										: h.splice(
												3,
												1,
												["L", t + i, o / 2],
												["L", a, r],
												["L", t + i, o / 2],
												["L", t + i, e + o - s]
										  )
									: t + a <= 0
									? e + n < r && r < e + o - n
										? h.splice(
												7,
												1,
												["L", t, r + 6],
												["L", t - 6, r],
												["L", t, r - 6],
												["L", t, e + s]
										  )
										: h.splice(
												7,
												1,
												["L", t, o / 2],
												["L", a, r],
												["L", t, o / 2],
												["L", t, e + s]
										  )
									: r && o < r && t + n < a && a < t + i - n
									? h.splice(
											5,
											1,
											["L", a + 6, e + o],
											["L", a, e + o + 6],
											["L", a - 6, e + o],
											["L", t + s, e + o]
									  )
									: r &&
									  r < 0 &&
									  t + n < a &&
									  a < t + i - n &&
									  h.splice(
											1,
											1,
											["L", a - 6, e],
											["L", a, e - 6],
											["L", a + 6, e],
											["L", i - s, e]
									  )),
							h
						);
					},
					circle: function (t, e, i, o) {
						return r(t + i / 2, e + o / 2, i / 2, o / 2, {
							start: 0.5 * Math.PI,
							end: 2.5 * Math.PI,
							open: !1,
						});
					},
					diamond: function (t, e, i, o) {
						return [
							["M", t + i / 2, e],
							["L", t + i, e + o / 2],
							["L", t + i / 2, e + o],
							["L", t, e + o / 2],
							["Z"],
						];
					},
					rect: e,
					roundedRect: c,
					square: e,
					triangle: function (t, e, i, o) {
						return [
							["M", t + i / 2, e],
							["L", t + i, e + o],
							["L", t, e + o],
							["Z"],
						];
					},
					"triangle-down": function (t, e, i, o) {
						return [
							["M", t, e],
							["L", t + i, e],
							["L", t + i / 2, e + o],
							["Z"],
						];
					},
				};
			}
		),
		e(
			t,
			"Core/Renderer/SVG/TextBuilder.js",
			[
				t["Core/Renderer/HTML/AST.js"],
				t["Core/Globals.js"],
				t["Core/Utilities.js"],
			],
			function (h, t, e) {
				var f = t.doc,
					g = t.SVG_NS,
					r = t.win,
					m = e.attr,
					c = e.extend,
					i = e.fireEvent,
					l = e.isString,
					s = e.objectEach,
					d = e.pick;
				function o(t) {
					var e = t.styles;
					(this.renderer = t.renderer),
						(this.svgElement = t),
						(this.width = t.textWidth),
						(this.textLineHeight = e && e.lineHeight),
						(this.textOutline = e && e.textOutline),
						(this.ellipsis = Boolean(e && "ellipsis" === e.textOverflow)),
						(this.noWrap = Boolean(e && "nowrap" === e.whiteSpace)),
						(this.fontSize = e && e.fontSize);
				}
				return (
					(o.prototype.buildSVG = function () {
						var t = this.svgElement,
							e = t.element,
							i = t.renderer,
							o = d(t.textStr, "").toString(),
							r = -1 !== o.indexOf("<"),
							s = e.childNodes,
							i = this.width && !t.added && i.box,
							n = [
								o,
								this.ellipsis,
								this.noWrap,
								this.textLineHeight,
								this.textOutline,
								this.fontSize,
								this.width,
							].join(",");
						if (n !== t.textCache) {
							(t.textCache = n), delete t.actualWidth;
							for (var a = s.length; a--; ) e.removeChild(s[a]);
							r ||
							this.ellipsis ||
							this.width ||
							t.textPath ||
							(-1 !== o.indexOf(" ") && (!this.noWrap || /<br.*?>/g.test(o)))
								? "" !== o &&
								  (i && i.appendChild(e),
								  (n = new h(o)),
								  this.modifyTree(n.nodes),
								  n.addToDOM(e),
								  this.modifyDOM(),
								  this.ellipsis &&
										-1 !== (e.textContent || "").indexOf("…") &&
										t.attr(
											"title",
											this.unescapeEntities(t.textStr || "", ["&lt;", "&gt;"])
										),
								  i && i.removeChild(e))
								: e.appendChild(f.createTextNode(this.unescapeEntities(o))),
								l(this.textOutline) &&
									t.applyTextOutline &&
									t.applyTextOutline(this.textOutline);
						}
					}),
					(o.prototype.modifyDOM = function () {
						var t,
							c = this,
							d = this.svgElement,
							p = m(d.element, "x");
						for (
							d.firstLineMetrics = void 0;
							(t = d.element.firstChild) &&
							/^[\s\u200B]*$/.test(t.textContent || " ");

						)
							d.element.removeChild(t);
						[].forEach.call(
							d.element.querySelectorAll("tspan.highcharts-br"),
							function (t, e) {
								t.nextSibling &&
									t.previousSibling &&
									(0 === e &&
										1 === t.previousSibling.nodeType &&
										(d.firstLineMetrics = d.renderer.fontMetrics(
											void 0,
											t.previousSibling
										)),
									m(t, { dy: c.getLineHeight(t.nextSibling), x: p }));
							}
						);
						var i,
							o,
							u = this.width || 0;
						u &&
							((i = function (e, i) {
								var t = e.textContent || "",
									o = t.replace(/([^\^])-/g, "$1- ").split(" "),
									r =
										!c.noWrap &&
										(1 < o.length || 1 < d.element.childNodes.length),
									s = c.getLineHeight(i),
									n = 0,
									a = d.actualWidth;
								if (c.ellipsis)
									t &&
										c.truncate(
											e,
											t,
											void 0,
											0,
											Math.max(0, u - parseInt(c.fontSize || 12, 10)),
											function (t, e) {
												return t.substring(0, e) + "…";
											}
										);
								else if (r) {
									for (var h = [], l = []; i.firstChild && i.firstChild !== e; )
										l.push(i.firstChild), i.removeChild(i.firstChild);
									for (; o.length; )
										o.length &&
											!c.noWrap &&
											0 < n &&
											(h.push(e.textContent || ""),
											(e.textContent = o.join(" ").replace(/- /g, "-"))),
											c.truncate(
												e,
												void 0,
												o,
												(0 === n && a) || 0,
												u,
												function (t, e) {
													return o.slice(0, e).join(" ").replace(/- /g, "-");
												}
											),
											(a = d.actualWidth),
											n++;
									l.forEach(function (t) {
										i.insertBefore(t, e);
									}),
										h.forEach(function (t) {
											i.insertBefore(f.createTextNode(t), e);
											t = f.createElementNS(g, "tspan");
											(t.textContent = "​"),
												m(t, { dy: s, x: p }),
												i.insertBefore(t, e);
										});
								}
							}),
							(o = function (e) {
								[].slice.call(e.childNodes).forEach(function (t) {
									t.nodeType === r.Node.TEXT_NODE
										? i(t, e)
										: (-1 !== t.className.baseVal.indexOf("highcharts-br") &&
												(d.actualWidth = 0),
										  o(t));
								});
							})(d.element));
					}),
					(o.prototype.getLineHeight = function (t) {
						var e,
							t = t.nodeType === r.Node.TEXT_NODE ? t.parentElement : t;
						return (
							this.renderer.styledMode ||
								(e =
									t && /(px|em)$/.test(t.style.fontSize)
										? t.style.fontSize
										: this.fontSize || this.renderer.style.fontSize || 12),
							this.textLineHeight
								? parseInt(this.textLineHeight.toString(), 10)
								: this.renderer.fontMetrics(e, t || this.svgElement.element).h
						);
					}),
					(o.prototype.modifyTree = function (a) {
						function h(t, e) {
							var i = void 0 === (i = t.attributes) ? {} : i,
								o = t.children,
								r = void 0 === (r = t.style) ? {} : r,
								s = t.tagName,
								n = l.renderer.styledMode;
							"b" === s || "strong" === s
								? n
									? (i.class = "highcharts-strong")
									: (r.fontWeight = "bold")
								: ("i" !== s && "em" !== s) ||
								  (n
										? (i.class = "highcharts-emphasized")
										: (r.fontStyle = "italic")),
								r && r.color && (r.fill = r.color),
								"br" === s
									? ((i.class = "highcharts-br"),
									  (t.textContent = "​"),
									  (n = a[e + 1]) &&
											n.textContent &&
											(n.textContent = n.textContent.replace(/^ +/gm, "")))
									: "a" === s &&
									  o &&
									  o.some(function (t) {
											return "#text" === t.tagName;
									  }) &&
									  (t.children = [{ children: o, tagName: "tspan" }]),
								"#text" !== s && "a" !== s && (t.tagName = "tspan"),
								c(t, { attributes: i, style: r }),
								o &&
									o
										.filter(function (t) {
											return "#text" !== t.tagName;
										})
										.forEach(h);
						}
						var l = this;
						a.forEach(h), i(this.svgElement, "afterModifyTree", { nodes: a });
					}),
					(o.prototype.truncate = function (o, r, s, n, t, a) {
						function e(t, e) {
							var e = e || t,
								i = o.parentNode;
							if (i && void 0 === p[e])
								if (i.getSubStringLength)
									try {
										p[e] = n + i.getSubStringLength(0, s ? e + 1 : e);
									} catch (t) {}
								else
									c.getSpanWidth &&
										((o.textContent = a(r || s, t)),
										(p[e] = n + c.getSpanWidth(l, o)));
							return p[e];
						}
						var i,
							h,
							l = this.svgElement,
							c = l.renderer,
							d = l.rotation,
							p = [],
							u = s ? 1 : 0,
							f = (r || s || "").length,
							g = f;
						if (((l.rotation = 0), (h = e(o.textContent.length)), t < n + h)) {
							for (; u <= f; )
								(h = e(
									(g = Math.ceil((u + f) / 2)),
									(i = s ? a(s, g) : i) && i.length - 1
								)),
									u === f ? (u = f + 1) : t < h ? (f = g - 1) : (u = g);
							0 === f
								? (o.textContent = "")
								: (r && f === r.length - 1) ||
								  (o.textContent = i || a(r || s, g));
						}
						s && s.splice(0, g), (l.actualWidth = h), (l.rotation = d);
					}),
					(o.prototype.unescapeEntities = function (i, o) {
						return (
							s(this.renderer.escapes, function (t, e) {
								(o && -1 !== o.indexOf(t)) ||
									(i = i.toString().replace(new RegExp(t, "g"), e));
							}),
							i
						);
					}),
					o
				);
			}
		),
		e(
			t,
			"Core/Renderer/SVG/SVGRenderer.js",
			[
				t["Core/Renderer/HTML/AST.js"],
				t["Core/Color/Color.js"],
				t["Core/Globals.js"],
				t["Core/Renderer/RendererRegistry.js"],
				t["Core/Renderer/SVG/SVGElement.js"],
				t["Core/Renderer/SVG/SVGLabel.js"],
				t["Core/Renderer/SVG/Symbols.js"],
				t["Core/Renderer/SVG/TextBuilder.js"],
				t["Core/Utilities.js"],
			],
			function (v, e, t, i, o, l, r, s, n) {
				var a,
					g = t.charts,
					h = t.deg2rad,
					m = t.doc,
					d = t.isFirefox,
					x = t.isMS,
					c = t.isWebKit,
					p = t.noop,
					u = t.SVG_NS,
					y = t.symbolSizes,
					f = t.win,
					b = n.addEvent,
					S = n.attr,
					k = n.createElement,
					C = n.css,
					M = n.defined,
					w = n.destroyObjectProperties,
					T = n.extend,
					A = n.isArray,
					P = n.isNumber,
					L = n.isObject,
					O = n.isString,
					E = n.merge,
					D = n.pick,
					j = n.pInt,
					I = n.uniqueKey,
					t =
						((B.prototype.init = function (t, e, i, o, r, s, n) {
							var a,
								h = this,
								l = h
									.createElement("svg")
									.attr({ version: "1.1", class: "highcharts-root" }),
								c = l.element;
							n || l.css(this.getStyle(o)),
								t.appendChild(c),
								S(t, "dir", "ltr"),
								-1 === t.innerHTML.indexOf("xmlns") &&
									S(c, "xmlns", this.SVG_NS),
								(h.isSVG = !0),
								(this.box = c),
								(this.boxWrapper = l),
								(h.alignedObjects = []),
								(this.url = this.getReferenceURL()),
								this.createElement("desc")
									.add()
									.element.appendChild(
										m.createTextNode("Created with Highcharts 10.3.3")
									),
								(h.defs = this.createElement("defs").add()),
								(h.allowHTML = s),
								(h.forExport = r),
								(h.styledMode = n),
								(h.gradients = {}),
								(h.cache = {}),
								(h.cacheKeys = []),
								(h.imgCount = 0),
								h.setSize(e, i, !1),
								d &&
									t.getBoundingClientRect &&
									((o = function () {
										C(t, { left: 0, top: 0 }),
											(a = t.getBoundingClientRect()),
											C(t, {
												left: Math.ceil(a.left) - a.left + "px",
												top: Math.ceil(a.top) - a.top + "px",
											});
									})(),
									(h.unSubPixelFix = b(f, "resize", o)));
						}),
						(B.prototype.definition = function (t) {
							return new v([t]).addToDOM(this.defs.element);
						}),
						(B.prototype.getReferenceURL = function () {
							var t, e;
							if (
								(d || c) &&
								m.getElementsByTagName("base").length &&
								(M(a) ||
									((t = I()),
									(t = new v([
										{
											tagName: "svg",
											attributes: { width: 8, height: 8 },
											children: [
												{
													tagName: "defs",
													children: [
														{
															tagName: "clipPath",
															attributes: { id: t },
															children: [
																{
																	tagName: "rect",
																	attributes: { width: 4, height: 4 },
																},
															],
														},
													],
												},
												{
													tagName: "rect",
													attributes: {
														id: "hitme",
														width: 8,
														height: 8,
														"clip-path": "url(#".concat(t, ")"),
														fill: "rgba(0,0,0,0.001)",
													},
												},
											],
										},
									]).addToDOM(m.body)),
									C(t, { position: "fixed", top: 0, left: 0, zIndex: 9e5 }),
									(e = m.elementFromPoint(6, 6)),
									(a = "hitme" === (e && e.id)),
									m.body.removeChild(t)),
								a)
							)
								return f.location.href
									.split("#")[0]
									.replace(/<[^>]*>/g, "")
									.replace(/([\('\)])/g, "\\$1")
									.replace(/ /g, "%20");
							return "";
						}),
						(B.prototype.getStyle = function (t) {
							return (
								(this.style = T(
									{
										fontFamily:
											'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
										fontSize: "12px",
									},
									t
								)),
								this.style
							);
						}),
						(B.prototype.setStyle = function (t) {
							this.boxWrapper.css(this.getStyle(t));
						}),
						(B.prototype.isHidden = function () {
							return !this.boxWrapper.getBBox().width;
						}),
						(B.prototype.destroy = function () {
							var t = this,
								e = t.defs;
							return (
								(t.box = null),
								(t.boxWrapper = t.boxWrapper.destroy()),
								w(t.gradients || {}),
								(t.gradients = null),
								e && (t.defs = e.destroy()),
								t.unSubPixelFix && t.unSubPixelFix(),
								(t.alignedObjects = null)
							);
						}),
						(B.prototype.createElement = function (t) {
							var e = new this.Element();
							return e.init(this, t), e;
						}),
						(B.prototype.getRadialAttr = function (t, e) {
							return {
								cx: t[0] - t[2] / 2 + (e.cx || 0) * t[2],
								cy: t[1] - t[2] / 2 + (e.cy || 0) * t[2],
								r: (e.r || 0) * t[2],
							};
						}),
						(B.prototype.buildText = function (t) {
							new s(t).buildSVG();
						}),
						(B.prototype.getContrast = function (t) {
							(t = e.parse(t).rgba.map(function (t) {
								t /= 255;
								return t <= 0.03928
									? t / 12.92
									: Math.pow((0.055 + t) / 1.055, 2.4);
							})),
								(t = 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]);
							return (0.05 + t) / 0.05 < 1.05 / (0.05 + t)
								? "#FFFFFF"
								: "#000000";
						}),
						(B.prototype.button = function (t, e, i, o, r, s, n, a, h, l) {
							void 0 === r && (r = {});
							var c,
								d,
								p,
								u = this.label(t, e, i, h, void 0, void 0, l, void 0, "button"),
								f = this.styledMode,
								t = r.states || {},
								g = 0,
								m =
									(delete (r = E(r)).states,
									E(
										{
											color: "#333333",
											cursor: "pointer",
											fontWeight: "normal",
										},
										r.style
									)),
								y = (delete r.style, v.filterUserAttributes(r));
							return (
								u.attr(E({ padding: 8, r: 2 }, y)),
								f ||
									((y = E(
										{ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 },
										y
									)),
									(s = E(
										y,
										{ fill: "#e6e6e6" },
										v.filterUserAttributes(s || t.hover || {})
									)),
									(c = s.style),
									delete s.style,
									(n = E(
										y,
										{
											fill: "#e6ebf5",
											style: { color: "#000000", fontWeight: "bold" },
										},
										v.filterUserAttributes(n || t.select || {})
									)),
									(d = n.style),
									delete n.style,
									(a = E(
										y,
										{ style: { color: "#cccccc" } },
										v.filterUserAttributes(a || t.disabled || {})
									)),
									(p = a.style),
									delete a.style),
								b(u.element, x ? "mouseover" : "mouseenter", function () {
									3 !== g && u.setState(1);
								}),
								b(u.element, x ? "mouseout" : "mouseleave", function () {
									3 !== g && u.setState(g);
								}),
								(u.setState = function (t) {
									1 !== t && (u.state = g = t),
										u
											.removeClass(
												/highcharts-button-(normal|hover|pressed|disabled)/
											)
											.addClass(
												"highcharts-button-" +
													["normal", "hover", "pressed", "disabled"][t || 0]
											),
										f ||
											(u.attr([y, s, n, a][t || 0]),
											L((t = [m, c, d, p][t || 0])) && u.css(t));
								}),
								f ||
									(u.attr(y).css(T({ cursor: "default" }, m)),
									l && u.text.css({ pointerEvents: "none" })),
								u
									.on("touchstart", function (t) {
										return t.stopPropagation();
									})
									.on("click", function (t) {
										3 !== g && o.call(u, t);
									})
							);
						}),
						(B.prototype.crispLine = function (t, e, i) {
							void 0 === i && (i = "round");
							var o = t[0],
								r = t[1];
							return (
								M(o[1]) &&
									o[1] === r[1] &&
									(o[1] = r[1] = Math[i](o[1]) - (e % 2) / 2),
								M(o[2]) &&
									o[2] === r[2] &&
									(o[2] = r[2] = Math[i](o[2]) + (e % 2) / 2),
								t
							);
						}),
						(B.prototype.path = function (t) {
							var e = this.styledMode ? {} : { fill: "none" };
							return (
								A(t) ? (e.d = t) : L(t) && T(e, t),
								this.createElement("path").attr(e)
							);
						}),
						(B.prototype.circle = function (t, e, i) {
							(t = L(t) ? t : void 0 === t ? {} : { x: t, y: e, r: i }),
								(e = this.createElement("circle"));
							return (
								(e.xSetter = e.ySetter =
									function (t, e, i) {
										i.setAttribute("c" + e, t);
									}),
								e.attr(t)
							);
						}),
						(B.prototype.arc = function (t, e, i, o, r, s) {
							L(t)
								? ((e = (n = t).y),
								  (i = n.r),
								  (o = n.innerR),
								  (r = n.start),
								  (s = n.end),
								  (t = n.x))
								: (n = { innerR: o, start: r, end: s });
							var n,
								o = this.symbol("arc", t, e, i, i, n);
							return (o.r = i), o;
						}),
						(B.prototype.rect = function (t, e, i, o, r, s) {
							r = L(t) ? t.r : r;
							var n = this.createElement("rect"),
								t = L(t)
									? t
									: void 0 === t
									? {}
									: {
											x: t,
											y: e,
											width: Math.max(i, 0),
											height: Math.max(o, 0),
									  };
							return (
								this.styledMode ||
									(void 0 !== s && ((t["stroke-width"] = s), (t = n.crisp(t))),
									(t.fill = "none")),
								r && (t.r = r),
								(n.rSetter = function (t, e, i) {
									(n.r = t), S(i, { rx: t, ry: t });
								}),
								(n.rGetter = function () {
									return n.r || 0;
								}),
								n.attr(t)
							);
						}),
						(B.prototype.setSize = function (t, e, i) {
							(this.width = t),
								(this.height = e),
								this.boxWrapper.animate(
									{ width: t, height: e },
									{
										step: function () {
											this.attr({
												viewBox:
													"0 0 " +
													this.attr("width") +
													" " +
													this.attr("height"),
											});
										},
										duration: D(i, !0) ? void 0 : 0,
									}
								),
								this.alignElements();
						}),
						(B.prototype.g = function (t) {
							var e = this.createElement("g");
							return t ? e.attr({ class: "highcharts-" + t }) : e;
						}),
						(B.prototype.image = function (e, t, i, o, r, s) {
							function n(t) {
								h(l.element, e), s.call(l, t);
							}
							var a = { preserveAspectRatio: "none" },
								h = function (t, e) {
									t.setAttributeNS
										? t.setAttributeNS(
												"http://www.w3.org/1999/xlink",
												"href",
												e
										  )
										: t.setAttribute("hc-svg-href", e);
								},
								l =
									(P(t) && (a.x = t),
									P(i) && (a.y = i),
									P(o) && (a.width = o),
									P(r) && (a.height = r),
									this.createElement("image").attr(a));
							return (
								s
									? (h(
											l.element,
											"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
									  ),
									  (t = new f.Image()),
									  b(t, "load", n),
									  (t.src = e),
									  t.complete && n({}))
									: h(l.element, e),
								l
							);
						}),
						(B.prototype.symbol = function (t, e, i, o, r, l) {
							var s,
								n,
								a,
								h,
								c = this,
								d = /^url\((.*?)\)$/,
								p = d.test(t),
								u = !p && (this.symbols[t] ? t : "circle"),
								f = u && this.symbols[u];
							return (
								f
									? ("number" == typeof e &&
											(s = f.call(
												this.symbols,
												Math.round(e || 0),
												Math.round(i || 0),
												o || 0,
												r || 0,
												l
											)),
									  (s = this.path(s)),
									  c.styledMode || s.attr("fill", "none"),
									  T(s, {
											symbolName: u || void 0,
											x: e,
											y: i,
											width: o,
											height: r,
									  }),
									  l && T(s, l))
									: p &&
									  ((a = t.match(d)[1]),
									  ((h = s = this.image(a)).imgwidth = D(
											y[a] && y[a].width,
											l && l.width
									  )),
									  (h.imgheight = D(y[a] && y[a].height, l && l.height)),
									  (n = function (t) {
											return t.attr({ width: t.width, height: t.height });
									  }),
									  ["width", "height"].forEach(function (t) {
											h[t + "Setter"] = function (t, e) {
												this[e] = t;
												var i,
													t = this,
													o = t.alignByTranslate,
													r = t.element,
													s = t.width,
													n = t.height,
													a = t.imgwidth,
													t = t.imgheight,
													h = this["img" + e];
												M(h) &&
													((i = 1),
													l && "within" === l.backgroundSize && s && n
														? ((i = Math.min(s / a, n / t)),
														  (h = Math.round(h * i)),
														  S(r, {
																width: Math.round(a * i),
																height: Math.round(t * i),
														  }))
														: r && r.setAttribute(e, h),
													o ||
														this.translate(
															((s || 0) - h * i) / 2,
															((n || 0) - h * i) / 2
														));
											};
									  }),
									  M(e) && h.attr({ x: e, y: i }),
									  (h.isImg = !0),
									  M(h.imgwidth) && M(h.imgheight)
											? n(h)
											: (h.attr({ width: 0, height: 0 }),
											  k("img", {
													onload: function () {
														var t = g[c.chartIndex];
														0 === this.width &&
															(C(this, { position: "absolute", top: "-999em" }),
															m.body.appendChild(this)),
															(y[a] = {
																width: this.width,
																height: this.height,
															}),
															(h.imgwidth = this.width),
															(h.imgheight = this.height),
															h.element && n(h),
															this.parentNode &&
																this.parentNode.removeChild(this),
															c.imgCount--,
															c.imgCount || !t || t.hasLoaded || t.onload();
													},
													src: a,
											  }),
											  this.imgCount++)),
								s
							);
						}),
						(B.prototype.clipRect = function (t, e, i, o) {
							var r = I() + "-",
								s = this.createElement("clipPath")
									.attr({ id: r })
									.add(this.defs),
								t = this.rect(t, e, i, o, 0).add(s);
							return (t.id = r), (t.clipPath = s), (t.count = 0), t;
						}),
						(B.prototype.text = function (t, e, i, o) {
							var r = this,
								s = {};
							if (o && (r.allowHTML || !r.forExport)) return r.html(t, e, i);
							(s.x = Math.round(e || 0)),
								i && (s.y = Math.round(i)),
								M(t) && (s.text = t);
							e = r.createElement("text").attr(s);
							return (
								(o && (!r.forExport || r.allowHTML)) ||
									(e.xSetter = function (t, e, i) {
										for (
											var o = i.getElementsByTagName("tspan"),
												r = i.getAttribute(e),
												s = 0,
												n = void 0;
											s < o.length;
											s++
										)
											(n = o[s]).getAttribute(e) === r && n.setAttribute(e, t);
										i.setAttribute(e, t);
									}),
								e
							);
						}),
						(B.prototype.fontMetrics = function (t, e) {
							t =
								(!this.styledMode && /px/.test(t)) || !f.getComputedStyle
									? t ||
									  (e && e.style && e.style.fontSize) ||
									  (this.style && this.style.fontSize)
									: e && o.prototype.getStyle.call(e, "font-size");
							e =
								(t = /px/.test(t) ? j(t) : 12) < 24
									? t + 3
									: Math.round(1.2 * t);
							return { h: e, b: Math.round(0.8 * e), f: t };
						}),
						(B.prototype.rotCorr = function (t, e, i) {
							var o = t;
							return (
								e && i && (o = Math.max(o * Math.cos(e * h), 4)),
								{ x: (-t / 3) * Math.sin(e * h), y: o }
							);
						}),
						(B.prototype.pathToSegments = function (t) {
							for (
								var e = [],
									i = [],
									o = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 },
									r = 0;
								r < t.length;
								r++
							)
								O(i[0]) &&
									P(t[r]) &&
									i.length === o[i[0].toUpperCase()] &&
									t.splice(r, 0, i[0].replace("M", "L").replace("m", "l")),
									"string" == typeof t[r] &&
										(i.length && e.push(i.slice(0)), (i.length = 0)),
									i.push(t[r]);
							return e.push(i.slice(0)), e;
						}),
						(B.prototype.label = function (t, e, i, o, r, s, n, a, h) {
							return new l(this, t, e, i, o, r, s, n, a, h);
						}),
						(B.prototype.alignElements = function () {
							this.alignedObjects.forEach(function (t) {
								return t.align();
							});
						}),
						B);
				function B(t, e, i, o, r, s, n) {
					(this.alignedObjects = void 0),
						(this.box = void 0),
						(this.boxWrapper = void 0),
						(this.cache = void 0),
						(this.cacheKeys = void 0),
						(this.chartIndex = void 0),
						(this.defs = void 0),
						(this.globalAnimation = void 0),
						(this.gradients = void 0),
						(this.height = void 0),
						(this.imgCount = void 0),
						(this.isSVG = void 0),
						(this.style = void 0),
						(this.url = void 0),
						(this.width = void 0),
						this.init(t, e, i, o, r, s, n);
				}
				return (
					T(t.prototype, {
						Element: o,
						SVG_NS: u,
						escapes: {
							"&": "&amp;",
							"<": "&lt;",
							">": "&gt;",
							"'": "&#39;",
							'"': "&quot;",
						},
						symbols: r,
						draw: p,
					}),
					i.registerRendererType("svg", t, !0),
					t
				);
			}
		),
		e(
			t,
			"Core/Renderer/HTML/HTMLElement.js",
			[
				t["Core/Globals.js"],
				t["Core/Renderer/SVG/SVGElement.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var o,
					r,
					s =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					n = t.isFirefox,
					a = t.isMS,
					h = t.isWebKit,
					l = t.win,
					m = i.css,
					y = i.defined,
					c = i.extend,
					d = i.pick,
					v = i.pInt;
				function p() {
					return (null !== r && r.apply(this, arguments)) || this;
				}
				return (
					s(p, (r = e)),
					(p.compose = function (t) {
						var e, i;
						return (
							-1 === p.composedClasses.indexOf(t) &&
								(p.composedClasses.push(t),
								((i = t.prototype).getSpanCorrection = (e =
									p.prototype).getSpanCorrection),
								(i.htmlCss = e.htmlCss),
								(i.htmlGetBBox = e.htmlGetBBox),
								(i.htmlUpdateTransform = e.htmlUpdateTransform),
								(i.setSpanRotation = e.setSpanRotation)),
							t
						);
					}),
					(p.prototype.getSpanCorrection = function (t, e, i) {
						(this.xCorr = -t * i), (this.yCorr = -e);
					}),
					(p.prototype.htmlCss = function (t) {
						var e,
							i = this,
							o = "SPAN" === i.element.tagName && t && "width" in t,
							r = d(o && t.width, void 0);
						return (
							o && (delete t.width, (i.textWidth = r), (e = !0)),
							t &&
								"ellipsis" === t.textOverflow &&
								((t.whiteSpace = "nowrap"), (t.overflow = "hidden")),
							(i.styles = c(i.styles, t)),
							m(i.element, t),
							e && i.htmlUpdateTransform(),
							i
						);
					}),
					(p.prototype.htmlGetBBox = function () {
						var t = this.element;
						return {
							x: t.offsetLeft,
							y: t.offsetTop,
							width: t.offsetWidth,
							height: t.offsetHeight,
						};
					}),
					(p.prototype.htmlUpdateTransform = function () {
						var t, e, i, o, r, s, n, a, h, l, c, d, p, u, f, g;
						this.added
							? ((e = (t = this).renderer),
							  (i = t.element),
							  (o = t.translateX || 0),
							  (r = t.translateY || 0),
							  (s = t.x || 0),
							  (n = t.y || 0),
							  (h = { left: 0, center: 0.5, right: 1 }[
									(a = t.textAlign || "left")
							  ]),
							  (l = t.styles),
							  (l = l && l.whiteSpace),
							  m(i, { marginLeft: o, marginTop: r }),
							  !e.styledMode &&
									t.shadows &&
									t.shadows.forEach(function (t) {
										m(t, { marginLeft: o + 1, marginTop: r + 1 });
									}),
							  t.inverted &&
									[].forEach.call(i.childNodes, function (t) {
										e.invertChild(t, i);
									}),
							  "SPAN" === i.tagName &&
									((c = t.rotation),
									(d = t.textWidth && v(t.textWidth)),
									(p = [c, a, i.innerHTML, t.textWidth, t.textAlign].join(",")),
									(u = void 0),
									(f = !1),
									d !== t.oldTextWidth &&
										((g =
											t.textPxLength ||
											(m(i, { width: "", whiteSpace: l || "nowrap" }),
											i.offsetWidth)),
										(d > t.oldTextWidth || d < g) &&
											(/[ \-]/.test(i.textContent || i.innerText) ||
												"ellipsis" === i.style.textOverflow) &&
											(m(i, {
												width: d < g || c ? d + "px" : "auto",
												display: "block",
												whiteSpace: l || "normal",
											}),
											(t.oldTextWidth = d),
											(f = !0))),
									(t.hasBoxWidthChanged = f),
									p !== t.cTT &&
										((u = e.fontMetrics(i.style.fontSize, i).b),
										!y(c) ||
											(c === (t.oldRotation || 0) && a === t.oldAlign) ||
											t.setSpanRotation(c, h, u),
										t.getSpanCorrection(
											(!y(c) && t.textPxLength) || i.offsetWidth,
											u,
											h,
											c,
											a
										)),
									m(i, {
										left: s + (t.xCorr || 0) + "px",
										top: n + (t.yCorr || 0) + "px",
									}),
									(t.cTT = p),
									(t.oldRotation = c),
									(t.oldAlign = a)))
							: (this.alignOnAdd = !0);
					}),
					(p.prototype.setSpanRotation = function (t, e, i) {
						var o = {},
							r =
								a && !/Edge/.test(l.navigator.userAgent)
									? "-ms-transform"
									: h
									? "-webkit-transform"
									: n
									? "MozTransform"
									: l.opera
									? "-o-transform"
									: void 0;
						r &&
							((o[r] = o.transform = "rotate(" + t + "deg)"),
							(o[r + (n ? "Origin" : "-origin")] = o.transformOrigin =
								100 * e + "% " + i + "px"),
							m(this.element, o));
					}),
					(p.composedClasses = []),
					p
				);
			}
		),
		e(
			t,
			"Core/Renderer/HTML/HTMLRenderer.js",
			[
				t["Core/Renderer/HTML/AST.js"],
				t["Core/Renderer/SVG/SVGElement.js"],
				t["Core/Renderer/SVG/SVGRenderer.js"],
				t["Core/Utilities.js"],
			],
			function (n, a, t, e) {
				var o,
					i,
					r =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					d = e.attr,
					p = e.createElement,
					u = e.extend,
					h = e.pick;
				function s() {
					return (null !== i && i.apply(this, arguments)) || this;
				}
				return (
					r(s, (i = t)),
					(s.compose = function (t) {
						return (
							-1 === s.composedClasses.indexOf(t) &&
								(s.composedClasses.push(t),
								(t.prototype.html = s.prototype.html)),
							t
						);
					}),
					(s.prototype.html = function (t, e, i) {
						function l(s, n) {
							["opacity", "visibility"].forEach(function (r) {
								s[r + "Setter"] = function (t, e, i) {
									var o = s.div ? s.div.style : n;
									a.prototype[r + "Setter"].call(this, t, e, i),
										o && (o[e] = t);
								};
							}),
								(s.addedSetters = !0);
						}
						var c = this.createElement("span"),
							o = c.element,
							r = c.renderer,
							s = r.isSVG;
						return (
							(c.textSetter = function (t) {
								t !== this.textStr &&
									(delete this.bBox,
									delete this.oldTextWidth,
									n.setElementHTML(this.element, h(t, "")),
									(this.textStr = t),
									(c.doTransform = !0));
							}),
							s && l(c, c.element.style),
							(c.xSetter =
								c.ySetter =
								c.alignSetter =
								c.rotationSetter =
									function (t, e) {
										"align" === e
											? (c.alignValue = c.textAlign = t)
											: (c[e] = t),
											(c.doTransform = !0);
									}),
							(c.afterSetters = function () {
								this.doTransform &&
									(this.htmlUpdateTransform(), (this.doTransform = !1));
							}),
							c
								.attr({ text: t, x: Math.round(e), y: Math.round(i) })
								.css({ position: "absolute" }),
							r.styledMode ||
								c.css({
									fontFamily: this.style.fontFamily,
									fontSize: this.style.fontSize,
								}),
							(o.style.whiteSpace = "nowrap"),
							(c.css = c.htmlCss),
							s &&
								(c.add = function (t) {
									var n,
										e,
										a = r.box.parentNode,
										h = [];
									if ((this.parentGroup = t)) {
										if (!(n = t.div)) {
											for (e = t; e; ) h.push(e), (e = e.parentGroup);
											h.reverse().forEach(function (i) {
												var t = d(i.element, "class");
												function e(t, e) {
													(i[e] = t),
														"translateX" === e
															? (s.left = t + "px")
															: (s.top = t + "px"),
														(i.doTransform = !0);
												}
												var o,
													r = i.styles || {},
													s = (n = i.div =
														i.div ||
														p(
															"div",
															t ? { className: t } : void 0,
															{
																position: "absolute",
																left: (i.translateX || 0) + "px",
																top: (i.translateY || 0) + "px",
																display: i.display,
																opacity: i.opacity,
																cursor: r.cursor,
																pointerEvents: r.pointerEvents,
																visibility: i.visibility,
															},
															n || a
														)).style;
												u(i, {
													classSetter:
														((o = n),
														function (t) {
															this.element.setAttribute("class", t),
																(o.className = t);
														}),
													on: function () {
														return (
															h[0].div &&
																c.on.apply(
																	{ element: h[0].div, onEvents: i.onEvents },
																	arguments
																),
															i
														);
													},
													translateXSetter: e,
													translateYSetter: e,
												}),
													i.addedSetters || l(i);
											});
										}
									} else n = a;
									return (
										n.appendChild(o),
										(c.added = !0),
										c.alignOnAdd && c.htmlUpdateTransform(),
										c
									);
								}),
							c
						);
					}),
					(s.composedClasses = []),
					s
				);
			}
		),
		e(t, "Core/Axis/AxisDefaults.js", [], function () {
			var t, e;
			return (
				((e = t = t || {}).defaultXAxisOptions = {
					alignTicks: !0,
					allowDecimals: void 0,
					panningEnabled: !0,
					zIndex: 2,
					zoomEnabled: !0,
					dateTimeLabelFormats: {
						millisecond: { main: "%H:%M:%S.%L", range: !1 },
						second: { main: "%H:%M:%S", range: !1 },
						minute: { main: "%H:%M", range: !1 },
						hour: { main: "%H:%M", range: !1 },
						day: { main: "%e. %b" },
						week: { main: "%e. %b" },
						month: { main: "%b '%y" },
						year: { main: "%Y" },
					},
					endOnTick: !1,
					gridLineDashStyle: "Solid",
					gridZIndex: 1,
					labels: {
						autoRotation: void 0,
						autoRotationLimit: 80,
						distance: void 0,
						enabled: !0,
						indentation: 10,
						overflow: "justify",
						padding: 5,
						reserveSpace: void 0,
						rotation: void 0,
						staggerLines: 0,
						step: 0,
						useHTML: !1,
						x: 0,
						zIndex: 7,
						style: { color: "#666666", cursor: "default", fontSize: "11px" },
					},
					maxPadding: 0.01,
					minorGridLineDashStyle: "Solid",
					minorTickLength: 2,
					minorTickPosition: "outside",
					minPadding: 0.01,
					offset: void 0,
					opposite: !1,
					reversed: void 0,
					reversedStacks: !1,
					showEmpty: !0,
					showFirstLabel: !0,
					showLastLabel: !0,
					startOfWeek: 1,
					startOnTick: !1,
					tickLength: 10,
					tickPixelInterval: 100,
					tickmarkPlacement: "between",
					tickPosition: "outside",
					title: {
						align: "middle",
						rotation: 0,
						useHTML: !1,
						x: 0,
						y: 0,
						style: { color: "#666666" },
					},
					type: "linear",
					uniqueNames: !0,
					visible: !0,
					minorGridLineColor: "#f2f2f2",
					minorGridLineWidth: 1,
					minorTickColor: "#999999",
					lineColor: "#ccd6eb",
					lineWidth: 1,
					gridLineColor: "#e6e6e6",
					gridLineWidth: void 0,
					tickColor: "#ccd6eb",
				}),
				(e.defaultYAxisOptions = {
					reversedStacks: !0,
					endOnTick: !0,
					maxPadding: 0.05,
					minPadding: 0.05,
					tickPixelInterval: 72,
					showLastLabel: !0,
					labels: { x: -8 },
					startOnTick: !0,
					title: { rotation: 270, text: "Values" },
					stackLabels: {
						animation: {},
						allowOverlap: !1,
						enabled: !1,
						crop: !0,
						overflow: "justify",
						formatter: function () {
							return (0, this.axis.chart.numberFormatter)(this.total || 0, -1);
						},
						style: {
							color: "#000000",
							fontSize: "11px",
							fontWeight: "bold",
							textOutline: "1px contrast",
						},
					},
					gridLineWidth: 1,
					lineWidth: 0,
				}),
				(e.defaultLeftAxisOptions = {
					labels: { x: -15 },
					title: { rotation: 270 },
				}),
				(e.defaultRightAxisOptions = {
					labels: { x: 15 },
					title: { rotation: 90 },
				}),
				(e.defaultBottomAxisOptions = {
					labels: { autoRotation: [-45], x: 0 },
					margin: 15,
					title: { rotation: 0 },
				}),
				(e.defaultTopAxisOptions = {
					labels: { autoRotation: [-45], x: 0 },
					margin: 15,
					title: { rotation: 0 },
				}),
				t
			);
		}),
		e(t, "Core/Foundation.js", [t["Core/Utilities.js"]], function (t) {
			var e,
				o = t.addEvent,
				r = t.isFunction,
				s = t.objectEach,
				n = t.removeEvent;
			return (
				((e || (e = {})).registerEventOptions = function (i, t) {
					(i.eventOptions = i.eventOptions || {}),
						s(t.events, function (t, e) {
							i.eventOptions[e] !== t &&
								(i.eventOptions[e] &&
									(n(i, e, i.eventOptions[e]), delete i.eventOptions[e]),
								r(t) && ((i.eventOptions[e] = t), o(i, e, t)));
						});
				}),
				e
			);
		}),
		e(
			t,
			"Core/Axis/Tick.js",
			[
				t["Core/FormatUtilities.js"],
				t["Core/Globals.js"],
				t["Core/Utilities.js"],
			],
			function (b, t, e) {
				var y = t.deg2rad,
					a = e.clamp,
					S = e.correctFloat,
					k = e.defined,
					i = e.destroyObjectProperties,
					C = e.extend,
					M = e.fireEvent,
					w = e.isNumber,
					s = e.merge,
					h = e.objectEach,
					T = e.pick;
				function o(t, e, i, o, r) {
					(this.isNew = !0),
						(this.isNewLabel = !0),
						(this.axis = t),
						(this.pos = e),
						(this.type = i || ""),
						(this.parameters = r || {}),
						(this.tickmarkOffset = this.parameters.tickmarkOffset),
						(this.options = this.parameters.options),
						M(this, "init"),
						i || o || this.addLabel();
				}
				return (
					(o.prototype.addLabel = function () {
						function t(t) {
							return p.formatter
								? p.formatter.call(t, t)
								: p.format
								? ((t.text = s.defaultLabelFormatter.call(t, t)),
								  b.format(p.format, t, a))
								: s.defaultLabelFormatter.call(t, t);
						}
						var e,
							i,
							o,
							r = this,
							s = r.axis,
							n = s.options,
							a = s.chart,
							h = s.categories,
							l = s.logarithmic,
							c = s.names,
							d = r.pos,
							p = T(r.options && r.options.labels, n.labels),
							u = s.tickPositions,
							f = d === u[0],
							g = d === u[u.length - 1],
							m = (!p.step || 1 === p.step) && 1 === s.tickInterval,
							u = u.info,
							y = r.label,
							h = this.parameters.category || (h ? T(h[d], c[d], d) : d),
							v =
								(l && w(h) && (h = S(l.lin2log(h))),
								s.dateTime &&
									(u
										? (e = (i = a.time.resolveDTLFormat(
												n.dateTimeLabelFormats[
													(!n.grid && u.higherRanks[d]) || u.unitName
												]
										  )).main)
										: w(h) &&
										  (e = s.dateTime.getXDateFormat(
												h,
												n.dateTimeLabelFormats || {}
										  ))),
								(r.isFirst = f),
								(r.isLast = g),
								{
									axis: s,
									chart: a,
									dateTimeLabelFormat: e,
									isFirst: f,
									isLast: g,
									pos: d,
									tick: r,
									tickPositionInfo: u,
									value: h,
								}),
							c = (M(this, "labelFormat", v), t.call(v, v)),
							x = i && i.list;
						(r.shortenLabel = x
							? function () {
									for (o = 0; o < x.length; o++)
										if (
											(C(v, { dateTimeLabelFormat: x[o] }),
											y.attr({ text: t.call(v, v) }),
											y.getBBox().width < s.getSlotWidth(r) - 2 * p.padding)
										)
											return;
									y.attr({ text: "" });
							  }
							: void 0),
							m && s._addedPlotLB && r.moveLabel(c, p),
							k(y) || r.movedLabel
								? y &&
								  y.textStr !== c &&
								  !m &&
								  (!y.textWidth ||
										p.style.width ||
										y.styles.width ||
										y.css({ width: null }),
								  y.attr({ text: c }),
								  (y.textPxLength = y.getBBox().width))
								: ((r.label = y = r.createLabel({ x: 0, y: 0 }, c, p)),
								  (r.rotation = 0));
					}),
					(o.prototype.createLabel = function (t, e, i) {
						var o = this.axis,
							r = o.chart,
							e =
								k(e) && i.enabled
									? r.renderer.text(e, t.x, t.y, i.useHTML).add(o.labelGroup)
									: null;
						return (
							e &&
								(r.styledMode || e.css(s(i.style)),
								(e.textPxLength = e.getBBox().width)),
							e
						);
					}),
					(o.prototype.destroy = function () {
						i(this, this.axis);
					}),
					(o.prototype.getPosition = function (t, e, i, o) {
						var r = this.axis,
							s = r.chart,
							n = (o && s.oldChartHeight) || s.chartHeight,
							s = {
								x: t
									? S(r.translate(e + i, void 0, void 0, o) + r.transB)
									: r.left +
									  r.offset +
									  (r.opposite
											? ((o && s.oldChartWidth) || s.chartWidth) -
											  r.right -
											  r.left
											: 0),
								y: t
									? n - r.bottom + r.offset - (r.opposite ? r.height : 0)
									: S(n - r.translate(e + i, void 0, void 0, o) - r.transB),
							};
						return (
							(s.y = a(s.y, -1e5, 1e5)),
							M(this, "afterGetPosition", { pos: s }),
							s
						);
					}),
					(o.prototype.getLabelPosition = function (t, e, i, o, r, s, n, a) {
						var h = this.axis,
							l = h.transA,
							c = (h.isLinked && h.linkedParent ? h.linkedParent : h).reversed,
							d = h.staggerLines,
							p = h.tickRotCorr || { x: 0, y: 0 },
							u =
								o || h.reserveSpaceDefault
									? 0
									: -h.labelOffset * ("center" === h.labelAlign ? 0.5 : 1),
							f = {},
							i =
								0 === h.side
									? i.rotation
										? -8
										: -i.getBBox().height
									: 2 === h.side
									? p.y + 8
									: Math.cos(i.rotation * y) *
									  (p.y - i.getBBox(!1, 0).height / 2);
						return (
							k(r.y) && (i = 0 === h.side && h.horiz ? r.y + i : r.y),
							(t = t + r.x + u + p.x - (s && o ? s * l * (c ? -1 : 1) : 0)),
							(e = e + i - (s && !o ? s * l * (c ? 1 : -1) : 0)),
							d &&
								((r = (n / (a || 1)) % d),
								(e += (r = h.opposite ? d - r - 1 : r) * (h.labelOffset / d))),
							(f.x = t),
							(f.y = Math.round(e)),
							M(this, "afterGetLabelPosition", {
								pos: f,
								tickmarkOffset: s,
								index: n,
							}),
							f
						);
					}),
					(o.prototype.getLabelSize = function () {
						return this.label
							? this.label.getBBox()[this.axis.horiz ? "height" : "width"]
							: 0;
					}),
					(o.prototype.getMarkPath = function (t, e, i, o, r, s) {
						return s.crispLine(
							[
								["M", t, e],
								["L", t + (r ? 0 : -i), e + (r ? i : 0)],
							],
							o
						);
					}),
					(o.prototype.handleOverflow = function (t) {
						var e,
							i = this.axis,
							o = i.options.labels,
							r = t.x,
							s = i.chart.chartWidth,
							n = i.chart.spacing,
							a = T(i.labelLeft, Math.min(i.pos, n[3])),
							n = T(
								i.labelRight,
								Math.max(i.isRadial ? 0 : i.pos + i.len, s - n[1])
							),
							h = this.label,
							l = this.rotation,
							c = { left: 0, center: 0.5, right: 1 }[
								i.labelAlign || h.attr("align")
							],
							d = h.getBBox().width,
							p = i.getSlotWidth(this),
							u = c,
							f = {},
							g = p,
							m = 1;
						l || "justify" !== o.overflow
							? l < 0 && r - c * d < a
								? (e = Math.round(r / Math.cos(l * y) - a))
								: 0 < l &&
								  n < r + c * d &&
								  (e = Math.round((s - r) / Math.cos(l * y)))
							: (r - c * d < a
									? (g = t.x + g * (1 - c) - a)
									: n < r + (1 - c) * d && ((g = n - t.x + g * c), (m = -1)),
							  (g = Math.min(p, g)) < p &&
									"center" === i.labelAlign &&
									(t.x += m * (p - g - u * (p - Math.min(d, g)))),
							  (g < d || (i.autoRotation && (h.styles || {}).width)) &&
									(e = g)),
							e &&
								(this.shortenLabel
									? this.shortenLabel()
									: ((f.width = Math.floor(e) + "px"),
									  (o.style || {}).textOverflow ||
											(f.textOverflow = "ellipsis"),
									  h.css(f)));
					}),
					(o.prototype.moveLabel = function (e, t) {
						var i,
							o = this,
							r = o.label,
							s = o.axis,
							n = s.reversed,
							a = !1;
						r && r.textStr === e
							? ((o.movedLabel = r), (a = !0), delete o.label)
							: h(s.ticks, function (t) {
									a ||
										t.isNew ||
										t === o ||
										!t.label ||
										t.label.textStr !== e ||
										((o.movedLabel = t.label),
										(a = !0),
										(t.labelPos = o.movedLabel.xy),
										delete t.label);
							  }),
							a ||
								(!o.labelPos && !r) ||
								((r = o.labelPos || r.xy),
								(i = s.horiz ? (n ? 0 : s.width + s.left) : r.x),
								(r = s.horiz ? r.y : n ? s.width + s.left : 0),
								(o.movedLabel = o.createLabel({ x: i, y: r }, e, t)),
								o.movedLabel && o.movedLabel.attr({ opacity: 0 }));
					}),
					(o.prototype.render = function (t, e, i) {
						var o = this,
							r = o.axis,
							s = r.horiz,
							n = o.pos,
							a = T(o.tickmarkOffset, r.tickmarkOffset),
							n = o.getPosition(s, n, a, e),
							a = n.x,
							h = n.y,
							a = (s && a === r.pos + r.len) || (!s && h === r.pos) ? -1 : 1,
							s = T(i, o.label && o.label.newOpacity, 1);
						(i = T(i, 1)),
							(this.isActive = !0),
							this.renderGridLine(e, i, a),
							this.renderMark(n, i, a),
							this.renderLabel(n, e, s, t),
							(o.isNew = !1),
							M(this, "afterRender");
					}),
					(o.prototype.renderGridLine = function (t, e, i) {
						var o = this,
							r = o.axis,
							s = r.options,
							n = {},
							a = o.pos,
							h = o.type,
							l = T(o.tickmarkOffset, r.tickmarkOffset),
							c = r.chart.renderer,
							d = o.gridLine,
							p = s.gridLineWidth,
							u = s.gridLineColor,
							f = s.gridLineDashStyle;
						"minor" === o.type &&
							((p = s.minorGridLineWidth),
							(u = s.minorGridLineColor),
							(f = s.minorGridLineDashStyle)),
							d ||
								(r.chart.styledMode ||
									((n.stroke = u),
									(n["stroke-width"] = p || 0),
									(n.dashstyle = f)),
								h || (n.zIndex = 1),
								t && (e = 0),
								(o.gridLine = d =
									c
										.path()
										.attr(n)
										.addClass("highcharts-" + (h ? h + "-" : "") + "grid-line")
										.add(r.gridGroup))),
							d &&
								(s = r.getPlotLinePath({
									value: a + l,
									lineWidth: d.strokeWidth() * i,
									force: "pass",
									old: t,
									acrossPanes: !1,
								})) &&
								d[t || o.isNew ? "attr" : "animate"]({ d: s, opacity: e });
					}),
					(o.prototype.renderMark = function (t, e, i) {
						var o = this,
							r = o.axis,
							s = r.options,
							n = r.chart.renderer,
							a = o.type,
							h = r.tickSize(a ? a + "Tick" : "tick"),
							l = t.x,
							t = t.y,
							c = T(
								s["minor" !== a ? "tickWidth" : "minorTickWidth"],
								!a && r.isXAxis ? 1 : 0
							),
							s = s["minor" !== a ? "tickColor" : "minorTickColor"],
							d = o.mark,
							p = !d;
						h &&
							(r.opposite && (h[0] = -h[0]),
							d ||
								((o.mark = d =
									n
										.path()
										.addClass("highcharts-" + (a ? a + "-" : "") + "tick")
										.add(r.axisGroup)),
								r.chart.styledMode || d.attr({ stroke: s, "stroke-width": c })),
							d[p ? "attr" : "animate"]({
								d: o.getMarkPath(l, t, h[0], d.strokeWidth() * i, r.horiz, n),
								opacity: e,
							}));
					}),
					(o.prototype.renderLabel = function (t, e, i, o) {
						var r = this,
							s = r.axis,
							n = s.horiz,
							a = s.options,
							h = r.label,
							l = a.labels,
							c = l.step,
							s = T(r.tickmarkOffset, s.tickmarkOffset),
							d = t.x,
							p = t.y,
							u = !0;
						h &&
							w(d) &&
							((h.xy = t = r.getLabelPosition(d, p, h, n, l, s, o, c)),
							(r.isFirst && !r.isLast && !a.showFirstLabel) ||
							(r.isLast && !r.isFirst && !a.showLastLabel)
								? (u = !1)
								: !n ||
								  l.step ||
								  l.rotation ||
								  e ||
								  0 === i ||
								  r.handleOverflow(t),
							(u = c && o % c ? !1 : u) && w(t.y)
								? ((t.opacity = i),
								  h[r.isNewLabel ? "attr" : "animate"](t).show(!0),
								  (r.isNewLabel = !1))
								: (h.hide(), (r.isNewLabel = !0)));
					}),
					(o.prototype.replaceMovedLabel = function () {
						var t,
							e = this,
							i = e.label,
							o = e.axis,
							r = o.reversed;
						i &&
							!e.isNew &&
							((t = o.horiz ? (r ? o.left : o.width + o.left) : i.xy.x),
							(r = o.horiz ? i.xy.y : r ? o.width + o.top : o.top),
							i.animate({ x: t, y: r, opacity: 0 }, void 0, i.destroy),
							delete e.label),
							(o.isDirty = !0),
							(e.label = e.movedLabel),
							delete e.movedLabel;
					}),
					o
				);
			}
		),
		e(
			t,
			"Core/Axis/Axis.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Axis/AxisDefaults.js"],
				t["Core/Color/Color.js"],
				t["Core/Defaults.js"],
				t["Core/Foundation.js"],
				t["Core/Globals.js"],
				t["Core/Axis/Tick.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, h, i, o, b, S, r) {
				function k(t, e) {
					return p(
						e,
						void 0,
						void 0,
						O(t.options.allowDecimals, e < 0.5 || void 0 !== t.tickAmount),
						!!t.tickAmount
					);
				}
				var C = t.animObject,
					f = i.defaultOptions,
					a = o.registerEventOptions,
					y = b.deg2rad,
					g = r.arrayMax,
					m = r.arrayMin,
					x = r.clamp,
					M = r.correctFloat,
					w = r.defined,
					n = r.destroyObjectProperties,
					s = r.erase,
					T = r.error,
					l = r.extend,
					A = r.fireEvent,
					c = r.isArray,
					P = r.isNumber,
					v = r.isString,
					d = r.merge,
					p = r.normalizeTickInterval,
					L = r.objectEach,
					O = r.pick,
					u = r.relativeLength,
					E = r.removeEvent,
					D = r.splat,
					j = r.syncTimeout;
				function I(t, e) {
					(this.alternateBands = void 0),
						(this.bottom = void 0),
						(this.chart = void 0),
						(this.closestPointRange = void 0),
						(this.coll = void 0),
						(this.eventOptions = void 0),
						(this.hasNames = void 0),
						(this.hasVisibleSeries = void 0),
						(this.height = void 0),
						(this.isLinked = void 0),
						(this.labelEdge = void 0),
						(this.labelFormatter = void 0),
						(this.left = void 0),
						(this.len = void 0),
						(this.max = void 0),
						(this.maxLabelLength = void 0),
						(this.min = void 0),
						(this.minorTickInterval = void 0),
						(this.minorTicks = void 0),
						(this.minPixelPadding = void 0),
						(this.names = void 0),
						(this.offset = void 0),
						(this.options = void 0),
						(this.overlap = void 0),
						(this.paddedTicks = void 0),
						(this.plotLinesAndBands = void 0),
						(this.plotLinesAndBandsGroups = void 0),
						(this.pointRange = void 0),
						(this.pointRangePadding = void 0),
						(this.pos = void 0),
						(this.positiveValuesOnly = void 0),
						(this.right = void 0),
						(this.series = void 0),
						(this.side = void 0),
						(this.tickAmount = void 0),
						(this.tickInterval = void 0),
						(this.tickmarkOffset = void 0),
						(this.tickPositions = void 0),
						(this.tickRotCorr = void 0),
						(this.ticks = void 0),
						(this.top = void 0),
						(this.transA = void 0),
						(this.transB = void 0),
						(this.translationSlope = void 0),
						(this.userOptions = void 0),
						(this.visible = void 0),
						(this.width = void 0),
						(this.zoomEnabled = void 0),
						this.init(t, e);
				}
				return (
					(I.prototype.init = function (t, e) {
						var i = e.isX,
							o = this,
							r =
								((o.chart = t),
								(o.horiz = t.inverted && !o.isZAxis ? !i : i),
								(o.isXAxis = i),
								(o.coll = o.coll || (i ? "xAxis" : "yAxis")),
								A(this, "init", { userOptions: e }),
								(o.opposite = O(e.opposite, o.opposite)),
								(o.side = O(
									e.side,
									o.side,
									o.horiz ? (o.opposite ? 0 : 2) : o.opposite ? 1 : 3
								)),
								o.setOptions(e),
								this.options),
							s = r.labels,
							n = r.type,
							e =
								((o.userOptions = e),
								(o.minPixelPadding = 0),
								(o.reversed = O(r.reversed, o.reversed)),
								(o.visible = r.visible),
								(o.zoomEnabled = r.zoomEnabled),
								(o.hasNames = "category" === n || !0 === r.categories),
								(o.categories = r.categories || (o.hasNames ? [] : void 0)),
								o.names || ((o.names = []), (o.names.keys = {})),
								(o.plotLinesAndBandsGroups = {}),
								(o.positiveValuesOnly = !!o.logarithmic),
								(o.isLinked = w(r.linkedTo)),
								(o.ticks = {}),
								(o.labelEdge = []),
								(o.minorTicks = {}),
								(o.plotLinesAndBands = []),
								(o.alternateBands = {}),
								(o.len = 0),
								(o.minRange = o.userMinRange = r.minRange || r.maxZoom),
								(o.range = r.range),
								(o.offset = r.offset || 0),
								(o.max = null),
								(o.min = null),
								O(r.crosshair, D(t.options.tooltip.crosshairs)[i ? 0 : 1]));
						(o.crosshair = !0 === e ? {} : e),
							-1 === t.axes.indexOf(o) &&
								(i ? t.axes.splice(t.xAxis.length, 0, o) : t.axes.push(o),
								t[o.coll].push(o)),
							(o.series = o.series || []),
							t.inverted &&
								!o.isZAxis &&
								i &&
								void 0 === o.reversed &&
								(o.reversed = !0),
							(o.labelRotation = P(s.rotation) ? s.rotation : void 0),
							a(o, r),
							A(this, "afterInit");
					}),
					(I.prototype.setOptions = function (t) {
						(this.options = d(
							e.defaultXAxisOptions,
							"yAxis" === this.coll && e.defaultYAxisOptions,
							[
								e.defaultTopAxisOptions,
								e.defaultRightAxisOptions,
								e.defaultBottomAxisOptions,
								e.defaultLeftAxisOptions,
							][this.side],
							d(f[this.coll], t)
						)),
							A(this, "afterSetOptions", { userOptions: t });
					}),
					(I.prototype.defaultLabelFormatter = function (t) {
						var e,
							i,
							o = this.axis,
							r = this.chart.numberFormatter,
							s = P(this.value) ? this.value : NaN,
							n = o.chart.time,
							a = o.categories,
							h = this.dateTimeLabelFormat,
							l = f.lang,
							c = l.numericSymbols,
							d = l.numericSymbolMagnitude || 1e3,
							p = o.logarithmic ? Math.abs(s) : o.tickInterval,
							u = c && c.length;
						if (a) i = "".concat(this.value);
						else if (h) i = n.dateFormat(h, s);
						else if (u && 1e3 <= p)
							for (; u-- && void 0 === i; )
								(e = Math.pow(d, u + 1)) <= p &&
									(10 * s) % e == 0 &&
									null !== c[u] &&
									0 !== s &&
									(i = r(s / e, -1) + c[u]);
						return (i =
							void 0 === i
								? 1e4 <= Math.abs(s)
									? r(s, -1)
									: r(s, -1, void 0, "")
								: i);
					}),
					(I.prototype.getSeriesExtremes = function () {
						var n,
							a = this,
							h = a.chart;
						A(this, "getSeriesExtremes", null, function () {
							(a.hasVisibleSeries = !1),
								(a.dataMin = a.dataMax = a.threshold = null),
								(a.softThreshold = !a.isXAxis),
								a.series.forEach(function (t) {
									var e, i, o, r, s;
									(!t.visible && h.options.chart.ignoreHiddenSeries) ||
										((i = (e = t.options).threshold),
										(a.hasVisibleSeries = !(r = o = s = void 0)),
										a.positiveValuesOnly && i <= 0 && (i = null),
										a.isXAxis
											? (s = t.xData).length &&
											  ((s = a.logarithmic
													? s.filter(a.validatePositiveValue)
													: s),
											  (o = (n = t.getXExtremes(s)).min),
											  (r = n.max),
											  P(o) ||
													o instanceof Date ||
													((s = s.filter(P)),
													(o = (n = t.getXExtremes(s)).min),
													(r = n.max)),
											  s.length &&
													((a.dataMin = Math.min(O(a.dataMin, o), o)),
													(a.dataMax = Math.max(O(a.dataMax, r), r))))
											: ((s = t.applyExtremes()),
											  P(s.dataMin) &&
													((o = s.dataMin),
													(a.dataMin = Math.min(O(a.dataMin, o), o))),
											  P(s.dataMax) &&
													((r = s.dataMax),
													(a.dataMax = Math.max(O(a.dataMax, r), r))),
											  w(i) && (a.threshold = i),
											  (e.softThreshold && !a.positiveValuesOnly) ||
													(a.softThreshold = !1)));
								});
						}),
							A(this, "afterGetSeriesExtremes");
					}),
					(I.prototype.translate = function (t, e, i, o, r, s) {
						var n = this.linkedParent || this,
							a = (o && n.old ? n.old : n).min;
						if (!P(a)) return NaN;
						var h = n.minPixelPadding,
							r =
								(n.isOrdinal ||
									(n.brokenAxis && n.brokenAxis.hasBreaks) ||
									(n.logarithmic && r)) &&
								n.lin2val,
							l = 1,
							c = 0,
							d = 0,
							o = (o = (o && n.old ? n.old : n).transA) || n.transA;
						return (
							i && ((l *= -1), (c = n.len)),
							n.reversed && (c -= (l *= -1) * (n.sector || n.len)),
							e
								? ((t = t * l + c),
								  (d = (t -= h) / o + a),
								  r && (d = n.lin2val(d)))
								: ((i = l * ((t = r ? n.val2lin(t) : t) - a) * o),
								  (d =
										(n.isRadial ? i : M(i)) + c + l * h + (P(s) ? o * s : 0))),
							d
						);
					}),
					(I.prototype.toPixels = function (t, e) {
						return (
							this.translate(t, !1, !this.horiz, void 0, !0) +
							(e ? 0 : this.pos)
						);
					}),
					(I.prototype.toValue = function (t, e) {
						return this.translate(
							t - (e ? 0 : this.pos),
							!0,
							!this.horiz,
							void 0,
							!0
						);
					}),
					(I.prototype.getPlotLinePath = function (t) {
						var e,
							i,
							o,
							r,
							s,
							n = this,
							a = n.chart,
							h = n.left,
							l = n.top,
							c = t.old,
							d = t.value,
							p = t.lineWidth,
							u = (c && a.oldChartHeight) || a.chartHeight,
							f = (c && a.oldChartWidth) || a.chartWidth,
							g = n.transB,
							m = t.translatedValue,
							y = t.force;
						function v(t, e, i) {
							return (
								"pass" !== y &&
									(t < e || i < t) &&
									(y ? (t = x(t, e, i)) : (s = !0)),
								t
							);
						}
						t = {
							value: d,
							lineWidth: p,
							old: c,
							force: y,
							acrossPanes: t.acrossPanes,
							translatedValue: m,
						};
						return (
							A(this, "getPlotLinePath", t, function (t) {
								(m = O(m, n.translate(d, void 0, void 0, c))),
									(m = x(m, -1e5, 1e5)),
									(e = o = Math.round(m + g)),
									(i = r = Math.round(u - m - g)),
									P(m)
										? n.horiz
											? ((i = l),
											  (r = u - n.bottom),
											  (e = o = v(e, h, h + n.width)))
											: ((e = h),
											  (o = f - n.right),
											  (i = r = v(i, l, l + n.height)))
										: (y = !(s = !0)),
									(t.path =
										s && !y
											? null
											: a.renderer.crispLine(
													[
														["M", e, i],
														["L", o, r],
													],
													p || 1
											  ));
							}),
							t.path
						);
					}),
					(I.prototype.getLinearTickPositions = function (t, e, i) {
						var o,
							r,
							s,
							n = M(Math.floor(e / t) * t),
							a = M(Math.ceil(i / t) * t),
							h = [];
						if ((M(n + t) === n && (s = 20), this.single)) return [e];
						for (o = n; o <= a && (h.push(o), (o = M(o + t, s)) !== r); ) r = o;
						return h;
					}),
					(I.prototype.getMinorTickInterval = function () {
						var t = this.options;
						return !0 === t.minorTicks
							? O(t.minorTickInterval, "auto")
							: !1 === t.minorTicks
							? null
							: t.minorTickInterval;
					}),
					(I.prototype.getMinorTickPositions = function () {
						var t,
							e = this,
							i = e.options,
							o = e.tickPositions,
							r = e.minorTickInterval,
							s = e.pointRangePadding || 0,
							n = e.min - s,
							a = e.max + s,
							s = a - n,
							h = [];
						if (s && s / r < e.len / 3) {
							var l = e.logarithmic;
							if (l)
								this.paddedTicks.forEach(function (t, e, i) {
									e &&
										h.push.apply(
											h,
											l.getLogTickPositions(r, i[e - 1], i[e], !0)
										);
								});
							else if (e.dateTime && "auto" === this.getMinorTickInterval())
								h = h.concat(
									e.getTimeTicks(
										e.dateTime.normalizeTimeTickInterval(r),
										n,
										a,
										i.startOfWeek
									)
								);
							else
								for (t = n + ((o[0] - n) % r); t <= a && t !== h[0]; t += r)
									h.push(t);
						}
						return 0 !== h.length && e.trimTicks(h), h;
					}),
					(I.prototype.adjustForMinRange = function () {
						var t,
							e,
							i,
							o,
							r,
							s,
							n,
							a,
							h = this,
							l = h.options,
							c = h.logarithmic,
							d = h.min,
							p = h.max,
							u = 0;
						h.isXAxis &&
							void 0 === h.minRange &&
							!c &&
							(w(l.min) || w(l.max) || w(l.floor) || w(l.ceiling)
								? (h.minRange = null)
								: (h.series.forEach(function (t) {
										if (
											((o = t.xData),
											(r = t.xIncrement ? 1 : o.length - 1),
											1 < o.length)
										)
											for (e = r; 0 < e; e--)
												(i = o[e] - o[e - 1]), (!u || i < u) && (u = i);
								  }),
								  (h.minRange = Math.min(5 * u, h.dataMax - h.dataMin)))),
							p - d < h.minRange &&
								((t = h.dataMax - h.dataMin >= h.minRange),
								(s = [
									d - (s = ((a = h.minRange) - p + d) / 2),
									O(l.min, d - s),
								]),
								t &&
									(s[2] = h.logarithmic
										? h.logarithmic.log2lin(h.dataMin)
										: h.dataMin),
								(n = [(d = g(s)) + a, O(l.max, d + a)]),
								t && (n[2] = c ? c.log2lin(h.dataMax) : h.dataMax),
								(p = m(n)) - d < a &&
									((s[0] = p - a), (s[1] = O(l.min, p - a)), (d = g(s)))),
							(h.min = d),
							(h.max = p);
					}),
					(I.prototype.getClosest = function () {
						var o;
						return (
							this.categories
								? (o = 1)
								: this.series.forEach(function (t) {
										var e = t.closestPointRange,
											i =
												t.visible || !t.chart.options.chart.ignoreHiddenSeries;
										!t.noSharedTooltip &&
											w(e) &&
											i &&
											(o = w(o) ? Math.min(o, e) : e);
								  }),
							o
						);
					}),
					(I.prototype.nameToX = function (t) {
						var e,
							i = c(this.options.categories),
							o = i ? this.categories : this.names,
							r = t.options.x;
						return (
							(t.series.requireSorting = !1),
							-1 ===
							(r = w(r)
								? r
								: this.options.uniqueNames && o
								? i
									? o.indexOf(t.name)
									: O(o.keys[t.name], -1)
								: t.series.autoIncrement())
								? !i && o && (e = o.length)
								: (e = r),
							void 0 !== e
								? ((this.names[e] = t.name), (this.names.keys[t.name] = e))
								: t.x && (e = t.x),
							e
						);
					}),
					(I.prototype.updateNames = function () {
						var r = this,
							e = this.names;
						0 < e.length &&
							(Object.keys(e.keys).forEach(function (t) {
								delete e.keys[t];
							}),
							(e.length = 0),
							(this.minRange = this.userMinRange),
							(this.series || []).forEach(function (o) {
								(o.xIncrement = null),
									(o.points && !o.isDirtyData) ||
										((r.max = Math.max(r.max, o.xData.length - 1)),
										o.processData(),
										o.generatePoints()),
									o.data.forEach(function (t, e) {
										var i;
										t &&
											t.options &&
											void 0 !== t.name &&
											void 0 !== (i = r.nameToX(t)) &&
											i !== t.x &&
											((t.x = i), (o.xData[e] = i));
									});
							}));
					}),
					(I.prototype.setAxisTranslation = function () {
						var o,
							r = this,
							t = r.max - r.min,
							e = r.linkedParent,
							s = !!r.categories,
							n = r.isXAxis,
							a = r.axisPointRange || 0,
							h = 0,
							l = 0;
						r.transA;
						(n || s || a) &&
							((o = r.getClosest()),
							e
								? ((h = e.minPointOffset), (l = e.pointRangePadding))
								: r.series.forEach(function (t) {
										var e = s
												? 1
												: n
												? O(t.options.pointRange, o, 0)
												: r.axisPointRange || 0,
											i = t.options.pointPlacement;
										(a = Math.max(a, e)),
											(r.single && !s) ||
												((t = t.is("xrange") ? !n : n),
												(h = Math.max(h, t && v(i) ? 0 : e / 2)),
												(l = Math.max(l, t && "on" === i ? 0 : e)));
								  }),
							(e = r.ordinal && r.ordinal.slope && o ? r.ordinal.slope / o : 1),
							(r.minPointOffset = h *= e),
							(r.pointRangePadding = l *= e),
							(r.pointRange = Math.min(a, r.single && s ? 1 : t)),
							n && (r.closestPointRange = o)),
							(r.translationSlope =
								r.transA =
								e =
									r.staticScale || r.len / (t + l || 1)),
							(r.transB = r.horiz ? r.left : r.bottom),
							(r.minPixelPadding = e * h),
							A(this, "afterSetAxisTranslation");
					}),
					(I.prototype.minFromRange = function () {
						return this.max - this.range;
					}),
					(I.prototype.setTickInterval = function (t) {
						var e,
							i,
							o,
							r,
							s,
							n = this,
							a = n.chart,
							h = n.logarithmic,
							l = n.options,
							c = n.isXAxis,
							d = n.isLinked,
							p = l.tickPixelInterval,
							u = n.categories,
							f = n.softThreshold,
							g = l.maxPadding,
							m = l.minPadding,
							y =
								P(l.tickInterval) && 0 <= l.tickInterval
									? l.tickInterval
									: void 0,
							v = P(n.threshold) ? n.threshold : null,
							x =
								(n.dateTime || u || d || this.getTickAmount(),
								(o = O(n.userMin, l.min)),
								(r = O(n.userMax, l.max)),
								d
									? ((n.linkedParent = a[n.coll][l.linkedTo]),
									  (e = n.linkedParent.getExtremes()),
									  (n.min = O(e.min, e.dataMin)),
									  (n.max = O(e.max, e.dataMax)),
									  l.type !== n.linkedParent.options.type && T(11, 1, a))
									: (f &&
											w(v) &&
											(n.dataMin >= v
												? ((x = v), (m = 0))
												: n.dataMax <= v && ((i = v), (g = 0))),
									  (n.min = O(o, x, n.dataMin)),
									  (n.max = O(r, i, n.dataMax))),
								h &&
									(n.positiveValuesOnly &&
										!t &&
										Math.min(n.min, O(n.dataMin, n.min)) <= 0 &&
										T(10, 1, a),
									(n.min = M(h.log2lin(n.min), 16)),
									(n.max = M(h.log2lin(n.max), 16))),
								n.range &&
									w(n.max) &&
									((n.userMin =
										n.min =
										o =
											Math.max(n.dataMin, n.minFromRange())),
									(n.userMax = r = n.max),
									(n.range = null)),
								A(n, "foundExtremes"),
								n.beforePadding && n.beforePadding(),
								n.adjustForMinRange(),
								u ||
									n.axisPointRange ||
									(n.stacking && n.stacking.usePercentage) ||
									d ||
									!w(n.min) ||
									!w(n.max) ||
									((e = n.max - n.min) &&
										(!w(o) && m && (n.min -= e * m),
										!w(r) && g && (n.max += e * g))),
								P(n.userMin) ||
									(P(l.softMin) && l.softMin < n.min && (n.min = o = l.softMin),
									P(l.floor) && (n.min = Math.max(n.min, l.floor))),
								P(n.userMax) ||
									(P(l.softMax) && l.softMax > n.max && (n.max = r = l.softMax),
									P(l.ceiling) && (n.max = Math.min(n.max, l.ceiling))),
								f &&
									w(n.dataMin) &&
									((v = v || 0),
									!w(o) && n.min < v && n.dataMin >= v
										? (n.min = n.options.minRange
												? Math.min(v, n.max - n.minRange)
												: v)
										: !w(r) &&
										  n.max > v &&
										  n.dataMax <= v &&
										  (n.max = n.options.minRange
												? Math.max(v, n.min + n.minRange)
												: v)),
								P(n.min) &&
									P(n.max) &&
									!this.chart.polar &&
									n.min > n.max &&
									(w(n.options.min)
										? (n.max = n.min)
										: w(n.options.max) && (n.min = n.max)),
								n.min === n.max || void 0 === n.min || void 0 === n.max
									? (n.tickInterval = 1)
									: d &&
									  n.linkedParent &&
									  !y &&
									  p === n.linkedParent.options.tickPixelInterval
									? (n.tickInterval = y = n.linkedParent.tickInterval)
									: (n.tickInterval = O(
											y,
											this.tickAmount
												? (n.max - n.min) / Math.max(this.tickAmount - 1, 1)
												: void 0,
											u ? 1 : ((n.max - n.min) * p) / Math.max(n.len, p)
									  )),
								c &&
									!t &&
									((s =
										n.min !== (n.old && n.old.min) ||
										n.max !== (n.old && n.old.max)),
									n.series.forEach(function (t) {
										(t.forceCrop = t.forceCropping && t.forceCropping()),
											t.processData(s);
									}),
									A(this, "postProcessData", { hasExtremesChanged: s })),
								n.setAxisTranslation(),
								A(this, "initialAxisTranslation"),
								n.pointRange &&
									!y &&
									(n.tickInterval = Math.max(n.pointRange, n.tickInterval)),
								O(
									l.minTickInterval,
									n.dateTime &&
										!n.series.some(function (t) {
											return t.noSharedTooltip;
										})
										? n.closestPointRange
										: 0
								));
						!y && n.tickInterval < x && (n.tickInterval = x),
							n.dateTime ||
								n.logarithmic ||
								y ||
								(n.tickInterval = k(n, n.tickInterval)),
							this.tickAmount || (n.tickInterval = n.unsquish()),
							this.setTickPositions();
					}),
					(I.prototype.setTickPositions = function () {
						var t,
							e = this,
							i = this.options,
							o = i.tickPositions,
							r = i.tickPositioner,
							s = this.getMinorTickInterval(),
							n = this.hasVerticalPanning(),
							a = "colorAxis" === this.coll,
							h = (a || !n) && i.startOnTick,
							a = (a || !n) && i.endOnTick,
							l = [];
						if (
							((this.tickmarkOffset =
								this.categories &&
								"between" === i.tickmarkPlacement &&
								1 === this.tickInterval
									? 0.5
									: 0),
							(this.minorTickInterval =
								"auto" === s && this.tickInterval ? this.tickInterval / 5 : s),
							(this.single =
								this.min === this.max &&
								w(this.min) &&
								!this.tickAmount &&
								(parseInt(this.min, 10) === this.min ||
									!1 !== i.allowDecimals)),
							o)
						)
							l = o.slice();
						else if (P(this.min) && P(this.max)) {
							if (
								(e.ordinal && e.ordinal.positions) ||
								!(
									(this.max - this.min) / this.tickInterval >
									Math.max(2 * this.len, 200)
								)
							)
								if (e.dateTime)
									l = e.getTimeTicks(
										e.dateTime.normalizeTimeTickInterval(
											this.tickInterval,
											i.units
										),
										this.min,
										this.max,
										i.startOfWeek,
										e.ordinal && e.ordinal.positions,
										this.closestPointRange,
										!0
									);
								else if (e.logarithmic)
									l = e.logarithmic.getLogTickPositions(
										this.tickInterval,
										this.min,
										this.max
									);
								else
									for (
										var c = this.tickInterval, d = c;
										d <= 2 * c &&
										((l = this.getLinearTickPositions(
											this.tickInterval,
											this.min,
											this.max
										)),
										this.tickAmount && l.length > this.tickAmount);

									)
										this.tickInterval = k(this, (d *= 1.1));
							else (l = [this.min, this.max]), T(19, !1, this.chart);
							l.length > this.len &&
								(l = [l[0], l[l.length - 1]])[0] === l[1] &&
								(l.length = 1),
								r &&
									((this.tickPositions = l),
									(t = r.apply(e, [this.min, this.max])) && (l = t));
						}
						(this.tickPositions = l),
							(this.paddedTicks = l.slice(0)),
							this.trimTicks(l, h, a),
							!this.isLinked &&
								P(this.min) &&
								P(this.max) &&
								(this.single &&
									l.length < 2 &&
									!this.categories &&
									!this.series.some(function (t) {
										return (
											t.is("heatmap") && "between" === t.options.pointPlacement
										);
									}) &&
									((this.min -= 0.5), (this.max += 0.5)),
								o || t || this.adjustTickAmount()),
							A(this, "afterSetTickPositions");
					}),
					(I.prototype.trimTicks = function (t, e, i) {
						var o = t[0],
							r = t[t.length - 1],
							s = (!this.isOrdinal && this.minPointOffset) || 0;
						if ((A(this, "trimTicks"), !this.isLinked)) {
							if (e && o !== -1 / 0) this.min = o;
							else for (; this.min - s > t[0]; ) t.shift();
							if (i) this.max = r;
							else for (; this.max + s < t[t.length - 1]; ) t.pop();
							0 === t.length &&
								w(o) &&
								!this.options.tickPositions &&
								t.push((r + o) / 2);
						}
					}),
					(I.prototype.alignToOthers = function () {
						var i,
							o,
							r,
							e,
							s = this,
							n = [this],
							t = s.options,
							a =
								"yAxis" === this.coll &&
								this.chart.options.chart.alignThresholds,
							h = [];
						return (
							(s.thresholdAlignment = void 0),
							((!1 !== this.chart.options.chart.alignTicks && t.alignTicks) ||
								a) &&
								!1 !== t.startOnTick &&
								!1 !== t.endOnTick &&
								!s.logarithmic &&
								((r = (o = function (t) {
									var e = t.horiz,
										t = t.options;
									return [e ? t.left : t.top, t.width, t.height, t.pane].join(
										","
									);
								})(this)),
								this.chart[this.coll].forEach(function (t) {
									var e = t.series;
									e.length &&
										e.some(function (t) {
											return t.visible;
										}) &&
										t !== s &&
										o(t) === r &&
										((i = !0), n.push(t));
								})),
							i &&
								a &&
								(n.forEach(function (t) {
									t = t.getThresholdAlignment(s);
									P(t) && h.push(t);
								}),
								(e =
									1 < h.length
										? h.reduce(function (t, e) {
												return t + e;
										  }, 0) / h.length
										: void 0),
								n.forEach(function (t) {
									t.thresholdAlignment = e;
								})),
							i
						);
					}),
					(I.prototype.getThresholdAlignment = function (t) {
						if (
							((!P(this.dataMin) ||
								(this !== t &&
									this.series.some(function (t) {
										return t.isDirty || t.isDirtyData;
									}))) &&
								this.getSeriesExtremes(),
							P(this.threshold))
						)
							return (
								(t = x(
									(this.threshold - (this.dataMin || 0)) /
										((this.dataMax || 0) - (this.dataMin || 0)),
									0,
									1
								)),
								this.options.reversed ? 1 - t : t
							);
					}),
					(I.prototype.getTickAmount = function () {
						var t = this.options,
							e = t.tickPixelInterval,
							i = t.tickAmount;
						(i =
							!(i =
								!w(t.tickInterval) &&
								!i &&
								this.len < e &&
								!this.isRadial &&
								!this.logarithmic &&
								t.startOnTick &&
								t.endOnTick
									? 2
									: i) && this.alignToOthers()
								? Math.ceil(this.len / e) + 1
								: i) < 4 && ((this.finalTickAmt = i), (i = 5)),
							(this.tickAmount = i);
					}),
					(I.prototype.adjustTickAmount = function () {
						function t() {
							c.push(M(c[c.length - 1] + g));
						}
						function e() {
							c.unshift(M(c[0] - g));
						}
						var i,
							o,
							r,
							s = this,
							n = s.finalTickAmt,
							a = s.max,
							h = s.min,
							l = s.options,
							c = s.tickPositions,
							d = s.tickAmount,
							p = s.thresholdAlignment,
							u = c && c.length,
							f = O(s.threshold, s.softThreshold ? 0 : null),
							g = s.tickInterval;
						if (
							(P(p) &&
								((r =
									p < 0.5 ? Math.ceil(p * (d - 1)) : Math.floor(p * (d - 1))),
								l.reversed && (r = d - 1 - r)),
							s.hasData() && P(h) && P(a))
						) {
							p = function () {
								(s.transA *= (u - 1) / (d - 1)),
									(s.min = l.startOnTick ? c[0] : Math.min(h, c[0])),
									(s.max = l.endOnTick
										? c[c.length - 1]
										: Math.max(a, c[c.length - 1]));
							};
							if (P(r) && P(s.threshold)) {
								for (
									;
									c[r] !== f ||
									c.length !== d ||
									c[0] > h ||
									c[c.length - 1] < a;

								) {
									for (c.length = 0, c.push(s.threshold); c.length < d; )
										(void 0 === c[r] || c[r] > s.threshold ? e : t)();
									if (g > 8 * s.tickInterval) break;
									g *= 2;
								}
								p();
							} else if (u < d) {
								for (; c.length < d; ) (c.length % 2 || h === f ? t : e)();
								p();
							}
							if (w(n)) {
								for (o = i = c.length; o--; )
									((3 === n && o % 2 == 1) || (n <= 2 && 0 < o && o < i - 1)) &&
										c.splice(o, 1);
								s.finalTickAmt = void 0;
							}
						}
					}),
					(I.prototype.setScale = function () {
						var t = this,
							e = !1,
							i = !1,
							o =
								(t.series.forEach(function (t) {
									(e = e || t.isDirtyData || t.isDirty),
										(i = i || (t.xAxis && t.xAxis.isDirty) || !1);
								}),
								t.setAxisSize(),
								t.len !== (t.old && t.old.len));
						o ||
						e ||
						i ||
						t.isLinked ||
						t.forceRedraw ||
						t.userMin !== (t.old && t.old.userMin) ||
						t.userMax !== (t.old && t.old.userMax) ||
						t.alignToOthers()
							? (t.stacking &&
									(t.stacking.resetStacks(), t.stacking.buildStacks()),
							  (t.forceRedraw = !1),
							  t.getSeriesExtremes(),
							  t.setTickInterval(),
							  t.isDirty ||
									(t.isDirty =
										o ||
										t.min !== (t.old && t.old.min) ||
										t.max !== (t.old && t.old.max)))
							: t.stacking && t.stacking.cleanStacks(),
							e && t.panningState && (t.panningState.isDirty = !0),
							A(this, "afterSetScale");
					}),
					(I.prototype.setExtremes = function (t, e, i, o, r) {
						var s = this,
							n = s.chart;
						(i = O(i, !0)),
							s.series.forEach(function (t) {
								delete t.kdTree;
							}),
							(r = l(r, { min: t, max: e })),
							A(s, "setExtremes", r, function () {
								(s.userMin = t),
									(s.userMax = e),
									(s.eventArgs = r),
									i && n.redraw(o);
							});
					}),
					(I.prototype.zoom = function (t, e) {
						var o = this,
							r = this.dataMin,
							s = this.dataMax,
							i = this.options,
							n = Math.min(r, O(i.min, r)),
							a = Math.max(s, O(i.max, s)),
							i = { newMin: t, newMax: e };
						return (
							A(this, "zoom", i, function (t) {
								var e = t.newMin,
									i = t.newMax;
								(e === o.min && i === o.max) ||
									(o.allowZoomOutside ||
										(w(r) && a < (e = e < n ? n : e) && (e = a),
										w(s) && a < (i = i < n ? n : i) && (i = a)),
									(o.displayBtn = void 0 !== e || void 0 !== i),
									o.setExtremes(e, i, !1, void 0, { trigger: "zoom" })),
									(t.zoomed = !0);
							}),
							i.zoomed
						);
					}),
					(I.prototype.setAxisSize = function () {
						var t = this.chart,
							e = this.options,
							i = e.offsets || [0, 0, 0, 0],
							o = this.horiz,
							r = (this.width = Math.round(
								u(O(e.width, t.plotWidth - i[3] + i[1]), t.plotWidth)
							)),
							s = (this.height = Math.round(
								u(O(e.height, t.plotHeight - i[0] + i[2]), t.plotHeight)
							)),
							n = (this.top = Math.round(
								u(O(e.top, t.plotTop + i[0]), t.plotHeight, t.plotTop)
							)),
							e = (this.left = Math.round(
								u(O(e.left, t.plotLeft + i[3]), t.plotWidth, t.plotLeft)
							));
						(this.bottom = t.chartHeight - s - n),
							(this.right = t.chartWidth - r - e),
							(this.len = Math.max(o ? r : s, 0)),
							(this.pos = o ? e : n);
					}),
					(I.prototype.getExtremes = function () {
						var t = this,
							e = t.logarithmic;
						return {
							min: e ? M(e.lin2log(t.min)) : t.min,
							max: e ? M(e.lin2log(t.max)) : t.max,
							dataMin: t.dataMin,
							dataMax: t.dataMax,
							userMin: t.userMin,
							userMax: t.userMax,
						};
					}),
					(I.prototype.getThreshold = function (t) {
						var e = this,
							i = e.logarithmic,
							o = i ? i.lin2log(e.min) : e.min,
							i = i ? i.lin2log(e.max) : e.max;
						return (
							null === t || t === -1 / 0
								? (t = o)
								: t === 1 / 0
								? (t = i)
								: t < o
								? (t = o)
								: i < t && (t = i),
							e.translate(t, 0, 1, 0, 1)
						);
					}),
					(I.prototype.autoLabelAlign = function (t) {
						var e = (O(t, 0) - 90 * this.side + 720) % 360,
							t = { align: "center" };
						return (
							A(this, "autoLabelAlign", t, function (t) {
								15 < e && e < 165
									? (t.align = "right")
									: 195 < e && e < 345 && (t.align = "left");
							}),
							t.align
						);
					}),
					(I.prototype.tickSize = function (t) {
						var e,
							i = this.options,
							o = O(
								i["tick" === t ? "tickWidth" : "minorTickWidth"],
								"tick" === t && this.isXAxis && !this.categories ? 1 : 0
							),
							r = i["tick" === t ? "tickLength" : "minorTickLength"],
							i = {
								tickSize: (e =
									o && r
										? [(r = "inside" === i[t + "Position"] ? -r : r), o]
										: e),
							};
						return A(this, "afterTickSize", i), i.tickSize;
					}),
					(I.prototype.labelMetrics = function () {
						var t = (this.tickPositions && this.tickPositions[0]) || 0;
						return this.chart.renderer.fontMetrics(
							this.options.labels.style.fontSize,
							this.ticks[t] && this.ticks[t].label
						);
					}),
					(I.prototype.unsquish = function () {
						function t(t) {
							var e = 1 < (e = t / (n || 1)) ? Math.ceil(e) : 1;
							return (
								l < e * s &&
									t !== 1 / 0 &&
									n !== 1 / 0 &&
									l &&
									(e = Math.ceil(l / s)),
								M(e * s)
							);
						}
						var e,
							i,
							o = this.options.labels,
							r = this.horiz,
							s = this.tickInterval,
							n =
								this.len /
								(((this.categories ? 1 : 0) + this.max - this.min) / s),
							a = o.rotation,
							h = this.labelMetrics(),
							l = Math.max(this.max - this.min, 0),
							c = s,
							d = Number.MAX_VALUE;
						if (r) {
							if (
								(o.staggerLines ||
									(P(a)
										? (i = [a])
										: n < o.autoRotationLimit && (i = o.autoRotation)),
								i)
							)
								for (var p, u, f = 0, g = i; f < g.length; f++) {
									var m = g[f];
									(m === a || (m && -90 <= m && m <= 90)) &&
										(u =
											(p = t(Math.abs(h.h / Math.sin(y * m)))) +
											Math.abs(m / 360)) < d &&
										((d = u), (e = m), (c = p));
								}
						} else c = t(h.h);
						return (
							(this.autoRotation = i),
							(this.labelRotation = O(e, P(a) ? a : 0)),
							o.step ? s : c
						);
					}),
					(I.prototype.getSlotWidth = function (t) {
						var e = this.chart,
							i = this.horiz,
							o = this.options.labels,
							r = Math.max(
								this.tickPositions.length - (this.categories ? 0 : 1),
								1
							),
							s = e.margin[3];
						if (t && P(t.slotWidth)) return t.slotWidth;
						if (i && o.step < 2)
							return o.rotation ? 0 : ((this.staggerLines || 1) * this.len) / r;
						if (!i) {
							t = o.style.width;
							if (void 0 !== t) return parseInt(String(t), 10);
							if (s) return s - e.spacing[3];
						}
						return 0.33 * e.chartWidth;
					}),
					(I.prototype.renderUnsquish = function () {
						var r,
							s,
							t,
							e,
							i = this.chart,
							o = i.renderer,
							n = this.tickPositions,
							a = this.ticks,
							h = this.options.labels,
							l = h.style,
							c = this.horiz,
							d = this.getSlotWidth(),
							p = Math.max(1, Math.round(d - 2 * h.padding)),
							u = {},
							f = this.labelMetrics(),
							g = l.textOverflow,
							m = 0;
						if (
							(v(h.rotation) || (u.rotation = h.rotation || 0),
							n.forEach(function (t) {
								t = a[t];
								t.movedLabel && t.replaceMovedLabel(),
									t &&
										t.label &&
										t.label.textPxLength > m &&
										(m = t.label.textPxLength);
							}),
							(this.maxLabelLength = m),
							this.autoRotation)
						)
							p < m && m > f.h
								? (u.rotation = this.labelRotation)
								: (this.labelRotation = 0);
						else if (d && ((r = p), !g))
							for (s = "clip", t = n.length; !c && t--; )
								(e = n[t]),
									(e = a[e].label) &&
										(e.styles && "ellipsis" === e.styles.textOverflow
											? e.css({ textOverflow: "clip" })
											: e.textPxLength > d && e.css({ width: d + "px" }),
										e.getBBox().height > this.len / n.length - (f.h - f.f) &&
											(e.specificTextOverflow = "ellipsis"));
						u.rotation &&
							((r = m > 0.5 * i.chartHeight ? 0.33 * i.chartHeight : m),
							g || (s = "ellipsis")),
							(this.labelAlign =
								h.align || this.autoLabelAlign(this.labelRotation)),
							this.labelAlign && (u.align = this.labelAlign),
							n.forEach(function (t) {
								var t = a[t],
									e = t && t.label,
									i = l.width,
									o = {};
								e &&
									(e.attr(u),
									t.shortenLabel
										? t.shortenLabel()
										: r &&
										  !i &&
										  "nowrap" !== l.whiteSpace &&
										  (r < e.textPxLength || "SPAN" === e.element.tagName)
										? ((o.width = r + "px"),
										  g || (o.textOverflow = e.specificTextOverflow || s),
										  e.css(o))
										: e.styles &&
										  e.styles.width &&
										  !o.width &&
										  !i &&
										  e.css({ width: null }),
									delete e.specificTextOverflow,
									(t.rotation = u.rotation));
							}, this),
							(this.tickRotCorr = o.rotCorr(
								f.b,
								this.labelRotation || 0,
								0 !== this.side
							));
					}),
					(I.prototype.hasData = function () {
						return (
							this.series.some(function (t) {
								return t.hasData();
							}) ||
							(this.options.showEmpty && w(this.min) && w(this.max))
						);
					}),
					(I.prototype.addTitle = function (t) {
						var e,
							i = this,
							o = i.chart.renderer,
							r = i.horiz,
							s = i.opposite,
							n = i.options.title,
							a = i.chart.styledMode;
						i.axisTitle ||
							((e =
								(e = n.textAlign) ||
								(r
									? { low: "left", middle: "center", high: "right" }
									: {
											low: s ? "right" : "left",
											middle: "center",
											high: s ? "left" : "right",
									  })[n.align]),
							(i.axisTitle = o
								.text(n.text || "", 0, 0, n.useHTML)
								.attr({ zIndex: 7, rotation: n.rotation, align: e })
								.addClass("highcharts-axis-title")),
							a || i.axisTitle.css(d(n.style)),
							i.axisTitle.add(i.axisGroup),
							(i.axisTitle.isNew = !0)),
							a ||
								n.style.width ||
								i.isRadial ||
								i.axisTitle.css({ width: i.len + "px" }),
							i.axisTitle[t ? "show" : "hide"](t);
					}),
					(I.prototype.generateTick = function (t) {
						var e = this.ticks;
						e[t] ? e[t].addLabel() : (e[t] = new S(this, t));
					}),
					(I.prototype.getOffset = function () {
						var t,
							e,
							i,
							o = this,
							r = this,
							s = r.chart,
							n = r.horiz,
							a = r.options,
							h = r.side,
							l = r.ticks,
							c = r.tickPositions,
							d = r.coll,
							p = r.axisParent,
							u = s.renderer,
							f = s.inverted && !r.isZAxis ? [1, 0, 3, 2][h] : h,
							g = r.hasData(),
							m = a.title,
							y = a.labels,
							v = s.axisOffset,
							s = s.clipOffset,
							x = [-1, 1, 1, -1][h],
							b = a.className,
							S = 0,
							k = 0,
							C = 0;
						(r.showAxis = i = g || a.showEmpty),
							(r.staggerLines = (r.horiz && y.staggerLines) || void 0),
							r.axisGroup ||
								((r.gridGroup = (e = function (t, e, i) {
									return u
										.g(t)
										.attr({ zIndex: i })
										.addClass(
											"highcharts-".concat(d.toLowerCase()).concat(e, " ") +
												(o.isRadial
													? "highcharts-radial-axis".concat(e, " ")
													: "") +
												(b || "")
										)
										.add(p);
								})("grid", "-grid", a.gridZIndex)),
								(r.axisGroup = e("axis", "", a.zIndex)),
								(r.labelGroup = e("axis-labels", "-labels", y.zIndex))),
							g || r.isLinked
								? (c.forEach(function (t) {
										r.generateTick(t);
								  }),
								  r.renderUnsquish(),
								  (r.reserveSpaceDefault =
										0 === h ||
										2 === h ||
										{ 1: "left", 3: "right" }[h] === r.labelAlign),
								  O(
										y.reserveSpace,
										"center" === r.labelAlign || null,
										r.reserveSpaceDefault
								  ) &&
										c.forEach(function (t) {
											C = Math.max(l[t].getLabelSize(), C);
										}),
								  r.staggerLines && (C *= r.staggerLines),
								  (r.labelOffset = C * (r.opposite ? -1 : 1)))
								: L(l, function (t, e) {
										t.destroy(), delete l[e];
								  }),
							m &&
								m.text &&
								!1 !== m.enabled &&
								(r.addTitle(i),
								i &&
									!1 !== m.reserveSpace &&
									((r.titleOffset = S =
										r.axisTitle.getBBox()[n ? "height" : "width"]),
									(t = m.offset),
									(k = w(t) ? 0 : O(m.margin, n ? 5 : 10)))),
							r.renderLine(),
							(r.offset = x * O(a.offset, v[h] ? v[h] + (a.margin || 0) : 0)),
							(r.tickRotCorr = r.tickRotCorr || { x: 0, y: 0 }),
							(e =
								0 === h ? -r.labelMetrics().h : 2 === h ? r.tickRotCorr.y : 0),
							(g = Math.abs(C) + k),
							C &&
								(g =
									(g -= e) + x * (n ? O(y.y, r.tickRotCorr.y + 8 * x) : y.x)),
							(r.axisTitleMargin = O(t, g)),
							r.getMaxLabelDimensions &&
								(r.maxLabelDimensions = r.getMaxLabelDimensions(l, c)),
							"colorAxis" !== d &&
								((i = this.tickSize("tick")),
								(v[h] = Math.max(
									v[h],
									(r.axisTitleMargin || 0) + S + x * r.offset,
									g,
									c && c.length && i ? i[0] + x * r.offset : 0
								)),
								(m =
									!r.axisLine || a.offset
										? 0
										: 2 * Math.floor(r.axisLine.strokeWidth() / 2)),
								(s[f] = Math.max(s[f], m))),
							A(this, "afterGetOffset");
					}),
					(I.prototype.getLinePath = function (t) {
						var e = this.chart,
							i = this.opposite,
							o = this.offset,
							r = this.horiz,
							s = this.left + (i ? this.width : 0) + o,
							o = e.chartHeight - this.bottom - (i ? this.height : 0) + o;
						return (
							i && (t *= -1),
							e.renderer.crispLine(
								[
									["M", r ? this.left : s, r ? o : this.top],
									[
										"L",
										r ? e.chartWidth - this.right : s,
										r ? o : e.chartHeight - this.bottom,
									],
								],
								t
							)
						);
					}),
					(I.prototype.renderLine = function () {
						this.axisLine ||
							((this.axisLine = this.chart.renderer
								.path()
								.addClass("highcharts-axis-line")
								.add(this.axisGroup)),
							this.chart.styledMode ||
								this.axisLine.attr({
									stroke: this.options.lineColor,
									"stroke-width": this.options.lineWidth,
									zIndex: 7,
								}));
					}),
					(I.prototype.getTitlePosition = function () {
						var t = this.horiz,
							e = this.left,
							i = this.top,
							o = this.len,
							r = this.options.title,
							s = t ? e : i,
							n = this.opposite,
							a = this.offset,
							h = r.x,
							l = r.y,
							c = this.axisTitle,
							d = this.chart.renderer.fontMetrics(r.style.fontSize, c),
							c = c ? Math.max(c.getBBox(!1, 0).height - d.h - 1, 0) : 0,
							s = {
								low: s + (t ? 0 : o),
								middle: s + o / 2,
								high: s + (t ? o : 0),
							}[r.align],
							o =
								(t ? i + this.height : e) +
								(t ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) +
								[-c, c, d.f, -c][this.side],
							r = {
								x: t ? s + h : o + (n ? this.width : 0) + a + h,
								y: t ? o + l - (n ? this.height : 0) + a : s + l,
							};
						return A(this, "afterGetTitlePosition", { titlePosition: r }), r;
					}),
					(I.prototype.renderMinorTick = function (t, e) {
						var i = this.minorTicks;
						i[t] || (i[t] = new S(this, t, "minor")),
							e && i[t].isNew && i[t].render(null, !0),
							i[t].render(null, !1, 1);
					}),
					(I.prototype.renderTick = function (t, e, i) {
						var o = this,
							r = o.isLinked,
							s = o.ticks;
						(!r || (t >= o.min && t <= o.max) || (o.grid && o.grid.isColumn)) &&
							(s[t] || (s[t] = new S(o, t)),
							i && s[t].isNew && s[t].render(e, !0, -1),
							s[t].render(e));
					}),
					(I.prototype.render = function () {
						var i,
							o,
							r,
							s = this,
							n = s.chart,
							a = s.logarithmic,
							t = n.renderer,
							e = s.options,
							h = s.isLinked,
							l = s.tickPositions,
							c = s.axisTitle,
							d = s.ticks,
							p = s.minorTicks,
							u = s.alternateBands,
							f = e.stackLabels,
							g = e.alternateGridColor,
							m = s.tickmarkOffset,
							y = s.axisLine,
							v = s.showAxis,
							x = C(t.globalAnimation);
						(s.labelEdge.length = 0),
							(s.overlap = !1),
							[d, p, u].forEach(function (t) {
								L(t, function (t) {
									t.isActive = !1;
								});
							}),
							(s.hasData() || h) &&
								((r = s.chart.hasRendered && s.old && P(s.old.min)),
								s.minorTickInterval &&
									!s.categories &&
									s.getMinorTickPositions().forEach(function (t) {
										s.renderMinorTick(t, r);
									}),
								l.length &&
									(l.forEach(function (t, e) {
										s.renderTick(t, e, r);
									}),
									m &&
										(0 === s.min || s.single) &&
										(d[-1] || (d[-1] = new S(s, -1, null, !0)),
										d[-1].render(-1))),
								g &&
									l.forEach(function (t, e) {
										(o = void 0 !== l[e + 1] ? l[e + 1] + m : s.max - m),
											e % 2 == 0 &&
												t < s.max &&
												o <= s.max + (n.polar ? -m : m) &&
												(u[t] || (u[t] = new b.PlotLineOrBand(s)),
												(i = t + m),
												(u[t].options = {
													from: a ? a.lin2log(i) : i,
													to: a ? a.lin2log(o) : o,
													color: g,
													className: "highcharts-alternate-grid",
												}),
												u[t].render(),
												(u[t].isActive = !0));
									}),
								s._addedPlotLB ||
									((s._addedPlotLB = !0),
									(e.plotLines || [])
										.concat(e.plotBands || [])
										.forEach(function (t) {
											s.addPlotBandOrLine(t);
										}))),
							[d, p, u].forEach(function (e) {
								var i = [],
									t = x.duration;
								L(e, function (t, e) {
									t.isActive ||
										(t.render(e, !1, 0), (t.isActive = !1), i.push(e));
								}),
									j(
										function () {
											for (var t = i.length; t--; )
												e[i[t]] &&
													!e[i[t]].isActive &&
													(e[i[t]].destroy(), delete e[i[t]]);
										},
										e !== u && n.hasRendered && t ? t : 0
									);
							}),
							y &&
								(y[y.isPlaced ? "animate" : "attr"]({
									d: this.getLinePath(y.strokeWidth()),
								}),
								(y.isPlaced = !0),
								y[v ? "show" : "hide"](v)),
							c &&
								v &&
								((t = s.getTitlePosition()),
								c[c.isNew ? "attr" : "animate"](t),
								(c.isNew = !1)),
							f && f.enabled && s.stacking && s.stacking.renderStackTotals(),
							(s.old = {
								len: s.len,
								max: s.max,
								min: s.min,
								transA: s.transA,
								userMax: s.userMax,
								userMin: s.userMin,
							}),
							(s.isDirty = !1),
							A(this, "afterRender");
					}),
					(I.prototype.redraw = function () {
						this.visible &&
							(this.render(),
							this.plotLinesAndBands.forEach(function (t) {
								t.render();
							})),
							this.series.forEach(function (t) {
								t.isDirty = !0;
							});
					}),
					(I.prototype.getKeepProps = function () {
						return this.keepProps || I.keepProps;
					}),
					(I.prototype.destroy = function (t) {
						var e,
							i = this,
							o = i.plotLinesAndBands,
							r = this.eventOptions;
						if (
							(A(this, "destroy", { keepEvents: t }),
							t || E(i),
							[i.ticks, i.minorTicks, i.alternateBands].forEach(function (t) {
								n(t);
							}),
							o)
						)
							for (var s = o.length; s--; ) o[s].destroy();
						for (e in ([
							"axisLine",
							"axisTitle",
							"axisGroup",
							"gridGroup",
							"labelGroup",
							"cross",
							"scrollbar",
						].forEach(function (t) {
							i[t] && (i[t] = i[t].destroy());
						}),
						i.plotLinesAndBandsGroups))
							i.plotLinesAndBandsGroups[e] =
								i.plotLinesAndBandsGroups[e].destroy();
						L(i, function (t, e) {
							-1 === i.getKeepProps().indexOf(e) && delete i[e];
						}),
							(this.eventOptions = r);
					}),
					(I.prototype.drawCrosshair = function (t, e) {
						var i,
							o,
							r = this.crosshair,
							s = O(r && r.snap, !0),
							n = this.chart,
							a = this.cross;
						if (
							(A(this, "drawCrosshair", { e: t, point: e }),
							(t = t || (this.cross && this.cross.e)),
							r && !1 !== (w(e) || !s))
						) {
							if (
								(s
									? w(e) &&
									  (o = O(
											"colorAxis" !== this.coll ? e.crosshairPos : null,
											this.isXAxis ? e.plotX : this.len - e.plotY
									  ))
									: (o =
											t &&
											(this.horiz
												? t.chartX - this.pos
												: this.len - t.chartY + this.pos)),
								w(o) &&
									((s = {
										value: e && (this.isXAxis ? e.x : O(e.stackY, e.y)),
										translatedValue: o,
									}),
									n.polar &&
										l(s, {
											isCrosshair: !0,
											chartX: t && t.chartX,
											chartY: t && t.chartY,
											point: e,
										}),
									(i = this.getPlotLinePath(s) || null)),
								!w(i))
							)
								return void this.hideCrosshair();
							(o = this.categories && !this.isRadial),
								a ||
									((this.cross = a =
										n.renderer
											.path()
											.addClass(
												"highcharts-crosshair highcharts-crosshair-" +
													(o ? "category " : "thin ") +
													(r.className || "")
											)
											.attr({ zIndex: O(r.zIndex, 2) })
											.add()),
									n.styledMode ||
										(a
											.attr({
												stroke:
													r.color ||
													(o
														? h.parse("#ccd6eb").setOpacity(0.25).get()
														: "#cccccc"),
												"stroke-width": O(r.width, 1),
											})
											.css({ "pointer-events": "none" }),
										r.dashStyle && a.attr({ dashstyle: r.dashStyle }))),
								a.show().attr({ d: i }),
								o && !r.width && a.attr({ "stroke-width": this.transA }),
								(this.cross.e = t);
						} else this.hideCrosshair();
						A(this, "afterDrawCrosshair", { e: t, point: e });
					}),
					(I.prototype.hideCrosshair = function () {
						this.cross && this.cross.hide(), A(this, "afterHideCrosshair");
					}),
					(I.prototype.hasVerticalPanning = function () {
						var t = this.chart.options.chart.panning;
						return Boolean(t && t.enabled && /y/.test(t.type));
					}),
					(I.prototype.validatePositiveValue = function (t) {
						return P(t) && 0 < t;
					}),
					(I.prototype.update = function (t, e) {
						var i = this.chart;
						(t = d(this.userOptions, t)),
							this.destroy(!0),
							this.init(i, t),
							(i.isDirtyBox = !0),
							O(e, !0) && i.redraw();
					}),
					(I.prototype.remove = function (t) {
						for (
							var e = this.chart, i = this.coll, o = this.series, r = o.length;
							r--;

						)
							o[r] && o[r].remove(!1);
						s(e.axes, this),
							s(e[i], this),
							e[i].forEach(function (t, e) {
								t.options.index = t.userOptions.index = e;
							}),
							this.destroy(),
							(e.isDirtyBox = !0),
							O(t, !0) && e.redraw();
					}),
					(I.prototype.setTitle = function (t, e) {
						this.update({ title: t }, e);
					}),
					(I.prototype.setCategories = function (t, e) {
						this.update({ categories: t }, e);
					}),
					(I.defaultOptions = e.defaultXAxisOptions),
					(I.keepProps = [
						"extKey",
						"hcEvents",
						"names",
						"series",
						"userMax",
						"userMin",
					]),
					I
				);
			}
		),
		e(t, "Core/Axis/DateTimeAxis.js", [t["Core/Utilities.js"]], function (t) {
			var e,
				i = t.addEvent,
				a = t.getMagnitude,
				h = t.normalizeTickInterval,
				l = t.timeUnits,
				t = (e = e || {}),
				o = [];
			function r() {
				return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
			}
			function s(t) {
				"datetime" !== t.userOptions.type
					? (this.dateTime = void 0)
					: this.dateTime || (this.dateTime = new n(this));
			}
			(t.compose = function (t) {
				return (
					-1 === o.indexOf(t) &&
						(o.push(t),
						t.keepProps.push("dateTime"),
						(t.prototype.getTimeTicks = r),
						i(t, "init", s)),
					t
				);
			}),
				(c.prototype.normalizeTimeTickInterval = function (t, e) {
					for (
						var i = e || [
								["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
								["second", [1, 2, 5, 10, 15, 30]],
								["minute", [1, 2, 5, 10, 15, 30]],
								["hour", [1, 2, 3, 4, 6, 8, 12]],
								["day", [1, 2]],
								["week", [1, 2]],
								["month", [1, 2, 3, 4, 6]],
								["year", null],
							],
							o = i[i.length - 1],
							r = l[o[0]],
							s = o[1],
							n = 0;
						n < i.length;
						n++
					) {
						(o = i[n]), (r = l[o[0]]), (s = o[1]);
						if (i[n + 1])
							if (t <= (r * s[s.length - 1] + l[i[n + 1][0]]) / 2) break;
					}
					return (
						r === l.year && t < 5 * r && (s = [1, 2, 5]),
						{
							unitRange: r,
							count: h(t / r, s, "year" === o[0] ? Math.max(a(t / r), 1) : 1),
							unitName: o[0],
						}
					);
				}),
				(c.prototype.getXDateFormat = function (t, e) {
					var i = this.axis,
						o = i.chart.time;
					return i.closestPointRange
						? o.getDateFormat(
								i.closestPointRange,
								t,
								i.options.startOfWeek,
								e
						  ) || o.resolveDTLFormat(e.year).main
						: o.resolveDTLFormat(e.day).main;
				});
			var n = c;
			function c(t) {
				this.axis = t;
			}
			return (t.Additions = n), e;
		}),
		e(
			t,
			"Core/Axis/LogarithmicAxis.js",
			[t["Core/Utilities.js"]],
			function (t) {
				var e,
					i = t.addEvent,
					x = (t.getMagnitude, t.normalizeTickInterval),
					b = t.pick,
					t = (e = e || {}),
					o = [];
				function r(t) {
					var t = t.userOptions,
						e = this.logarithmic;
					"logarithmic" !== t.type
						? (this.logarithmic = void 0)
						: e || (this.logarithmic = new n(this));
				}
				function s() {
					var e = this.logarithmic;
					e &&
						((this.lin2val = function (t) {
							return e.lin2log(t);
						}),
						(this.val2lin = function (t) {
							return e.log2lin(t);
						}));
				}
				(t.compose = function (t) {
					return (
						-1 === o.indexOf(t) &&
							(o.push(t),
							t.keepProps.push("logarithmic"),
							i(t, "init", r),
							i(t, "afterInit", s)),
						t
					);
				}),
					(a.prototype.getLogTickPositions = function (t, e, i, o) {
						var r = this,
							s = r.axis,
							n = s.len,
							a = s.options,
							h = [];
						if ((o || (r.minorAutoInterval = void 0), 0.5 <= t))
							(t = Math.round(t)), (h = s.getLinearTickPositions(t, e, i));
						else if (0.08 <= t)
							for (
								var l,
									c,
									d = void 0,
									p = void 0,
									u = void 0,
									f = void 0,
									g = void 0,
									d =
										0.3 < t
											? [1, 2, 4]
											: 0.15 < t
											? [1, 2, 4, 6, 8]
											: [1, 2, 3, 4, 5, 6, 7, 8, 9],
									p = Math.floor(e);
								p < i + 1 && !g;
								p++
							)
								for (l = d.length, u = 0; u < l && !g; u++)
									e < (c = r.log2lin(r.lin2log(p) * d[u])) &&
										(!o || f <= i) &&
										void 0 !== f &&
										h.push(f),
										i < f && (g = !0),
										(f = c);
						else {
							var m = r.lin2log(e),
								y = r.lin2log(i),
								v = o ? s.getMinorTickInterval() : a.tickInterval,
								a = a.tickPixelInterval / (o ? 5 : 1),
								n = o ? n / s.tickPositions.length : n;
							(t = b(
								"auto" === v ? null : v,
								r.minorAutoInterval,
								((y - m) * a) / (n || 1)
							)),
								(t = x(t)),
								(h = s.getLinearTickPositions(t, m, y).map(r.log2lin)),
								o || (r.minorAutoInterval = t / 5);
						}
						return o || (s.tickInterval = t), h;
					}),
					(a.prototype.lin2log = function (t) {
						return Math.pow(10, t);
					}),
					(a.prototype.log2lin = function (t) {
						return Math.log(t) / Math.LN10;
					});
				var n = a;
				function a(t) {
					this.axis = t;
				}
				return (t.Additions = n), e;
			}
		),
		e(
			t,
			"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js",
			[t["Core/Utilities.js"]],
			function (t) {
				var e,
					n,
					s = t.erase,
					i = t.extend,
					f = t.isNumber,
					o = ((e = e || {}), []),
					r =
						((e.compose = function (t, e) {
							return (
								(n = n || t),
								-1 === o.indexOf(e) && (o.push(e), i(e.prototype, r.prototype)),
								e
							);
						}),
						(a.prototype.getPlotBandPath = function (t, e, i) {
							void 0 === i && (i = this.options);
							var o,
								r,
								s = this.getPlotLinePath({
									value: e,
									force: !0,
									acrossPanes: i.acrossPanes,
								}),
								n = [],
								a = this.horiz,
								e =
									!f(this.min) ||
									!f(this.max) ||
									(t < this.min && e < this.min) ||
									(t > this.max && e > this.max),
								h = this.getPlotLinePath({
									value: t,
									force: !0,
									acrossPanes: i.acrossPanes,
								}),
								l = 1;
							if (h && s)
								for (
									e && ((r = h.toString() === s.toString()), (l = 0)), o = 0;
									o < h.length;
									o += 2
								) {
									var c = h[o],
										d = h[o + 1],
										p = s[o],
										u = s[o + 1];
									("M" !== c[0] && "L" !== c[0]) ||
										("M" !== d[0] && "L" !== d[0]) ||
										("M" !== p[0] && "L" !== p[0]) ||
										("M" !== u[0] && "L" !== u[0]) ||
										(a && p[1] === c[1]
											? ((p[1] += l), (u[1] += l))
											: a || p[2] !== c[2] || ((p[2] += l), (u[2] += l)),
										n.push(
											["M", c[1], c[2]],
											["L", d[1], d[2]],
											["L", u[1], u[2]],
											["L", p[1], p[2]],
											["Z"]
										)),
										(n.isFlat = r);
								}
							else h = null;
							return n;
						}),
						(a.prototype.addPlotBand = function (t) {
							return this.addPlotBandOrLine(t, "plotBands");
						}),
						(a.prototype.addPlotLine = function (t) {
							return this.addPlotBandOrLine(t, "plotLines");
						}),
						(a.prototype.addPlotBandOrLine = function (t, e) {
							var i,
								o = this,
								r = this.userOptions,
								s = new n(this, t);
							return (
								(s = this.visible ? s.render() : s) &&
									(this._addedPlotLB ||
										((this._addedPlotLB = !0),
										(r.plotLines || [])
											.concat(r.plotBands || [])
											.forEach(function (t) {
												o.addPlotBandOrLine(t);
											})),
									e && ((i = r[e] || []).push(t), (r[e] = i)),
									this.plotLinesAndBands.push(s)),
								s
							);
						}),
						(a.prototype.removePlotBandOrLine = function (e) {
							var t = this.plotLinesAndBands,
								i = this.options,
								o = this.userOptions;
							if (t) {
								for (var r = t.length; r--; ) t[r].id === e && t[r].destroy();
								[
									i.plotLines || [],
									o.plotLines || [],
									i.plotBands || [],
									o.plotBands || [],
								].forEach(function (t) {
									for (r = t.length; r--; ) (t[r] || {}).id === e && s(t, t[r]);
								});
							}
						}),
						(a.prototype.removePlotBand = function (t) {
							this.removePlotBandOrLine(t);
						}),
						(a.prototype.removePlotLine = function (t) {
							this.removePlotBandOrLine(t);
						}),
						a);
				function a() {}
				return e;
			}
		),
		e(
			t,
			"Core/Axis/PlotLineOrBand/PlotLineOrBand.js",
			[
				t["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"],
				t["Core/Utilities.js"],
			],
			function (e, t) {
				var a = t.arrayMax,
					h = t.arrayMin,
					k = t.defined,
					i = t.destroyObjectProperties,
					o = t.erase,
					C = t.fireEvent,
					M = t.merge,
					w = t.objectEach,
					T = t.pick;
				function r(t, e) {
					(this.axis = t), e && ((this.options = e), (this.id = e.id));
				}
				return (
					(r.compose = function (t) {
						return e.compose(r, t);
					}),
					(r.prototype.render = function () {
						C(this, "render");
						var i = this,
							t = i.axis,
							e = t.horiz,
							o = t.logarithmic,
							r = i.options,
							s = r.color,
							n = T(r.zIndex, 0),
							a = r.events,
							h = {},
							l = t.chart.renderer,
							c = r.label,
							d = i.label,
							p = r.to,
							u = r.from,
							f = r.value,
							g = i.svgElem,
							m = [],
							y = k(u) && k(p),
							v = k(f),
							x = !g,
							b = {
								class:
									"highcharts-plot-" +
									(y ? "band " : "line ") +
									(r.className || ""),
							},
							S = y ? "bands" : "lines";
						if (
							(o &&
								((u = o.log2lin(u)), (p = o.log2lin(p)), (f = o.log2lin(f))),
							t.chart.styledMode ||
								(v
									? ((b.stroke = s || "#999999"),
									  (b["stroke-width"] = T(r.width, 1)),
									  r.dashStyle && (b.dashstyle = r.dashStyle))
									: y &&
									  ((b.fill = s || "#e6ebf5"),
									  r.borderWidth &&
											((b.stroke = r.borderColor),
											(b["stroke-width"] = r.borderWidth)))),
							(h.zIndex = n),
							(o = t.plotLinesAndBandsGroups[(S += "-" + n)]) ||
								(t.plotLinesAndBandsGroups[S] = o =
									l
										.g("plot-" + S)
										.attr(h)
										.add()),
							x && (i.svgElem = g = l.path().attr(b).add(o)),
							v)
						)
							m = t.getPlotLinePath({
								value: f,
								lineWidth: g.strokeWidth(),
								acrossPanes: r.acrossPanes,
							});
						else {
							if (!y) return;
							m = t.getPlotBandPath(u, p, r);
						}
						return (
							!i.eventsAdded &&
								a &&
								(w(a, function (t, e) {
									g.on(e, function (t) {
										a[e].apply(i, [t]);
									});
								}),
								(i.eventsAdded = !0)),
							(x || !g.d) && m && m.length
								? g.attr({ d: m })
								: g &&
								  (m
										? (g.show(), g.animate({ d: m }))
										: g.d && (g.hide(), d && (i.label = d = d.destroy()))),
							c &&
							(k(c.text) || k(c.formatter)) &&
							m &&
							m.length &&
							0 < t.width &&
							0 < t.height &&
							!m.isFlat
								? ((c = M(
										{
											align: e && y && "center",
											x: e ? !y && 4 : 10,
											verticalAlign: !e && y && "middle",
											y: e ? (y ? 16 : 10) : y ? 6 : -4,
											rotation: e && !y && 90,
										},
										c
								  )),
								  this.renderLabel(c, m, y, n))
								: d && d.hide(),
							i
						);
					}),
					(r.prototype.renderLabel = function (t, e, i, o) {
						var r = this.axis,
							s = r.chart.renderer,
							n = this.label,
							s =
								(n ||
									((this.label = n =
										s
											.text(this.getLabelText(t), 0, 0, t.useHTML)
											.attr({
												align: t.textAlign || t.align,
												rotation: t.rotation,
												class:
													"highcharts-plot-" +
													(i ? "band" : "line") +
													"-label " +
													(t.className || ""),
												zIndex: o,
											})
											.add()),
									r.chart.styledMode ||
										n.css(M({ textOverflow: "ellipsis" }, t.style))),
								e.xBounds || [e[0][1], e[1][1], (i ? e[2] : e[0])[1]]),
							o = e.yBounds || [e[0][2], e[1][2], (i ? e[2] : e[0])[2]],
							i = h(s),
							e = h(o);
						n.align(t, !1, { x: i, y: e, width: a(s) - i, height: a(o) - e }),
							(n.alignValue && "left" !== n.alignValue) ||
								((s = t.clip ? r.width : r.chart.chartWidth),
								n.css({
									width:
										(90 === n.rotation
											? r.height - (n.alignAttr.y - r.top)
											: s - (n.alignAttr.x - r.left)) + "px",
								})),
							n.show(!0);
					}),
					(r.prototype.getLabelText = function (t) {
						return k(t.formatter) ? t.formatter.call(this) : t.text;
					}),
					(r.prototype.destroy = function () {
						o(this.axis.plotLinesAndBands, this), delete this.axis, i(this);
					}),
					r
				);
			}
		),
		e(
			t,
			"Core/Tooltip.js",
			[
				t["Core/FormatUtilities.js"],
				t["Core/Globals.js"],
				t["Core/Renderer/RendererUtilities.js"],
				t["Core/Renderer/RendererRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, p, e, u, y) {
				var h = t.format,
					O = p.doc,
					E = e.distribute,
					D = (y.addEvent, y.clamp),
					f = y.css,
					i = (y.defined, y.discardElement),
					j = y.extend,
					v = y.fireEvent,
					x = y.isArray,
					l = y.isNumber,
					I = y.isString,
					o = y.merge,
					B = y.pick,
					b = y.splat,
					r = y.syncTimeout;
				function s(t, e) {
					(this.allowShared = !0),
						(this.container = void 0),
						(this.crosshairs = []),
						(this.distance = 0),
						(this.isHidden = !0),
						(this.isSticky = !1),
						(this.now = {}),
						(this.options = {}),
						(this.outside = !1),
						(this.chart = t),
						this.init(t, e);
				}
				return (
					(s.prototype.applyFilter = function () {
						var t = this.chart;
						t.renderer.definition({
							tagName: "filter",
							attributes: { id: "drop-shadow-" + t.index, opacity: 0.5 },
							children: [
								{
									tagName: "feGaussianBlur",
									attributes: { in: "SourceAlpha", stdDeviation: 1 },
								},
								{ tagName: "feOffset", attributes: { dx: 1, dy: 1 } },
								{
									tagName: "feComponentTransfer",
									children: [
										{
											tagName: "feFuncA",
											attributes: { type: "linear", slope: 0.3 },
										},
									],
								},
								{
									tagName: "feMerge",
									children: [
										{ tagName: "feMergeNode" },
										{
											tagName: "feMergeNode",
											attributes: { in: "SourceGraphic" },
										},
									],
								},
							],
						});
					}),
					(s.prototype.bodyFormatter = function (t) {
						return t.map(function (t) {
							var e = t.series.tooltipOptions;
							return (
								e[(t.point.formatPrefix || "point") + "Formatter"] ||
								t.point.tooltipFormatter
							).call(
								t.point,
								e[(t.point.formatPrefix || "point") + "Format"] || ""
							);
						});
					}),
					(s.prototype.cleanSplit = function (i) {
						this.chart.series.forEach(function (t) {
							var e = t && t.tt;
							e &&
								(!e.isActive || i ? (t.tt = e.destroy()) : (e.isActive = !1));
						});
					}),
					(s.prototype.defaultFormatter = function (t) {
						var e = this.points || b(this),
							i = [t.tooltipFooterHeaderFormatter(e[0])];
						return (
							(i = i.concat(t.bodyFormatter(e))).push(
								t.tooltipFooterHeaderFormatter(e[0], !0)
							),
							i
						);
					}),
					(s.prototype.destroy = function () {
						this.label && (this.label = this.label.destroy()),
							this.split &&
								this.tt &&
								(this.cleanSplit(!0), (this.tt = this.tt.destroy())),
							this.renderer &&
								((this.renderer = this.renderer.destroy()), i(this.container)),
							y.clearTimeout(this.hideTimer),
							y.clearTimeout(this.tooltipTimeout);
					}),
					(s.prototype.getAnchor = function (t, e) {
						var i,
							o,
							r = this.chart,
							s = r.pointer,
							n = r.inverted,
							a = r.plotTop,
							r = r.plotLeft;
						return (
							(t = b(t))[0].series &&
								t[0].series.yAxis &&
								!t[0].series.yAxis.options.reversedStacks &&
								(t = t.slice().reverse()),
							(this.followPointer && e
								? [
										(e = void 0 === e.chartX ? s.normalize(e) : e).chartX - r,
										e.chartY - a,
								  ]
								: t[0].tooltipPos ||
								  ((o = i = 0),
								  t.forEach(function (t) {
										t = t.pos(!0);
										t && ((i += t[0]), (o += t[1]));
								  }),
								  (i /= t.length),
								  (o /= t.length),
								  this.shared &&
										1 < t.length &&
										e &&
										(n ? (i = e.chartX) : (o = e.chartY)),
								  [i - r, o - a])
							).map(Math.round)
						);
					}),
					(s.prototype.getClassName = function (t, e, i) {
						var o = this.options,
							r = t.series,
							s = r.options;
						return [
							o.className,
							"highcharts-label",
							i && "highcharts-tooltip-header",
							e ? "highcharts-tooltip-box" : "highcharts-tooltip",
							!i && "highcharts-color-" + B(t.colorIndex, r.colorIndex),
							s && s.className,
						]
							.filter(I)
							.join(" ");
					}),
					(s.prototype.getLabel = function () {
						var e,
							t,
							i,
							o,
							r,
							s,
							n = this,
							a = this.chart.styledMode,
							h = this.options,
							l = this.split && this.allowShared,
							c =
								h.style.pointerEvents ||
								(this.shouldStickOnContact() ? "auto" : "none"),
							d = this.chart.renderer;
						return (
							n.label &&
								((t = !n.label.hasClass("highcharts-label")),
								((l && !t) || (!l && t)) && n.destroy()),
							this.label ||
								(this.outside &&
									((t = this.chart.options.chart.style),
									(i = u.getRendererType()),
									(this.container = e = p.doc.createElement("div")),
									(e.className = "highcharts-tooltip-container"),
									f(e, {
										position: "absolute",
										top: "1px",
										pointerEvents: c,
										zIndex: Math.max(
											this.options.style.zIndex || 0,
											((t && t.zIndex) || 0) + 3
										),
									}),
									p.doc.body.appendChild(e),
									(this.renderer = d =
										new i(e, 0, 0, t, void 0, void 0, d.styledMode))),
								l
									? (this.label = d.g("tooltip"))
									: ((this.label = d
											.label(
												"",
												0,
												0,
												h.shape,
												void 0,
												void 0,
												h.useHTML,
												void 0,
												"tooltip"
											)
											.attr({ padding: h.padding, r: h.borderRadius })),
									  a ||
											this.label
												.attr({
													fill: h.backgroundColor,
													"stroke-width": h.borderWidth,
												})
												.css(h.style)
												.css({ pointerEvents: c })
												.shadow(h.shadow)),
								a &&
									h.shadow &&
									(this.applyFilter(),
									this.label.attr({
										filter: "url(#drop-shadow-" + this.chart.index + ")",
									})),
								n.outside &&
									!n.split &&
									((o = this.label),
									(r = o.xSetter),
									(s = o.ySetter),
									(o.xSetter = function (t) {
										r.call(o, n.distance), (e.style.left = t + "px");
									}),
									(o.ySetter = function (t) {
										s.call(o, n.distance), (e.style.top = t + "px");
									})),
								this.label.attr({ zIndex: 8 }).add()),
							this.label
						);
					}),
					(s.prototype.getPosition = function (i, o, r) {
						function t(t) {
							var e = "x" === t;
							return [t, e ? a : h, e ? i : o].concat(
								g
									? [
											e ? m(i) : y(o),
											e
												? l.left - p + m(r.plotX + n.plotLeft)
												: l.top - p + y(r.plotY + n.plotTop),
											0,
											e ? a : h,
									  ]
									: [
											e ? i : o,
											e ? r.plotX + n.plotLeft : r.plotY + n.plotTop,
											e ? n.plotLeft : n.plotTop,
											e ? n.plotLeft + n.plotWidth : n.plotTop + n.plotHeight,
									  ]
							);
						}
						var s,
							n = this.chart,
							p = this.distance,
							u = {},
							f = (n.inverted && r.h) || 0,
							g = this.outside,
							a = g ? O.documentElement.clientWidth - 2 * p : n.chartWidth,
							h = g
								? Math.max(
										O.body.scrollHeight,
										O.documentElement.scrollHeight,
										O.body.offsetHeight,
										O.documentElement.offsetHeight,
										O.documentElement.clientHeight
								  )
								: n.chartHeight,
							l = n.pointer.getChartPosition(),
							m = function (t) {
								return t * l.scaleX;
							},
							y = function (t) {
								return t * l.scaleY;
							},
							c = t("y"),
							d = t("x"),
							e = !!r.negative,
							v =
								(!n.polar &&
									n.hoverSeries &&
									n.hoverSeries.yAxis &&
									n.hoverSeries.yAxis.reversed &&
									(e = !e),
								!this.followPointer && B(r.ttBelow, !n.inverted === e)),
							x = function (t, e, i, o, r, s, n) {
								var a = g ? ("y" === t ? y : m)(p) : p,
									h = (i - o) / 2,
									l = o < r - p,
									c = r + p + o < e,
									d = r - a - i + h,
									r = r + a - h;
								if (v && c) u[t] = r;
								else if (!v && l) u[t] = d;
								else if (l) u[t] = Math.min(n - o, d - f < 0 ? d : d - f);
								else {
									if (!c) return !1;
									u[t] = Math.max(s, e < r + f + i ? r : r + f);
								}
							},
							b = function (t, e, i, o, r) {
								var s;
								return (
									r < p || e - p < r
										? (s = !1)
										: (u[t] =
												r < i / 2 ? 1 : e - o / 2 < r ? e - o - 2 : r - i / 2),
									s
								);
							},
							S = function (t) {
								var e = c;
								(c = d), (d = e), (s = t);
							},
							k = function () {
								!1 !== x.apply(0, c)
									? !1 !== b.apply(0, d) || s || (S(!0), k())
									: s
									? (u.x = u.y = 0)
									: (S(!0), k());
							};
						return (n.inverted || 1 < this.len) && S(), k(), u;
					}),
					(s.prototype.hide = function (t) {
						var e = this;
						y.clearTimeout(this.hideTimer),
							(t = B(t, this.options.hideDelay)),
							this.isHidden ||
								(this.hideTimer = r(function () {
									e.getLabel().fadeOut(t && void 0), (e.isHidden = !0);
								}, t));
					}),
					(s.prototype.init = function (t, e) {
						(this.chart = t),
							(this.options = e),
							(this.crosshairs = []),
							(this.now = { x: 0, y: 0 }),
							(this.isHidden = !0),
							(this.split = e.split && !t.inverted && !t.polar),
							(this.shared = e.shared || this.split),
							(this.outside = B(
								e.outside,
								Boolean(t.scrollablePixelsX || t.scrollablePixelsY)
							));
					}),
					(s.prototype.shouldStickOnContact = function (t) {
						return !(
							this.followPointer ||
							!this.options.stickOnContact ||
							(t && !this.chart.pointer.inClass(t.target, "highcharts-tooltip"))
						);
					}),
					(s.prototype.move = function (t, e, i, o) {
						var r = this,
							s = r.now,
							n =
								!1 !== r.options.animation &&
								!r.isHidden &&
								(1 < Math.abs(t - s.x) || 1 < Math.abs(e - s.y)),
							a = r.followPointer || 1 < r.len;
						j(s, {
							x: n ? (2 * s.x + t) / 3 : t,
							y: n ? (s.y + e) / 2 : e,
							anchorX: a ? void 0 : n ? (2 * s.anchorX + i) / 3 : i,
							anchorY: a ? void 0 : n ? (s.anchorY + o) / 2 : o,
						}),
							r.getLabel().attr(s),
							r.drawTracker(),
							n &&
								(y.clearTimeout(this.tooltipTimeout),
								(this.tooltipTimeout = setTimeout(function () {
									r && r.move(t, e, i, o);
								}, 32)));
					}),
					(s.prototype.refresh = function (t, e) {
						var i = this,
							o = this.chart,
							r = i.options,
							s = o.pointer,
							n = b(t),
							a = n[0],
							h = [],
							l = r.formatter || i.defaultFormatter,
							c = i.shared,
							d = o.styledMode,
							p = {};
						if (r.enabled && a.series) {
							y.clearTimeout(this.hideTimer),
								(i.allowShared = !(
									!x(t) &&
									t.series &&
									t.series.noSharedTooltip
								)),
								(i.followPointer =
									!i.split && a.series.tooltipOptions.followPointer);
							var t = i.getAnchor(t, e),
								u = t[0],
								f = t[1],
								c =
									(c && i.allowShared
										? (s.applyInactiveState(n),
										  n.forEach(function (t) {
												t.setState("hover"), h.push(t.getLabelConfig());
										  }),
										  ((p = { x: a.category, y: a.y }).points = h))
										: (p = a.getLabelConfig()),
									(this.len = h.length),
									l.call(p, i)),
								l = a.series;
							if (
								((this.distance = B(l.tooltipOptions.distance, 16)), !1 === c)
							)
								this.hide();
							else {
								if (i.split && i.allowShared) this.renderSplit(c, n);
								else {
									var g = u,
										m = f;
									if (
										(e &&
											s.isDirectTouch &&
											((g = e.chartX - o.plotLeft), (m = e.chartY - o.plotTop)),
										!o.polar &&
											!1 !== l.options.clip &&
											!n.some(function (t) {
												return (
													s.isDirectTouch || t.series.shouldShowTooltip(g, m)
												);
											}))
									)
										return void i.hide();
									p = i.getLabel();
									(r.style.width && !d) ||
										p.css({ width: o.spacingBox.width + "px" }),
										p.attr({ text: c && c.join ? c.join("") : c }),
										p.addClass(i.getClassName(a), !0),
										d ||
											p.attr({
												stroke:
													r.borderColor || a.color || l.color || "#666666",
											}),
										i.updatePosition({
											plotX: u,
											plotY: f,
											negative: a.negative,
											ttBelow: a.ttBelow,
											h: t[2] || 0,
										});
								}
								i.isHidden && i.label && i.label.attr({ opacity: 1 }).show(),
									(i.isHidden = !1);
							}
							v(this, "refresh");
						}
					}),
					(s.prototype.renderSplit = function (t, u) {
						var f,
							g = this,
							e = g.chart,
							i = g.chart,
							o = i.chartWidth,
							r = i.chartHeight,
							m = i.plotHeight,
							y = i.plotLeft,
							v = i.plotTop,
							s = i.pointer,
							n = i.scrollablePixelsY,
							n = void 0 === n ? 0 : n,
							a = i.scrollablePixelsX,
							h = i.scrollingContainer,
							h = void 0 === h ? { scrollLeft: 0, scrollTop: 0 } : h,
							l = h.scrollLeft,
							h = h.scrollTop,
							x = i.styledMode,
							b = g.distance,
							S = g.options,
							k = g.options.positioner,
							C =
								g.outside && "number" != typeof a
									? O.documentElement.getBoundingClientRect()
									: { left: l, right: l + o, top: h, bottom: h + r },
							M = g.getLabel(),
							w = this.renderer || e.renderer,
							T = Boolean(e.xAxis[0] && e.xAxis[0].opposite),
							i = s.getChartPosition(),
							c = i.left,
							a = i.top,
							A = v + h,
							P = m - n;
						function L(t, e, i, o, r) {
							var s, n;
							return (
								void 0 === r && (r = !0),
								{
									x: (n = i
										? ((s = T ? 0 : P),
										  D(t - o / 2, C.left, C.right - o - (g.outside ? c : 0)))
										: ((s = e - A),
										  D((n = r ? t - o - b : t + b), r ? n : C.left, C.right))),
									y: s,
								}
							);
						}
						var l = (t = I(t) ? [!1, t] : t)
								.slice(0, u.length + 1)
								.reduce(function (t, e, i) {
									var o, r, s, n, a, h, l, c, d, p;
									return (
										!1 !== e &&
											"" !== e &&
											((e =
												(c = (d = (h = (o = (i = u[i - 1] || {
													isHeader: !0,
													plotX: u[0].plotX,
													plotY: m,
													series: {},
												}).isHeader)
													? g
													: i.series).tt =
													((h = h.tt),
													(l = i),
													(e = e.toString()),
													(d = l.isHeader),
													(p = l.series),
													h ||
														((c = { padding: S.padding, r: S.borderRadius }),
														x ||
															((c.fill = S.backgroundColor),
															(c["stroke-width"] = S.borderWidth)),
														(h = w
															.label(
																"",
																0,
																0,
																S[d ? "headerShape" : "shape"],
																void 0,
																void 0,
																S.useHTML
															)
															.addClass(g.getClassName(l, !0, d))
															.attr(c)
															.add(M))),
													(h.isActive = !0),
													h.attr({ text: e }),
													x ||
														h
															.css(S.style)
															.shadow(S.shadow)
															.attr({
																stroke:
																	S.borderColor ||
																	l.color ||
																	p.color ||
																	"#333333",
															}),
													h)).getBBox()).width + d.strokeWidth()),
											o && ((f = c.height), (P += f), T && (A -= f)),
											(p = (l = i).isHeader),
											(h = void 0 === (h = l.plotX) ? 0 : h),
											(a = void 0 === (a = l.plotY) ? 0 : a),
											(l = l.series),
											p
												? ((n = y + h), (r = v + m / 2))
												: ((p = l.xAxis),
												  (s = l.yAxis),
												  (n = p.pos + D(h, -b, p.len + b)),
												  l.shouldShowTooltip(0, s.pos - v + a, {
														ignoreX: !0,
												  }) && (r = s.pos + a)),
											(p = (h = {
												anchorX: (n = D(n, C.left - b, C.right + b)),
												anchorY: r,
											}).anchorX),
											"number" == typeof (l = h.anchorY)
												? ((s = c.height + 1),
												  (a = k ? k.call(g, e, s, i) : L(p, l, o, e)),
												  t.push({
														align: k ? 0 : void 0,
														anchorX: p,
														anchorY: l,
														boxWidth: e,
														point: i,
														rank: B(a.rank, o ? 1 : 0),
														size: s,
														target: a.y,
														tt: d,
														x: a.x,
												  }))
												: (d.isActive = !1)),
										t
									);
								}, []),
							d =
								(!k &&
									l.some(function (t) {
										var e = (g.outside ? c : 0) + t.anchorX;
										return (
											(e < C.left && e + t.boxWidth < C.right) ||
											(e < c - C.left + t.boxWidth && C.right - e > e)
										);
									}) &&
									(l = l.map(function (t) {
										var e = L(
												t.anchorX,
												t.anchorY,
												t.point.isHeader,
												t.boxWidth,
												!1
											),
											i = e.x,
											e = e.y;
										return j(t, { target: e, x: i });
									})),
								g.cleanSplit(),
								E(l, P),
								{ left: c, right: c }),
							o =
								(l.forEach(function (t) {
									var e = t.x,
										i = t.boxWidth,
										t = t.isHeader;
									t ||
										(g.outside && c + e < d.left && (d.left = c + e),
										!t &&
											g.outside &&
											d.left + i > d.right &&
											(d.right = c + e));
								}),
								l.forEach(function (t) {
									var e = t.x,
										i = t.anchorX,
										o = t.anchorY,
										r = t.pos,
										s = t.point.isHeader,
										r = {
											visibility: void 0 === r ? "hidden" : "inherit",
											x: e,
											y: (r || 0) + A,
											anchorX: i,
											anchorY: o,
										};
									g.outside &&
										e < i &&
										0 < (o = c - d.left) &&
										(s || ((r.x = e + o), (r.anchorX = i + o)),
										s && ((r.x = (d.right - d.left) / 2), (r.anchorX = i + o))),
										t.tt.attr(r);
								}),
								g.container),
							r = g.outside,
							e = g.renderer;
						r &&
							o &&
							e &&
							((i = (s = M.getBBox()).width),
							(h = s.height),
							(n = s.x),
							(t = s.y),
							e.setSize(i + n, h + t, !1),
							(o.style.left = d.left + "px"),
							(o.style.top = a + "px"));
					}),
					(s.prototype.drawTracker = function () {
						var t,
							e,
							i,
							o,
							r,
							s = this;
						this.shouldStickOnContact()
							? ((t = s.chart),
							  (e = s.label),
							  (o = s.shared ? t.hoverPoints : t.hoverPoint),
							  e &&
									o &&
									((i = { x: 0, y: 0, width: 0, height: 0 }),
									(o = this.getAnchor(o)),
									(r = e.getBBox()),
									(o[0] += t.plotLeft - e.translateX),
									(o[1] += t.plotTop - e.translateY),
									(i.x = Math.min(0, o[0])),
									(i.y = Math.min(0, o[1])),
									(i.width =
										o[0] < 0
											? Math.max(Math.abs(o[0]), r.width - o[0])
											: Math.max(Math.abs(o[0]), r.width)),
									(i.height =
										o[1] < 0
											? Math.max(Math.abs(o[1]), r.height - Math.abs(o[1]))
											: Math.max(Math.abs(o[1]), r.height)),
									s.tracker
										? s.tracker.attr(i)
										: ((s.tracker = e.renderer
												.rect(i)
												.addClass("highcharts-tracker")
												.add(e)),
										  t.styledMode ||
												s.tracker.attr({ fill: "rgba(0,0,0,0)" }))))
							: s.tracker && s.tracker.destroy();
					}),
					(s.prototype.styledModeFormat = function (t) {
						return t
							.replace('style="font-size: 10px"', 'class="highcharts-header"')
							.replace(
								/style="color:{(point|series)\.color}"/g,
								'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"'
							);
					}),
					(s.prototype.tooltipFooterHeaderFormatter = function (e, t) {
						var i = e.series,
							o = i.tooltipOptions,
							r = i.xAxis,
							s = r && r.dateTime,
							r = { isFooter: t, labelConfig: e },
							n = o.xDateFormat,
							a = o[t ? "footerFormat" : "headerFormat"];
						return (
							v(this, "headerFormatter", r, function (t) {
								s &&
									!n &&
									l(e.key) &&
									(n = s.getXDateFormat(e.key, o.dateTimeLabelFormats)),
									s &&
										n &&
										((e.point && e.point.tooltipDateKeys) || ["key"]).forEach(
											function (t) {
												a = a.replace(
													"{point." + t + "}",
													"{point." + t + ":" + n + "}"
												);
											}
										),
									i.chart.styledMode && (a = this.styledModeFormat(a)),
									(t.text = h(a, { point: e, series: i }, this.chart));
							}),
							r.text
						);
					}),
					(s.prototype.update = function (t) {
						this.destroy(),
							o(!0, this.chart.options.tooltip.userOptions, t),
							this.init(this.chart, o(!0, this.options, t));
					}),
					(s.prototype.updatePosition = function (t) {
						var e = this.chart,
							i = this.distance,
							o = this.options,
							r = e.pointer,
							s = this.getLabel(),
							r = r.getChartPosition(),
							n = r.left,
							a = r.top,
							h = r.scaleX,
							r = r.scaleY,
							l = (o.positioner || this.getPosition).call(
								this,
								s.width,
								s.height,
								t
							),
							c = (t.plotX || 0) + e.plotLeft,
							t = (t.plotY || 0) + e.plotTop;
						this.outside &&
							(o.positioner && ((l.x += n - i), (l.y += a - i)),
							(e = o.borderWidth + 2 * i),
							this.renderer.setSize(s.width + e, s.height + e, !1),
							(1 === h && 1 === r) ||
								(f(this.container, {
									transform: "scale(".concat(h, ", ").concat(r, ")"),
								}),
								(c *= h),
								(t *= r)),
							(c += n - l.x),
							(t += a - l.y)),
							this.move(Math.round(l.x), Math.round(l.y || 0), c, t);
					}),
					s
				);
			}
		),
		e(
			t,
			"Core/Series/Point.js",
			[
				t["Core/Renderer/HTML/AST.js"],
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Defaults.js"],
				t["Core/FormatUtilities.js"],
				t["Core/Utilities.js"],
			],
			function (v, t, e, i, o) {
				var a = t.animObject,
					x = e.defaultOptions,
					n = i.format,
					r = o.addEvent,
					s = o.defined,
					h = o.erase,
					b = o.extend,
					S = o.fireEvent,
					l = o.getNestedProperty,
					c = o.isArray,
					d = o.isFunction,
					k = o.isNumber,
					p = o.isObject,
					u = o.merge,
					f = o.objectEach,
					C = o.pick,
					g = o.syncTimeout,
					m = o.removeEvent,
					y = o.uniqueKey;
				function M() {
					(this.category = void 0),
						(this.formatPrefix = "point"),
						(this.id = void 0),
						(this.isNull = !1),
						(this.name = void 0),
						(this.options = void 0),
						(this.percentage = void 0),
						(this.selected = !1),
						(this.series = void 0),
						(this.shapeArgs = void 0),
						(this.total = void 0),
						(this.visible = !0),
						(this.x = void 0);
				}
				return (
					(M.prototype.animateBeforeDestroy = function () {
						var e = this,
							i = { x: e.startXPos, opacity: 0 },
							t = e.getGraphicalProps();
						t.singular.forEach(function (t) {
							e[t] = e[t].animate(
								"dataLabel" === t
									? { x: e[t].startXPos, y: e[t].startYPos, opacity: 0 }
									: i
							);
						}),
							t.plural.forEach(function (t) {
								e[t].forEach(function (t) {
									t.element &&
										t.animate(
											b(
												{ x: e.startXPos },
												t.startYPos ? { x: t.startXPos, y: t.startYPos } : {}
											)
										);
								});
							});
					}),
					(M.prototype.applyOptions = function (t, e) {
						var i = this,
							o = i.series,
							r = o.options.pointValKey || o.pointValKey;
						return (
							(t = M.prototype.optionsToObject.call(this, t)),
							b(i, t),
							(i.options = i.options ? b(i.options, t) : t),
							t.group && delete i.group,
							t.dataLabels && delete i.dataLabels,
							r && (i.y = M.prototype.getNestedProperty.call(i, r)),
							(i.isNull = this.isValid && !this.isValid()),
							(i.formatPrefix = i.isNull ? "null" : "point"),
							i.selected && (i.state = "select"),
							"name" in i &&
								void 0 === e &&
								o.xAxis &&
								o.xAxis.hasNames &&
								(i.x = o.xAxis.nameToX(i)),
							void 0 === i.x && o
								? (i.x = void 0 === e ? o.autoIncrement() : e)
								: k(t.x) &&
								  o.options.relativeXValue &&
								  (i.x = o.autoIncrement(t.x)),
							i
						);
					}),
					(M.prototype.destroy = function () {
						var t,
							e = this,
							i = e.series,
							o = i.chart,
							i = i.options.dataSorting,
							r = o.hoverPoints,
							s = e.series.chart.renderer.globalAnimation,
							s = a(s);
						function n() {
							for (t in ((e.graphic ||
								e.graphics ||
								e.dataLabel ||
								e.dataLabels) &&
								(m(e), e.destroyElements()),
							e))
								e[t] = null;
						}
						e.legendItem && o.legend.destroyItem(e),
							r && (e.setState(), h(r, e), r.length || (o.hoverPoints = null)),
							e === o.hoverPoint && e.onMouseOut(),
							i && i.enabled
								? (this.animateBeforeDestroy(), g(n, s.duration))
								: n(),
							o.pointCount--;
					}),
					(M.prototype.destroyElements = function (t) {
						var e = this,
							t = e.getGraphicalProps(t);
						t.singular.forEach(function (t) {
							e[t] = e[t].destroy();
						}),
							t.plural.forEach(function (t) {
								e[t].forEach(function (t) {
									t && t.element && t.destroy();
								}),
									delete e[t];
							});
					}),
					(M.prototype.firePointEvent = function (t, e, i) {
						var o = this,
							r = this.series.options;
						(r.point.events[t] ||
							(o.options && o.options.events && o.options.events[t])) &&
							o.importEvents(),
							"click" === t &&
								r.allowPointSelect &&
								(i = function (t) {
									o.select &&
										o.select(null, t.ctrlKey || t.metaKey || t.shiftKey);
								}),
							S(o, t, e, i);
					}),
					(M.prototype.getClassName = function () {
						var t = this;
						return (
							"highcharts-point" +
							(t.selected ? " highcharts-point-select" : "") +
							(t.negative ? " highcharts-negative" : "") +
							(t.isNull ? " highcharts-null-point" : "") +
							(void 0 !== t.colorIndex
								? " highcharts-color-" + t.colorIndex
								: "") +
							(t.options.className ? " " + t.options.className : "") +
							(t.zone && t.zone.className
								? " " + t.zone.className.replace("highcharts-negative", "")
								: "")
						);
					}),
					(M.prototype.getGraphicalProps = function (i) {
						var t,
							e,
							o = this,
							r = [],
							s = { singular: [], plural: [] };
						for (
							(i = i || { graphic: 1, dataLabel: 1 }).graphic &&
								r.push("graphic", "shadowGroup"),
								i.dataLabel &&
									r.push(
										"dataLabel",
										"dataLabelPath",
										"dataLabelUpper",
										"connector"
									),
								e = r.length;
							e--;

						)
							(t = r[e]), o[t] && s.singular.push(t);
						return (
							["graphic", "dataLabel", "connector"].forEach(function (t) {
								var e = t + "s";
								i[t] && o[e] && s.plural.push(e);
							}),
							s
						);
					}),
					(M.prototype.getLabelConfig = function () {
						return {
							x: this.category,
							y: this.y,
							color: this.color,
							colorIndex: this.colorIndex,
							key: this.name || this.category,
							series: this.series,
							point: this,
							percentage: this.percentage,
							total: this.total || this.stackTotal,
						};
					}),
					(M.prototype.getNestedProperty = function (t) {
						if (t)
							return 0 === t.indexOf("custom.") ? l(t, this.options) : this[t];
					}),
					(M.prototype.getZone = function () {
						for (
							var t = this.series,
								e = t.zones,
								i = t.zoneAxis || "y",
								o = 0,
								r = e[o];
							this[i] >= r.value;

						)
							r = e[++o];
						return (
							this.nonZonedColor || (this.nonZonedColor = this.color),
							r && r.color && !this.options.color
								? (this.color = r.color)
								: (this.color = this.nonZonedColor),
							r
						);
					}),
					(M.prototype.hasNewShapeType = function () {
						return (
							(this.graphic &&
								(this.graphic.symbolName || this.graphic.element.nodeName)) !==
							this.shapeType
						);
					}),
					(M.prototype.init = function (t, e, i) {
						return (
							(this.series = t),
							this.applyOptions(e, i),
							(this.id = s(this.id) ? this.id : y()),
							this.resolveColor(),
							t.chart.pointCount++,
							S(this, "afterInit"),
							this
						);
					}),
					(M.prototype.isValid = function () {
						return null !== this.x && k(this.y);
					}),
					(M.prototype.optionsToObject = function (t) {
						var e,
							i = this.series,
							o = i.options.keys,
							r = o || i.pointArrayMap || ["y"],
							s = r.length,
							n = {},
							a = 0,
							h = 0;
						if (k(t) || null === t) n[r[0]] = t;
						else if (c(t))
							for (
								!o &&
								t.length > s &&
								("string" == (e = typeof t[0])
									? (n.name = t[0])
									: "number" == e && (n.x = t[0]),
								a++);
								h < s;

							)
								(o && void 0 === t[a]) ||
									(0 < r[h].indexOf(".")
										? M.prototype.setNestedProperty(n, t[a], r[h])
										: (n[r[h]] = t[a])),
									a++,
									h++;
						else
							"object" == typeof t &&
								((n = t).dataLabels && (i._hasPointLabels = !0),
								t.marker && (i._hasPointMarkers = !0));
						return n;
					}),
					(M.prototype.pos = function (t, e) {
						void 0 === e && (e = this.plotY);
						var i = this.plotX,
							o = this.series,
							r = o.chart,
							s = o.xAxis,
							o = o.yAxis,
							n = 0,
							a = 0;
						if (k(i) && k(e))
							return (
								t &&
									((n = s ? s.pos : r.plotLeft), (a = o ? o.pos : r.plotTop)),
								r.inverted && s && o
									? [o.len - e + a, s.len - i + n]
									: [i + n, e + a]
							);
					}),
					(M.prototype.resolveColor = function () {
						var t,
							e,
							i = this.series,
							o = i.chart.options.chart,
							r = i.chart.styledMode,
							o = o.colorCount;
						delete this.nonZonedColor,
							i.options.colorByPoint
								? (r ||
										((t = (e = i.options.colors || i.chart.options.colors)[
											i.colorCounter
										]),
										(o = e.length)),
								  (e = i.colorCounter),
								  i.colorCounter++,
								  i.colorCounter === o && (i.colorCounter = 0))
								: (r || (t = i.color), (e = i.colorIndex)),
							(this.colorIndex = C(this.options.colorIndex, e)),
							(this.color = C(this.options.color, t));
					}),
					(M.prototype.setNestedProperty = function (t, r, e) {
						return (
							e.split(".").reduce(function (t, e, i, o) {
								o = o.length - 1 === i;
								return (t[e] = o ? r : p(t[e], !0) ? t[e] : {}), t[e];
							}, t),
							t
						);
					}),
					(M.prototype.shouldDraw = function () {
						return !this.isNull;
					}),
					(M.prototype.tooltipFormatter = function (e) {
						var t = this.series,
							i = t.tooltipOptions,
							o = C(i.valueDecimals, ""),
							r = i.valuePrefix || "",
							s = i.valueSuffix || "";
						return (
							t.chart.styledMode && (e = t.chart.tooltip.styledModeFormat(e)),
							(t.pointArrayMap || ["y"]).forEach(function (t) {
								(t = "{point." + t),
									(e = (e =
										r || s
											? e.replace(RegExp(t + "}", "g"), r + t + "}" + s)
											: e).replace(RegExp(t + "}", "g"), t + ":,." + o + "f}"));
							}),
							n(e, { point: this, series: this.series }, t.chart)
						);
					}),
					(M.prototype.update = function (e, i, o, t) {
						var r,
							s = this,
							n = s.series,
							a = s.graphic,
							h = n.chart,
							l = n.options;
						function c() {
							s.applyOptions(e);
							var t = a && s.hasMockGraphic,
								t = null === s.y ? !t : t;
							a && t && ((s.graphic = a.destroy()), delete s.hasMockGraphic),
								p(e, !0) &&
									(a &&
										a.element &&
										e &&
										e.marker &&
										void 0 !== e.marker.symbol &&
										(s.graphic = a.destroy()),
									e &&
										e.dataLabels &&
										s.dataLabel &&
										(s.dataLabel = s.dataLabel.destroy()),
									s.connector && (s.connector = s.connector.destroy())),
								(r = s.index),
								n.updateParallelArrays(s, r),
								(l.data[r] =
									p(l.data[r], !0) || p(e, !0) ? s.options : C(e, l.data[r])),
								(n.isDirty = n.isDirtyData = !0),
								!n.fixedBox && n.hasCartesianSeries && (h.isDirtyBox = !0),
								"point" === l.legendType && (h.isDirtyLegend = !0),
								i && h.redraw(o);
						}
						(i = C(i, !0)),
							!1 === t ? c() : s.firePointEvent("update", { options: e }, c);
					}),
					(M.prototype.remove = function (t, e) {
						this.series.removePoint(this.series.data.indexOf(this), t, e);
					}),
					(M.prototype.select = function (t, e) {
						var i = this,
							o = i.series,
							r = o.chart;
						(t = C(t, !i.selected)),
							(this.selectedStaging = t),
							i.firePointEvent(
								t ? "select" : "unselect",
								{ accumulate: e },
								function () {
									(i.selected = i.options.selected = t),
										(o.options.data[o.data.indexOf(i)] = i.options),
										i.setState(t && "select"),
										e ||
											r.getSelectedPoints().forEach(function (t) {
												var e = t.series;
												t.selected &&
													t !== i &&
													((t.selected = t.options.selected = !1),
													(e.options.data[e.data.indexOf(t)] = t.options),
													t.setState(
														r.hoverPoints && e.options.inactiveOtherPoints
															? "inactive"
															: ""
													),
													t.firePointEvent("unselect"));
											});
								}
							),
							delete this.selectedStaging;
					}),
					(M.prototype.onMouseOver = function (t) {
						var e = this.series.chart,
							i = e.pointer;
						(t = t
							? i.normalize(t)
							: i.getChartCoordinatesFromPoint(this, e.inverted)),
							i.runPointActions(t, this);
					}),
					(M.prototype.onMouseOut = function () {
						var t = this.series.chart;
						this.firePointEvent("mouseOut"),
							this.series.options.inactiveOtherPoints ||
								(t.hoverPoints || []).forEach(function (t) {
									t.setState();
								}),
							(t.hoverPoints = t.hoverPoint = null);
					}),
					(M.prototype.importEvents = function () {
						var i, t;
						this.hasImportedEvents ||
							((t = u((i = this).series.options.point, i.options).events),
							(i.events = t),
							f(t, function (t, e) {
								d(t) && r(i, e, t);
							}),
							(this.hasImportedEvents = !0));
					}),
					(M.prototype.setState = function (t, e) {
						var i,
							o,
							r,
							s = this,
							n = s.series,
							a = s.state,
							h = n.options.states[t || "normal"] || {},
							l = x.plotOptions[n.type].marker && n.options.marker,
							c = l && !1 === l.enabled,
							d = (l && l.states && l.states[t || "normal"]) || {},
							p = !1 === d.enabled,
							u = s.marker || {},
							f = n.chart,
							g = l && n.markerAttribs,
							m = n.halo,
							y = n.stateMarkerGraphic;
						((t = t || "") === s.state && !e) ||
							(s.selected && "select" !== t) ||
							!1 === h.enabled ||
							(t && (p || (c && !1 === d.enabled))) ||
							(t && u.states && u.states[t] && !1 === u.states[t].enabled) ||
							((s.state = t),
							g && (i = n.markerAttribs(s, t)),
							s.graphic && !s.hasMockGraphic
								? (a && s.graphic.removeClass("highcharts-point-" + a),
								  t && s.graphic.addClass("highcharts-point-" + t),
								  f.styledMode ||
										((p = n.pointAttribs(s, t)),
										(o = C(f.options.chart.animation, h.animation)),
										(r = p.opacity),
										n.options.inactiveOtherPoints &&
											k(r) &&
											((s.dataLabels || []).forEach(function (t) {
												t &&
													!t.hasClass("highcharts-data-label-hidden") &&
													t.animate({ opacity: r }, o);
											}),
											s.connector && s.connector.animate({ opacity: r }, o)),
										s.graphic.animate(p, o)),
								  i &&
										s.graphic.animate(
											i,
											C(f.options.chart.animation, d.animation, l.animation)
										),
								  y && y.hide())
								: (t &&
										d &&
										((c = u.symbol || n.symbol),
										y && y.currentSymbol !== c && (y = y.destroy()),
										i &&
											(y
												? y[e ? "animate" : "attr"]({ x: i.x, y: i.y })
												: c &&
												  ((n.stateMarkerGraphic = y =
														f.renderer
															.symbol(c, i.x, i.y, i.width, i.height)
															.add(n.markerGroup)),
												  (y.currentSymbol = c))),
										!f.styledMode &&
											y &&
											"inactive" !== s.state &&
											y.attr(n.pointAttribs(s, t))),
								  y &&
										(y[t && s.isInside ? "show" : "hide"](),
										(y.element.point = s),
										y.addClass(s.getClassName(), !0))),
							(g = h.halo),
							(p = ((a = s.graphic || y) && a.visibility) || "inherit"),
							g && g.size && a && "hidden" !== p && !s.isCluster
								? (m || (n.halo = m = f.renderer.path().add(a.parentGroup)),
								  m.show()[e ? "animate" : "attr"]({ d: s.haloPath(g.size) }),
								  m.attr({
										class:
											"highcharts-halo highcharts-color-" +
											C(s.colorIndex, n.colorIndex) +
											(s.className ? " " + s.className : ""),
										visibility: p,
										zIndex: -1,
								  }),
								  (m.point = s),
								  f.styledMode ||
										m.attr(
											b(
												{ fill: s.color || n.color, "fill-opacity": g.opacity },
												v.filterUserAttributes(g.attributes || {})
											)
										))
								: m &&
								  m.point &&
								  m.point.haloPath &&
								  m.animate({ d: m.point.haloPath(0) }, null, m.hide),
							S(s, "afterSetState", { state: t }));
					}),
					(M.prototype.haloPath = function (t) {
						var e = this.pos();
						return e
							? this.series.chart.renderer.symbols.circle(
									Math.floor(e[0]) - t,
									e[1] - t,
									2 * t,
									2 * t
							  )
							: [];
					}),
					M
				);
			}
		),
		e(
			t,
			"Core/Pointer.js",
			[
				t["Core/Color/Color.js"],
				t["Core/Globals.js"],
				t["Core/Tooltip.js"],
				t["Core/Utilities.js"],
			],
			function (t, r, i, e) {
				var f = t.parse,
					p = r.charts,
					u = r.noop,
					g = e.addEvent,
					s = e.attr,
					o = e.css,
					m = e.defined,
					y = e.extend,
					v = e.find,
					x = e.fireEvent,
					b = e.isNumber,
					S = e.isObject,
					n = e.objectEach,
					a = e.offset,
					k = e.pick,
					l = e.splat;
				function C(t, e) {
					(this.lastValidTouch = {}),
						(this.pinchDown = []),
						(this.runChartClick = !1),
						(this.eventsToUnbind = []),
						(this.chart = t),
						(this.hasDragged = !1),
						(this.options = e),
						this.init(t, e);
				}
				return (
					(C.prototype.applyInactiveState = function (t) {
						var e,
							i = [];
						(t || []).forEach(function (t) {
							(e = t.series),
								i.push(e),
								e.linkedParent && i.push(e.linkedParent),
								e.linkedSeries && (i = i.concat(e.linkedSeries)),
								e.navigatorSeries && i.push(e.navigatorSeries);
						}),
							this.chart.series.forEach(function (t) {
								-1 === i.indexOf(t)
									? t.setState("inactive", !0)
									: t.options.inactiveOtherPoints &&
									  t.setAllPointsToState("inactive");
							});
					}),
					(C.prototype.destroy = function () {
						var i = this;
						this.eventsToUnbind.forEach(function (t) {
							return t();
						}),
							(this.eventsToUnbind = []),
							r.chartCount ||
								(C.unbindDocumentMouseUp &&
									(C.unbindDocumentMouseUp = C.unbindDocumentMouseUp()),
								C.unbindDocumentTouchEnd &&
									(C.unbindDocumentTouchEnd = C.unbindDocumentTouchEnd())),
							clearInterval(i.tooltipTimeout),
							n(i, function (t, e) {
								i[e] = void 0;
							});
					}),
					(C.prototype.getSelectionMarkerAttrs = function (a, h) {
						var l = this,
							t = {
								args: { chartX: a, chartY: h },
								attrs: {},
								shapeType: "rect",
							};
						return (
							x(this, "getSelectionMarkerAttrs", t, function (t) {
								var e,
									i = l.chart,
									o = l.mouseDownX,
									o = void 0 === o ? 0 : o,
									r = l.mouseDownY,
									r = void 0 === r ? 0 : r,
									s = l.zoomHor,
									n = l.zoomVert,
									t = t.attrs;
								(t.x = i.plotLeft),
									(t.y = i.plotTop),
									(t.width = s ? 1 : i.plotWidth),
									(t.height = n ? 1 : i.plotHeight),
									s &&
										((e = a - o),
										(t.width = Math.abs(e)),
										(t.x = (0 < e ? 0 : e) + o)),
									n &&
										((e = h - r),
										(t.height = Math.abs(e)),
										(t.y = (0 < e ? 0 : e) + r));
							}),
							t
						);
					}),
					(C.prototype.drag = function (t) {
						var e = this.chart,
							i = e.options.chart,
							o = e.plotLeft,
							r = e.plotTop,
							s = e.plotWidth,
							n = e.plotHeight,
							a = this.mouseDownX || 0,
							h = this.mouseDownY || 0,
							l = S(i.panning) ? i.panning && i.panning.enabled : i.panning,
							c = i.panKey && t[i.panKey + "Key"],
							d = t.chartX,
							p = t.chartY,
							u = this.selectionMarker;
						(u && u.touch) ||
							(d < o ? (d = o) : o + s < d && (d = o + s),
							p < r ? (p = r) : r + n < p && (p = r + n),
							(this.hasDragged = Math.sqrt(
								Math.pow(a - d, 2) + Math.pow(h - p, 2)
							)),
							10 < this.hasDragged &&
								((s = e.isInsidePlot(a - o, h - r, { visiblePlotOnly: !0 })),
								(a = (n = this.getSelectionMarkerAttrs(d, p)).shapeType),
								(o = n.attrs),
								(!e.hasCartesianSeries && !e.mapView) ||
									(!this.zoomX && !this.zoomY) ||
									!s ||
									c ||
									u ||
									((this.selectionMarker = u = e.renderer[a]()),
									u
										.attr({ class: "highcharts-selection-marker", zIndex: 7 })
										.add(),
									e.styledMode ||
										u.attr({
											fill:
												i.selectionMarkerFill ||
												f("#335cad").setOpacity(0.25).get(),
										})),
								u && u.attr(o),
								s && !u && l && e.pan(t, i.panning)));
					}),
					(C.prototype.dragStart = function (t) {
						var e = this.chart;
						(e.mouseIsDown = t.type),
							(e.cancelClick = !1),
							(e.mouseDownX = this.mouseDownX = t.chartX),
							(e.mouseDownY = this.mouseDownY = t.chartY);
					}),
					(C.prototype.getSelectionBox = function (e) {
						var t = { args: { marker: e }, result: {} };
						return (
							x(this, "getSelectionBox", t, function (t) {
								t.result = {
									x: e.attr ? +e.attr("x") : e.x,
									y: e.attr ? +e.attr("y") : e.y,
									width: e.attr ? e.attr("width") : e.width,
									height: e.attr ? e.attr("height") : e.height,
								};
							}),
							t.result
						);
					}),
					(C.prototype.drop = function (r) {
						var t,
							s,
							n,
							a,
							h,
							l,
							c,
							d = this,
							e = this.chart,
							p = this.hasPinched;
						this.selectionMarker &&
							((t = this.getSelectionBox(this.selectionMarker)),
							(s = t.x),
							(n = t.y),
							(a = t.width),
							(h = t.height),
							(l = {
								originalEvent: r,
								xAxis: [],
								yAxis: [],
								x: s,
								y: n,
								width: a,
								height: h,
							}),
							(c = Boolean(e.mapView)),
							(this.hasDragged || p) &&
								(e.axes.forEach(function (t) {
									var e, i, o;
									t.zoomEnabled &&
										m(t.min) &&
										(p || d[{ xAxis: "zoomX", yAxis: "zoomY" }[t.coll]]) &&
										b(s) &&
										b(n) &&
										b(a) &&
										b(h) &&
										((o = t.horiz),
										(e = "touchend" === r.type ? t.minPixelPadding : 0),
										(i = t.toValue((o ? s : n) + e)),
										(o = t.toValue((o ? s + a : n + h) - e)),
										l[t.coll].push({
											axis: t,
											min: Math.min(i, o),
											max: Math.max(i, o),
										}),
										(c = !0));
								}),
								c &&
									x(e, "selection", l, function (t) {
										e.zoom(y(t, p ? { animation: !1 } : null));
									})),
							b(e.index) &&
								(this.selectionMarker = this.selectionMarker.destroy()),
							p && this.scaleGroups()),
							e &&
								b(e.index) &&
								(o(e.container, { cursor: e._cursor }),
								(e.cancelClick = 10 < this.hasDragged),
								(e.mouseIsDown = this.hasDragged = this.hasPinched = !1),
								(this.pinchDown = []));
					}),
					(C.prototype.findNearestKDPoint = function (t, n, a) {
						var h;
						return (
							t.forEach(function (t) {
								var e,
									i,
									o,
									r,
									s =
										!(t.noSharedTooltip && n) &&
										t.options.findNearestPointBy.indexOf("y") < 0,
									t = t.searchPoint(a, s);
								S(t, !0) &&
									t.series &&
									(!S(h, !0) ||
										((s = t),
										(i = (e = h).distX - s.distX),
										(o = e.dist - s.dist),
										(r =
											(s.series.group && s.series.group.zIndex) -
											(e.series.group && e.series.group.zIndex)),
										0 <
											(i =
												0 != i && n
													? i
													: 0 != o
													? o
													: 0 != r
													? r
													: e.series.index > s.series.index
													? -1
													: 1))) &&
									(h = t);
							}),
							h
						);
					}),
					(C.prototype.getChartCoordinatesFromPoint = function (t, e) {
						var i,
							o,
							r = t.series,
							s = r.xAxis,
							r = r.yAxis,
							n = t.shapeArgs;
						return s && r
							? ((i = k(t.clientX, t.plotX)),
							  (o = t.plotY || 0),
							  t.isNode && n && b(n.x) && b(n.y) && ((i = n.x), (o = n.y)),
							  e
									? { chartX: r.len + r.pos - o, chartY: s.len + s.pos - i }
									: { chartX: i + s.pos, chartY: o + r.pos })
							: n && n.x && n.y
							? { chartX: n.x, chartY: n.y }
							: void 0;
					}),
					(C.prototype.getChartPosition = function () {
						if (this.chartPosition) return this.chartPosition;
						var t = this.chart.container,
							e = a(t),
							i =
								((this.chartPosition = {
									left: e.left,
									top: e.top,
									scaleX: 1,
									scaleY: 1,
								}),
								t.offsetWidth),
							t = t.offsetHeight;
						return (
							2 < i &&
								2 < t &&
								((this.chartPosition.scaleX = e.width / i),
								(this.chartPosition.scaleY = e.height / t)),
							this.chartPosition
						);
					}),
					(C.prototype.getCoordinates = function (e) {
						var i = { xAxis: [], yAxis: [] };
						return (
							this.chart.axes.forEach(function (t) {
								i[t.isXAxis ? "xAxis" : "yAxis"].push({
									axis: t,
									value: t.toValue(e[t.horiz ? "chartX" : "chartY"]),
								});
							}),
							i
						);
					}),
					(C.prototype.getHoverData = function (t, e, i, o, r, s) {
						var n = [],
							o = !(!o || !t),
							a = function (t) {
								return (
									t.visible &&
									!(!r && t.directTouch) &&
									k(t.options.enableMouseTracking, !0)
								);
							},
							h = {
								chartX: s ? s.chartX : void 0,
								chartY: s ? s.chartY : void 0,
								shared: r,
							};
						x(this, "beforeGetHoverData", h);
						var l =
								e && !e.stickyTracking
									? [e]
									: i.filter(function (t) {
											return t.stickyTracking && (h.filter || a)(t);
									  }),
							c = o || !s ? t : this.findNearestKDPoint(l, r, s),
							e = c && c.series;
						return (
							c &&
								(r && !e.noSharedTooltip
									? (l = i.filter(function (t) {
											return h.filter
												? h.filter(t)
												: a(t) && !t.noSharedTooltip;
									  })).forEach(function (t) {
											var e = v(t.points, function (t) {
												return t.x === c.x && !t.isNull;
											});
											S(e) &&
												(t.boosted && t.boost && (e = t.boost.getPoint(e)),
												n.push(e));
									  })
									: n.push(c)),
							x(this, "afterGetHoverData", (h = { hoverPoint: c })),
							{ hoverPoint: h.hoverPoint, hoverSeries: e, hoverPoints: n }
						);
					}),
					(C.prototype.getPointFromEvent = function (t) {
						for (var e, i = t.target; i && !e; )
							(e = i.point), (i = i.parentNode);
						return e;
					}),
					(C.prototype.onTrackerMouseOut = function (t) {
						var e = this.chart,
							t = t.relatedTarget || t.toElement,
							e = e.hoverSeries;
						(this.isDirectTouch = !1),
							!e ||
								!t ||
								e.stickyTracking ||
								this.inClass(t, "highcharts-tooltip") ||
								(this.inClass(t, "highcharts-series-" + e.index) &&
									this.inClass(t, "highcharts-tracker")) ||
								e.onMouseOut();
					}),
					(C.prototype.inClass = function (t, e) {
						for (var i, o = t; o; ) {
							if ((i = s(o, "class"))) {
								if (-1 !== i.indexOf(e)) return !0;
								if (-1 !== i.indexOf("highcharts-container")) return !1;
							}
							o = o.parentElement;
						}
					}),
					(C.prototype.init = function (t, e) {
						(this.options = e),
							(this.chart = t),
							(this.runChartClick = Boolean(
								e.chart.events && e.chart.events.click
							)),
							(this.pinchDown = []),
							(this.lastValidTouch = {}),
							i && (t.tooltip = new i(t, e.tooltip)),
							this.setDOMEvents();
					}),
					(C.prototype.normalize = function (t, e) {
						var i = t.touches,
							i = i
								? i.length
									? i.item(0)
									: k(i.changedTouches, t.changedTouches)[0]
								: t,
							o = ((e = e || this.getChartPosition()), i.pageX - e.left),
							i = i.pageY - e.top;
						return (
							(o /= e.scaleX),
							(i /= e.scaleY),
							y(t, { chartX: Math.round(o), chartY: Math.round(i) })
						);
					}),
					(C.prototype.onContainerClick = function (t) {
						var e = this.chart,
							i = e.hoverPoint,
							t = this.normalize(t),
							o = e.plotLeft,
							r = e.plotTop;
						e.cancelClick ||
							(i && this.inClass(t.target, "highcharts-tracker")
								? (x(i.series, "click", y(t, { point: i })),
								  e.hoverPoint && i.firePointEvent("click", t))
								: (y(t, this.getCoordinates(t)),
								  e.isInsidePlot(t.chartX - o, t.chartY - r, {
										visiblePlotOnly: !0,
								  }) && x(e, "click", t)));
					}),
					(C.prototype.onContainerMouseDown = function (t) {
						var e = 1 == (1 & (t.buttons || t.button));
						(t = this.normalize(t)),
							r.isFirefox && 0 !== t.button && this.onContainerMouseMove(t),
							(void 0 !== t.button && !e) ||
								(this.zoomOption(t),
								e && t.preventDefault && t.preventDefault(),
								this.dragStart(t));
					}),
					(C.prototype.onContainerMouseLeave = function (t) {
						var e = p[k(C.hoverChartIndex, -1)],
							i = this.chart.tooltip;
						(t = this.normalize(t)),
							e &&
								(t.relatedTarget || t.toElement) &&
								(e.pointer.reset(), (e.pointer.chartPosition = void 0)),
							i && !i.isHidden && this.reset();
					}),
					(C.prototype.onContainerMouseEnter = function (t) {
						delete this.chartPosition;
					}),
					(C.prototype.onContainerMouseMove = function (t) {
						var e = this.chart,
							i = e.tooltip,
							t = this.normalize(t);
						this.setHoverChartIndex(),
							t.preventDefault || (t.returnValue = !1),
							("mousedown" !== e.mouseIsDown && !this.touchSelect(t)) ||
								this.drag(t),
							e.openMenu ||
								(!this.inClass(t.target, "highcharts-tracker") &&
									!e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop, {
										visiblePlotOnly: !0,
									})) ||
								(i && i.shouldStickOnContact(t)) ||
								(this.inClass(t.target, "highcharts-no-tooltip")
									? this.reset(!1, 0)
									: this.runPointActions(t));
					}),
					(C.prototype.onDocumentTouchEnd = function (t) {
						var e = p[k(C.hoverChartIndex, -1)];
						e && e.pointer.drop(t);
					}),
					(C.prototype.onContainerTouchMove = function (t) {
						this.touchSelect(t) ? this.onContainerMouseMove(t) : this.touch(t);
					}),
					(C.prototype.onContainerTouchStart = function (t) {
						this.touchSelect(t)
							? this.onContainerMouseDown(t)
							: (this.zoomOption(t), this.touch(t, !0));
					}),
					(C.prototype.onDocumentMouseMove = function (t) {
						var e = this.chart,
							i = e.tooltip,
							o = this.chartPosition,
							t = this.normalize(t, o);
						!o ||
							e.isInsidePlot(t.chartX - e.plotLeft, t.chartY - e.plotTop, {
								visiblePlotOnly: !0,
							}) ||
							(i && i.shouldStickOnContact(t)) ||
							this.inClass(t.target, "highcharts-tracker") ||
							this.reset();
					}),
					(C.prototype.onDocumentMouseUp = function (t) {
						var e = p[k(C.hoverChartIndex, -1)];
						e && e.pointer.drop(t);
					}),
					(C.prototype.pinch = function (t) {
						var e = this,
							n = e.chart,
							i = e.pinchDown,
							o = t.touches || [],
							r = o.length,
							s = e.lastValidTouch,
							a = e.hasZoom,
							h = {},
							l =
								1 === r &&
								((e.inClass(t.target, "highcharts-tracker") &&
									n.runTrackerClick) ||
									e.runChartClick),
							c = {},
							d = e.chart.tooltip,
							d = 1 === r && k(d && d.options.followTouchMove, !0),
							p = e.selectionMarker;
						1 < r ? (e.initiated = !0) : d && (e.initiated = !1),
							a &&
								e.initiated &&
								!l &&
								!1 !== t.cancelable &&
								t.preventDefault(),
							[].map.call(o, function (t) {
								return e.normalize(t);
							}),
							"touchstart" === t.type
								? ([].forEach.call(o, function (t, e) {
										i[e] = { chartX: t.chartX, chartY: t.chartY };
								  }),
								  (s.x = [i[0].chartX, i[1] && i[1].chartX]),
								  (s.y = [i[0].chartY, i[1] && i[1].chartY]),
								  n.axes.forEach(function (t) {
										var e, i, o, r, s;
										t.zoomEnabled &&
											((e = n.bounds[t.horiz ? "h" : "v"]),
											(i = t.minPixelPadding),
											(s = t.toPixels(
												Math.min(k(t.options.min, t.dataMin), t.dataMin)
											)),
											(o = t.toPixels(
												Math.max(k(t.options.max, t.dataMax), t.dataMax)
											)),
											(r = Math.min(s, o)),
											(s = Math.max(s, o)),
											(e.min = Math.min(t.pos, r - i)),
											(e.max = Math.max(t.pos + t.len, s + i)));
								  }),
								  (e.res = !0))
								: d
								? this.runPointActions(e.normalize(t))
								: i.length &&
								  (x(n, "touchpan", { originalEvent: t }, function () {
										p ||
											(e.selectionMarker = p =
												y({ destroy: u, touch: !0 }, n.plotBox)),
											e.pinchTranslate(i, o, h, p, c, s),
											(e.hasPinched = a),
											e.scaleGroups(h, c);
								  }),
								  e.res && ((e.res = !1), this.reset(!1, 0)));
					}),
					(C.prototype.pinchTranslate = function (t, e, i, o, r, s) {
						this.zoomHor && this.pinchTranslateDirection(!0, t, e, i, o, r, s),
							this.zoomVert &&
								this.pinchTranslateDirection(!1, t, e, i, o, r, s);
					}),
					(C.prototype.pinchTranslateDirection = function (
						t,
						e,
						i,
						o,
						r,
						s,
						n,
						a
					) {
						function h() {
							"number" == typeof w &&
								20 < Math.abs(S - k) &&
								(C = a || Math.abs(M - w) / Math.abs(S - k)),
								(c = (y - M) / C + S),
								(l = p["plot" + (t ? "Width" : "Height")] / C);
						}
						var l,
							c,
							d,
							p = this.chart,
							u = t ? "x" : "y",
							f = t ? "X" : "Y",
							g = "chart" + f,
							m = t ? "width" : "height",
							y = p["plot" + (t ? "Left" : "Top")],
							v = p.inverted,
							x = p.bounds[t ? "h" : "v"],
							b = 1 === e.length,
							S = e[0][g],
							k = !b && e[1][g],
							C = a || 1,
							M = i[0][g],
							w = !b && i[1][g],
							b =
								(h(),
								(e = c) < x.min
									? ((e = x.min), (d = !0))
									: e + l > x.max && ((e = x.max - l), (d = !0)),
								d
									? ((M -= 0.8 * (M - n[u][0])),
									  "number" == typeof w && (w -= 0.8 * (w - n[u][1])),
									  h())
									: (n[u] = [M, w]),
								v || ((s[u] = c - y), (s[m] = l)),
								v ? (t ? "scaleY" : "scaleX") : "scale" + f),
							i = v ? 1 / C : C;
						(r[m] = l),
							(r[u] = e),
							(o[b] = C),
							(o["translate" + f] = i * y + (M - i * S));
					}),
					(C.prototype.reset = function (e, t) {
						var i = this,
							o = i.chart,
							r = o.hoverSeries,
							s = o.hoverPoint,
							n = o.hoverPoints,
							a = o.tooltip,
							h = a && a.shared ? n : s;
						e &&
							h &&
							l(h).forEach(function (t) {
								t.series.isCartesian && void 0 === t.plotX && (e = !1);
							}),
							e
								? a &&
								  h &&
								  l(h).length &&
								  (a.refresh(h),
								  a.shared && n
										? n.forEach(function (t) {
												t.setState(t.state, !0),
													t.series.isCartesian &&
														(t.series.xAxis.crosshair &&
															t.series.xAxis.drawCrosshair(null, t),
														t.series.yAxis.crosshair &&
															t.series.yAxis.drawCrosshair(null, t));
										  })
										: s &&
										  (s.setState(s.state, !0),
										  o.axes.forEach(function (t) {
												t.crosshair &&
													s.series[t.coll] === t &&
													t.drawCrosshair(null, s);
										  })))
								: (s && s.onMouseOut(),
								  n &&
										n.forEach(function (t) {
											t.setState();
										}),
								  r && r.onMouseOut(),
								  a && a.hide(t),
								  i.unDocMouseMove && (i.unDocMouseMove = i.unDocMouseMove()),
								  o.axes.forEach(function (t) {
										t.hideCrosshair();
								  }),
								  (i.hoverX = o.hoverPoints = o.hoverPoint = null));
					}),
					(C.prototype.runPointActions = function (o, t, e) {
						var i = this,
							r = i.chart,
							s = r.series,
							n = r.tooltip && r.tooltip.options.enabled ? r.tooltip : void 0,
							a = !!n && n.shared,
							h = ((l = t || r.hoverPoint) && l.series) || r.hoverSeries,
							t =
								(!o || "touchmove" !== o.type) &&
								(!!t || (h && h.directTouch && i.isDirectTouch)),
							s = this.getHoverData(l, h, s, t, a, o),
							l = s.hoverPoint,
							h = s.hoverSeries,
							c = s.hoverPoints,
							t =
								h && h.tooltipOptions.followPointer && !h.tooltipOptions.split,
							d = a && h && !h.noSharedTooltip;
						if (l && (e || l !== r.hoverPoint || (n && n.isHidden))) {
							if (
								((r.hoverPoints || []).forEach(function (t) {
									-1 === c.indexOf(t) && t.setState();
								}),
								r.hoverSeries !== h && h.onMouseOver(),
								i.applyInactiveState(c),
								(c || []).forEach(function (t) {
									t.setState("hover");
								}),
								r.hoverPoint && r.hoverPoint.firePointEvent("mouseOut"),
								!l.series)
							)
								return;
							(r.hoverPoints = c),
								(r.hoverPoint = l).firePointEvent(
									"mouseOver",
									void 0,
									function () {
										n && l && n.refresh(d ? c : l, o);
									}
								);
						} else
							t &&
								n &&
								!n.isHidden &&
								((s = n.getAnchor([{}], o)),
								r.isInsidePlot(s[0], s[1], { visiblePlotOnly: !0 }) &&
									n.updatePosition({ plotX: s[0], plotY: s[1] }));
						i.unDocMouseMove ||
							((i.unDocMouseMove = g(
								r.container.ownerDocument,
								"mousemove",
								function (t) {
									var e = p[C.hoverChartIndex];
									e && e.pointer.onDocumentMouseMove(t);
								}
							)),
							i.eventsToUnbind.push(i.unDocMouseMove)),
							r.axes.forEach(function (e) {
								var t,
									i = k((e.crosshair || {}).snap, !0);
								(t =
									!i || ((t = r.hoverPoint) && t.series[e.coll] === e)
										? t
										: v(c, function (t) {
												return t.series && t.series[e.coll] === e;
										  })) || !i
									? e.drawCrosshair(o, t)
									: e.hideCrosshair();
							});
					}),
					(C.prototype.scaleGroups = function (i, o) {
						var r = this.chart;
						r.series.forEach(function (t) {
							var e = i || t.getPlotBox();
							t.group &&
								((t.xAxis && t.xAxis.zoomEnabled) || r.mapView) &&
								(t.group.attr(e),
								t.markerGroup &&
									(t.markerGroup.attr(e),
									t.markerGroup.clip(o ? r.clipRect : null)),
								t.dataLabelsGroup && t.dataLabelsGroup.attr(e));
						}),
							r.clipRect.attr(o || r.clipBox);
					}),
					(C.prototype.setDOMEvents = function () {
						for (
							var t = this,
								e = this.chart.container,
								i = e.ownerDocument,
								o =
									((e.onmousedown = this.onContainerMouseDown.bind(this)),
									(e.onmousemove = this.onContainerMouseMove.bind(this)),
									(e.onclick = this.onContainerClick.bind(this)),
									this.eventsToUnbind.push(
										g(e, "mouseenter", this.onContainerMouseEnter.bind(this))
									),
									this.eventsToUnbind.push(
										g(e, "mouseleave", this.onContainerMouseLeave.bind(this))
									),
									C.unbindDocumentMouseUp ||
										(C.unbindDocumentMouseUp = g(
											i,
											"mouseup",
											this.onDocumentMouseUp.bind(this)
										)),
									this.chart.renderTo.parentElement);
							o && "BODY" !== o.tagName;

						)
							this.eventsToUnbind.push(
								g(o, "scroll", function () {
									delete t.chartPosition;
								})
							),
								(o = o.parentElement);
						r.hasTouch &&
							(this.eventsToUnbind.push(
								g(e, "touchstart", this.onContainerTouchStart.bind(this), {
									passive: !1,
								})
							),
							this.eventsToUnbind.push(
								g(e, "touchmove", this.onContainerTouchMove.bind(this), {
									passive: !1,
								})
							),
							C.unbindDocumentTouchEnd ||
								(C.unbindDocumentTouchEnd = g(
									i,
									"touchend",
									this.onDocumentTouchEnd.bind(this),
									{ passive: !1 }
								)));
					}),
					(C.prototype.setHoverChartIndex = function () {
						var t = this.chart,
							e = r.charts[k(C.hoverChartIndex, -1)];
						e &&
							e !== t &&
							e.pointer.onContainerMouseLeave({ relatedTarget: t.container }),
							(e && e.mouseIsDown) || (C.hoverChartIndex = t.index);
					}),
					(C.prototype.touch = function (t, e) {
						var i,
							o = this.chart;
						this.setHoverChartIndex(),
							1 === t.touches.length
								? ((t = this.normalize(t)),
								  o.isInsidePlot(t.chartX - o.plotLeft, t.chartY - o.plotTop, {
										visiblePlotOnly: !0,
								  }) && !o.openMenu
										? (e && this.runPointActions(t),
										  "touchmove" === t.type &&
												(i =
													!!(o = this.pinchDown)[0] &&
													4 <=
														Math.sqrt(
															Math.pow(o[0].chartX - t.chartX, 2) +
																Math.pow(o[0].chartY - t.chartY, 2)
														)),
										  k(i, !0) && this.pinch(t))
										: e && this.reset())
								: 2 === t.touches.length && this.pinch(t);
					}),
					(C.prototype.touchSelect = function (t) {
						return Boolean(
							this.chart.options.chart.zooming.singleTouch &&
								t.touches &&
								1 === t.touches.length
						);
					}),
					(C.prototype.zoomOption = function (t) {
						var e = this.chart,
							i = e.options.chart,
							e = e.inverted,
							o = i.zooming.type || "";
						/touch/.test(t.type) && (o = k(i.zooming.pinchType, o)),
							(this.zoomX = t = /x/.test(o)),
							(this.zoomY = i = /y/.test(o)),
							(this.zoomHor = (t && !e) || (i && e)),
							(this.zoomVert = (i && !e) || (t && e)),
							(this.hasZoom = t || i);
					}),
					C
				);
			}
		),
		e(
			t,
			"Core/MSPointer.js",
			[t["Core/Globals.js"], t["Core/Pointer.js"], t["Core/Utilities.js"]],
			function (t, n, e) {
				var o,
					i,
					r =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					a = t.charts,
					s = t.doc,
					h = t.noop,
					l = t.win,
					c = e.addEvent,
					d = e.css,
					p = e.objectEach,
					u = e.pick,
					f = e.removeEvent,
					g = {},
					m = !!l.PointerEvent;
				function y(t, e, i, o) {
					var r,
						s = a[n.hoverChartIndex || NaN];
					("touch" !== t.pointerType &&
						t.pointerType !== t.MSPOINTER_TYPE_TOUCH) ||
						!s ||
						((s = s.pointer),
						o(t),
						s[e]({
							type: i,
							target: t.currentTarget,
							preventDefault: h,
							touches:
								(((r = []).item = function (t) {
									return this[t];
								}),
								p(g, function (t) {
									r.push({ pageX: t.pageX, pageY: t.pageY, target: t.target });
								}),
								r),
						}));
				}
				function v() {
					return (null !== i && i.apply(this, arguments)) || this;
				}
				return (
					r(v, (i = n)),
					(v.isRequired = function () {
						return !(t.hasTouch || (!l.PointerEvent && !l.MSPointerEvent));
					}),
					(v.prototype.batchMSEvents = function (t) {
						t(
							this.chart.container,
							m ? "pointerdown" : "MSPointerDown",
							this.onContainerPointerDown
						),
							t(
								this.chart.container,
								m ? "pointermove" : "MSPointerMove",
								this.onContainerPointerMove
							),
							t(s, m ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
					}),
					(v.prototype.destroy = function () {
						this.batchMSEvents(f), i.prototype.destroy.call(this);
					}),
					(v.prototype.init = function (t, e) {
						i.prototype.init.call(this, t, e),
							this.hasZoom &&
								d(t.container, {
									"-ms-touch-action": "none",
									"touch-action": "none",
								});
					}),
					(v.prototype.onContainerPointerDown = function (t) {
						y(t, "onContainerTouchStart", "touchstart", function (t) {
							g[t.pointerId] = {
								pageX: t.pageX,
								pageY: t.pageY,
								target: t.currentTarget,
							};
						});
					}),
					(v.prototype.onContainerPointerMove = function (t) {
						y(t, "onContainerTouchMove", "touchmove", function (t) {
							(g[t.pointerId] = { pageX: t.pageX, pageY: t.pageY }),
								g[t.pointerId].target ||
									(g[t.pointerId].target = t.currentTarget);
						});
					}),
					(v.prototype.onDocumentPointerUp = function (t) {
						y(t, "onDocumentTouchEnd", "touchend", function (t) {
							delete g[t.pointerId];
						});
					}),
					(v.prototype.setDOMEvents = function () {
						var t = this.chart.tooltip;
						i.prototype.setDOMEvents.call(this),
							(this.hasZoom || u(t && t.options.followTouchMove, !0)) &&
								this.batchMSEvents(c);
					}),
					v
				);
			}
		),
		e(
			t,
			"Core/Legend/Legend.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/FormatUtilities.js"],
				t["Core/Globals.js"],
				t["Core/Series/Point.js"],
				t["Core/Renderer/RendererUtilities.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, u, o, r) {
				var d = t.animObject,
					p = t.setAnimation,
					s = e.format,
					a = (i.isFirefox, i.marginNames),
					h = (i.win, o.distribute),
					n = r.addEvent,
					l = r.createElement,
					c = r.css,
					f = r.defined,
					g = r.discardElement,
					m = r.find,
					y = r.fireEvent,
					v = r.isNumber,
					x = r.merge,
					S = r.pick,
					b = r.relativeLength,
					k = r.stableSort,
					C = r.syncTimeout;
				r.wrap;
				function M(t, e) {
					(this.allItems = []),
						(this.box = void 0),
						(this.contentGroup = void 0),
						(this.display = !1),
						(this.group = void 0),
						(this.initialItemY = 0),
						(this.itemHeight = 0),
						(this.itemMarginBottom = 0),
						(this.itemMarginTop = 0),
						(this.itemX = 0),
						(this.itemY = 0),
						(this.lastItemY = 0),
						(this.lastLineHeight = 0),
						(this.legendHeight = 0),
						(this.legendWidth = 0),
						(this.maxItemWidth = 0),
						(this.maxLegendWidth = 0),
						(this.offsetWidth = 0),
						(this.options = void 0),
						(this.padding = 0),
						(this.pages = []),
						(this.proximate = !1),
						(this.scrollGroup = void 0),
						(this.symbolHeight = 0),
						(this.symbolWidth = 0),
						(this.titleHeight = 0),
						(this.totalItemWidth = 0),
						(this.widthOption = 0),
						(this.chart = t),
						this.init(t, e);
				}
				return (
					(M.prototype.init = function (t, e) {
						(this.chart = t),
							this.setOptions(e),
							e.enabled &&
								(this.render(),
								n(this.chart, "endResize", function () {
									this.legend.positionCheckboxes();
								}),
								this.proximate
									? (this.unchartrender = n(this.chart, "render", function () {
											this.legend.proximatePositions(),
												this.legend.positionItems();
									  }))
									: this.unchartrender && this.unchartrender());
					}),
					(M.prototype.setOptions = function (t) {
						var e = S(t.padding, 8);
						(this.options = t),
							this.chart.styledMode ||
								((this.itemStyle = t.itemStyle),
								(this.itemHiddenStyle = x(this.itemStyle, t.itemHiddenStyle))),
							(this.itemMarginTop = t.itemMarginTop || 0),
							(this.itemMarginBottom = t.itemMarginBottom || 0),
							(this.padding = e),
							(this.initialItemY = e - 5),
							(this.symbolWidth = S(t.symbolWidth, 16)),
							(this.pages = []),
							(this.proximate =
								"proximate" === t.layout && !this.chart.inverted),
							(this.baseline = void 0);
					}),
					(M.prototype.update = function (t, e) {
						var i = this.chart;
						this.setOptions(x(!0, this.options, t)),
							this.destroy(),
							(i.isDirtyLegend = i.isDirtyBox = !0),
							S(e, !0) && i.redraw(),
							y(this, "afterUpdate");
					}),
					(M.prototype.colorizeItem = function (t, e) {
						var i,
							o,
							r,
							s,
							n = t.legendItem || {},
							a = n.group,
							h = n.label,
							l = n.line,
							n = n.symbol;
						a &&
							a[e ? "removeClass" : "addClass"](
								"highcharts-legend-item-hidden"
							),
							this.chart.styledMode ||
								((a = this.options),
								(i = this.itemHiddenStyle.color),
								(a = e ? a.itemStyle.color : i),
								(o = (e && t.color) || i),
								(r = t.options && t.options.marker),
								(s = { fill: o }),
								h && h.css({ fill: a, color: a }),
								l && l.attr({ stroke: o }),
								n &&
									(r &&
										n.isMarker &&
										((s = t.pointAttribs()), e || (s.stroke = s.fill = i)),
									n.attr(s))),
							y(this, "afterColorizeItem", { item: t, visible: e });
					}),
					(M.prototype.positionItems = function () {
						this.allItems.forEach(this.positionItem, this),
							this.chart.isResizing || this.positionCheckboxes();
					}),
					(M.prototype.positionItem = function (t) {
						var e = this,
							i = t.legendItem || {},
							o = i.group,
							r = i.x,
							r = void 0 === r ? 0 : r,
							i = i.y,
							i = void 0 === i ? 0 : i,
							s = this.options,
							n = s.symbolPadding,
							s = !s.rtl,
							a = t.checkbox;
						o &&
							o.element &&
							((s = {
								translateX: s ? r : this.legendWidth - r - 2 * n - 4,
								translateY: i,
							}),
							o[f(o.translateY) ? "animate" : "attr"](s, void 0, function () {
								y(e, "afterPositionItem", { item: t });
							})),
							a && ((a.x = r), (a.y = i));
					}),
					(M.prototype.destroyItem = function (t) {
						for (
							var e = t.checkbox,
								i = t.legendItem || {},
								o = 0,
								r = ["group", "label", "line", "symbol"];
							o < r.length;
							o++
						) {
							var s = r[o];
							i[s] && (i[s] = i[s].destroy());
						}
						e && g(e), (t.legendItem = void 0);
					}),
					(M.prototype.destroy = function () {
						for (var t = 0, e = this.getAllItems(); t < e.length; t++) {
							var i = e[t];
							this.destroyItem(i);
						}
						for (
							var o = 0,
								r = [
									"clipRect",
									"up",
									"down",
									"pager",
									"nav",
									"box",
									"title",
									"group",
								];
							o < r.length;
							o++
						) {
							var s = r[o];
							this[s] && (this[s] = this[s].destroy());
						}
						this.display = null;
					}),
					(M.prototype.positionCheckboxes = function () {
						var o,
							r = this.group && this.group.alignAttr,
							s = this.clipHeight || this.legendHeight,
							n = this.titleHeight;
						r &&
							((o = r.translateY),
							this.allItems.forEach(function (t) {
								var e,
									i = t.checkbox;
								i &&
									((e = o + n + i.y + (this.scrollOffset || 0) + 3),
									c(i, {
										left: r.translateX + t.checkboxOffset + i.x - 20 + "px",
										top: e + "px",
										display:
											this.proximate || (o - 6 < e && e < o + s - 6)
												? ""
												: "none",
									}));
							}, this));
					}),
					(M.prototype.renderTitle = function () {
						var t = this.options,
							e = this.padding,
							i = t.title,
							o = 0;
						i.text &&
							(this.title ||
								((this.title = this.chart.renderer
									.label(
										i.text,
										e - 3,
										e - 4,
										void 0,
										void 0,
										void 0,
										t.useHTML,
										void 0,
										"legend-title"
									)
									.attr({ zIndex: 1 })),
								this.chart.styledMode || this.title.css(i.style),
								this.title.add(this.group)),
							i.width || this.title.css({ width: this.maxLegendWidth + "px" }),
							(o = (e = this.title.getBBox()).height),
							(this.offsetWidth = e.width),
							this.contentGroup.attr({ translateY: o })),
							(this.titleHeight = o);
					}),
					(M.prototype.setText = function (t) {
						var e = this.options;
						t.legendItem.label.attr({
							text: e.labelFormat
								? s(e.labelFormat, t, this.chart)
								: e.labelFormatter.call(t),
						});
					}),
					(M.prototype.renderItem = function (t) {
						var e = this,
							i = (t.legendItem = t.legendItem || {}),
							o = e.chart,
							r = o.renderer,
							s = e.options,
							n = "horizontal" === s.layout,
							a = e.symbolWidth,
							h = s.symbolPadding || 0,
							l = e.itemStyle,
							c = e.itemHiddenStyle,
							n = n ? S(s.itemDistance, 20) : 0,
							d = !s.rtl,
							p = !t.series,
							u = !p && t.series.drawLegendSymbol ? t.series : t,
							f = u.options,
							f = e.createCheckboxForItem && f && f.showCheckbox,
							g = s.useHTML,
							m = t.options.className,
							y = i.label,
							v = a + h + n + (f ? 20 : 0),
							m =
								(y ||
									((i.group = r
										.g("legend-item")
										.addClass(
											"highcharts-" +
												u.type +
												"-series highcharts-color-" +
												t.colorIndex +
												(m ? " " + m : "") +
												(p ? " highcharts-series-" + t.index : "")
										)
										.attr({ zIndex: 1 })
										.add(e.scrollGroup)),
									(i.label = y =
										r.text("", d ? a + h : -h, e.baseline || 0, g)),
									o.styledMode || y.css(x(t.visible ? l : c)),
									y
										.attr({ align: d ? "left" : "right", zIndex: 2 })
										.add(i.group),
									e.baseline ||
										((e.fontMetrics = r.fontMetrics(
											o.styledMode ? 12 : l.fontSize,
											y
										)),
										(e.baseline = e.fontMetrics.f + 3 + e.itemMarginTop),
										y.attr("y", e.baseline),
										(e.symbolHeight = s.symbolHeight || e.fontMetrics.f),
										s.squareSymbol &&
											((e.symbolWidth = S(
												s.symbolWidth,
												Math.max(e.symbolHeight, 16)
											)),
											(v = e.symbolWidth + h + n + (f ? 20 : 0)),
											d && y.attr("x", e.symbolWidth + h))),
									u.drawLegendSymbol(e, t),
									e.setItemEvents && e.setItemEvents(t, y, g)),
								f &&
									!t.checkbox &&
									e.createCheckboxForItem &&
									e.createCheckboxForItem(t),
								e.colorizeItem(t, t.visible),
								(!o.styledMode && l.width) ||
									y.css({
										width:
											(s.itemWidth || e.widthOption || o.spacingBox.width) -
											v +
											"px",
									}),
								e.setText(t),
								y.getBBox()),
							p = (e.fontMetrics && e.fontMetrics.h) || 0;
						(t.itemWidth = t.checkboxOffset =
							s.itemWidth || i.labelWidth || m.width + v),
							(e.maxItemWidth = Math.max(e.maxItemWidth, t.itemWidth)),
							(e.totalItemWidth += t.itemWidth),
							(e.itemHeight = t.itemHeight =
								Math.round(
									i.labelHeight || (m.height > 1.5 * p ? m.height : p)
								));
					}),
					(M.prototype.layoutItem = function (t) {
						var e = this.options,
							i = this.padding,
							o = "horizontal" === e.layout,
							r = t.itemHeight,
							s = this.itemMarginBottom,
							n = this.itemMarginTop,
							a = o ? S(e.itemDistance, 20) : 0,
							h = this.maxLegendWidth,
							e =
								e.alignColumns && this.totalItemWidth > h
									? this.maxItemWidth
									: t.itemWidth,
							l = t.legendItem || {};
						o &&
							this.itemX - i + e > h &&
							((this.itemX = i),
							this.lastLineHeight &&
								(this.itemY += n + this.lastLineHeight + s),
							(this.lastLineHeight = 0)),
							(this.lastItemY = n + this.itemY + s),
							(this.lastLineHeight = Math.max(r, this.lastLineHeight)),
							(l.x = this.itemX),
							(l.y = this.itemY),
							o
								? (this.itemX += e)
								: ((this.itemY += n + r + s), (this.lastLineHeight = r)),
							(this.offsetWidth =
								this.widthOption ||
								Math.max(
									(o ? this.itemX - i - (t.checkbox ? 0 : a) : e) + i,
									this.offsetWidth
								));
					}),
					(M.prototype.getAllItems = function () {
						var i = [];
						return (
							this.chart.series.forEach(function (t) {
								var e = t && t.options;
								t &&
									S(e.showInLegend, !f(e.linkedTo) && void 0, !0) &&
									(i = i.concat(
										(t.legendItem || {}).labels ||
											("point" === e.legendType ? t.data : t)
									));
							}),
							y(this, "afterGetAllItems", { allItems: i }),
							i
						);
					}),
					(M.prototype.getAlignment = function () {
						var t = this.options;
						return this.proximate
							? t.align.charAt(0) + "tv"
							: t.floating
							? ""
							: t.align.charAt(0) +
							  t.verticalAlign.charAt(0) +
							  t.layout.charAt(0);
					}),
					(M.prototype.adjustMargins = function (i, o) {
						var r = this.chart,
							s = this.options,
							n = this.getAlignment();
						n &&
							[
								/(lth|ct|rth)/,
								/(rtv|rm|rbv)/,
								/(rbh|cb|lbh)/,
								/(lbv|lm|ltv)/,
							].forEach(function (t, e) {
								t.test(n) &&
									!f(i[e]) &&
									(r[a[e]] = Math.max(
										r[a[e]],
										r.legend[(e + 1) % 2 ? "legendHeight" : "legendWidth"] +
											[1, -1, -1, 1][e] * s[e % 2 ? "x" : "y"] +
											S(s.margin, 12) +
											o[e] +
											(r.titleOffset[e] || 0)
									));
							});
					}),
					(M.prototype.proximatePositions = function () {
						var s = this.chart,
							n = [],
							a = "left" === this.options.align;
						this.allItems.forEach(function (t) {
							var e,
								i,
								o,
								r = a;
							t.yAxis &&
								(t.xAxis.options.reversed && (r = !r),
								t.points &&
									(e = m(
										r ? t.points : t.points.slice(0).reverse(),
										function (t) {
											return v(t.plotY);
										}
									)),
								(r =
									this.itemMarginTop +
									t.legendItem.label.getBBox().height +
									this.itemMarginBottom),
								(o = t.yAxis.top - s.plotTop),
								t.visible
									? ((i = e ? e.plotY : t.yAxis.height), (i += o - 0.3 * r))
									: (i = o + t.yAxis.height),
								n.push({ target: i, size: r, item: t }));
						}, this);
						for (var t = 0, e = h(n, s.plotHeight); t < e.length; t++) {
							var i = e[t],
								o = i.item.legendItem || {};
							v(i.pos) && (o.y = s.plotTop - s.spacing[0] + i.pos);
						}
					}),
					(M.prototype.render = function () {
						var t,
							e,
							i = this,
							o = i.chart,
							r = o.renderer,
							s = i.options,
							n = i.padding,
							a = i.getAllItems(),
							h = i.group,
							l = i.box;
						(i.itemX = n),
							(i.itemY = i.initialItemY),
							(i.offsetWidth = 0),
							(i.lastItemY = 0),
							(i.widthOption = b(s.width, o.spacingBox.width - n)),
							(e = o.spacingBox.width - 2 * n - s.x),
							-1 < ["rm", "lm"].indexOf(i.getAlignment().substring(0, 2)) &&
								(e /= 2),
							(i.maxLegendWidth = i.widthOption || e),
							h ||
								((i.group = h =
									r
										.g("legend")
										.addClass(s.className || "")
										.attr({ zIndex: 7 })
										.add()),
								(i.contentGroup = r.g().attr({ zIndex: 1 }).add(h)),
								(i.scrollGroup = r.g().add(i.contentGroup))),
							i.renderTitle(),
							k(a, function (t, e) {
								return (
									((t.options && t.options.legendIndex) || 0) -
									((e.options && e.options.legendIndex) || 0)
								);
							}),
							s.reversed && a.reverse(),
							(i.allItems = a),
							(i.display = e = !!a.length),
							(i.lastLineHeight = 0),
							(i.maxItemWidth = 0),
							(i.totalItemWidth = 0),
							(i.itemHeight = 0),
							a.forEach(i.renderItem, i),
							a.forEach(i.layoutItem, i),
							(a = (i.widthOption || i.offsetWidth) + n),
							(t = i.lastItemY + i.lastLineHeight + i.titleHeight),
							(t = i.handleOverflow(t)),
							(t += n),
							l ||
								(i.box = l =
									r
										.rect()
										.addClass("highcharts-legend-box")
										.attr({ r: s.borderRadius })
										.add(h)),
							o.styledMode ||
								l
									.attr({
										stroke: s.borderColor,
										"stroke-width": s.borderWidth || 0,
										fill: s.backgroundColor || "none",
									})
									.shadow(s.shadow),
							0 < a &&
								0 < t &&
								l[l.placed ? "animate" : "attr"](
									l.crisp.call(
										{},
										{ x: 0, y: 0, width: a, height: t },
										l.strokeWidth()
									)
								),
							h[e ? "show" : "hide"](),
							o.styledMode && "none" === h.getStyle("display") && (a = t = 0),
							(i.legendWidth = a),
							(i.legendHeight = t),
							e && i.align(),
							this.proximate || this.positionItems(),
							y(this, "afterRender");
					}),
					(M.prototype.align = function (t) {
						void 0 === t && (t = this.chart.spacingBox);
						var e = this.chart,
							i = this.options,
							o = t.y;
						/(lth|ct|rth)/.test(this.getAlignment()) && 0 < e.titleOffset[0]
							? (o += e.titleOffset[0])
							: /(lbh|cb|rbh)/.test(this.getAlignment()) &&
							  0 < e.titleOffset[2] &&
							  (o -= e.titleOffset[2]),
							o !== t.y && (t = x(t, { y: o })),
							e.hasRendered || (this.group.placed = !1),
							this.group.align(
								x(i, {
									width: this.legendWidth,
									height: this.legendHeight,
									verticalAlign: this.proximate ? "top" : i.verticalAlign,
								}),
								!0,
								t
							);
					}),
					(M.prototype.handleOverflow = function (t) {
						function e(t) {
							"number" == typeof t
								? b.attr({ height: t })
								: b && ((o.clipRect = b.destroy()), o.contentGroup.clip()),
								o.contentGroup.div &&
									(o.contentGroup.div.style.clip = t
										? "rect(" + p + "px,9999px," + (p + t) + "px,0)"
										: "auto");
						}
						function i(t) {
							return (
								(o[t] = h
									.circle(0, 0, 1.3 * m)
									.translate(m / 2, m / 2)
									.add(x)),
								a.styledMode || o[t].attr("fill", "rgba(0,0,0,0.0001)"),
								o[t]
							);
						}
						var r,
							s,
							n,
							o = this,
							a = this.chart,
							h = a.renderer,
							l = this.options,
							c = l.y,
							d = "top" === l.verticalAlign,
							p = this.padding,
							u = l.maxHeight,
							f = l.navigation,
							g = S(f.animation, !0),
							m = f.arrowSize || 12,
							y = this.pages,
							v = this.allItems,
							d = a.spacingBox.height + (d ? -c : c) - p,
							x = this.nav,
							b = this.clipRect;
						return (
							"horizontal" !== l.layout ||
								"middle" === l.verticalAlign ||
								l.floating ||
								(d /= 2),
							u && (d = Math.min(d, u)),
							(y.length = 0),
							t && 0 < d && d < t && !1 !== f.enabled
								? ((this.clipHeight = r =
										Math.max(d - 20 - this.titleHeight - p, 0)),
								  (this.currentPage = S(this.currentPage, 1)),
								  (this.fullHeight = t),
								  v.forEach(function (t, e) {
										var t = (n = t.legendItem || {}).y || 0,
											i = Math.round(n.label.getBBox().height),
											o = y.length;
										(!o || (t - y[o - 1] > r && (s || t) !== y[o - 1])) &&
											(y.push(s || t), o++),
											(n.pageIx = o - 1),
											s && ((v[e - 1].legendItem || {}).pageIx = o - 1),
											e === v.length - 1 &&
												t + i - y[o - 1] > r &&
												i <= r &&
												(y.push(t), (n.pageIx = o)),
											t !== s && (s = t);
								  }),
								  b ||
										((b = o.clipRect = h.clipRect(0, p, 9999, 0)),
										o.contentGroup.clip(b)),
								  e(r),
								  x ||
										((this.nav = x = h.g().attr({ zIndex: 1 }).add(this.group)),
										(this.up = h.symbol("triangle", 0, 0, m, m).add(x)),
										i("upTracker").on("click", function () {
											o.scroll(-1, g);
										}),
										(this.pager = h
											.text("", 15, 10)
											.addClass("highcharts-legend-navigation")),
										!a.styledMode && f.style && this.pager.css(f.style),
										this.pager.add(x),
										(this.down = h.symbol("triangle-down", 0, 0, m, m).add(x)),
										i("downTracker").on("click", function () {
											o.scroll(1, g);
										})),
								  o.scroll(0),
								  (t = d))
								: x &&
								  (e(),
								  (this.nav = x.destroy()),
								  this.scrollGroup.attr({ translateY: 1 }),
								  (this.clipHeight = 0)),
							t
						);
					}),
					(M.prototype.scroll = function (t, e) {
						var i = this,
							o = this.chart,
							r = this.pages,
							s = r.length,
							n = this.clipHeight,
							a = this.options.navigation,
							h = this.pager,
							l = this.padding,
							c = this.currentPage + t;
						0 < (c = s < c ? s : c) &&
							(void 0 !== e && p(e, o),
							this.nav.attr({
								translateX: l,
								translateY: n + this.padding + 7 + this.titleHeight,
								visibility: "inherit",
							}),
							[this.up, this.upTracker].forEach(function (t) {
								t.attr({
									class:
										1 === c
											? "highcharts-legend-nav-inactive"
											: "highcharts-legend-nav-active",
								});
							}),
							h.attr({ text: c + "/" + s }),
							[this.down, this.downTracker].forEach(function (t) {
								t.attr({
									x: 18 + this.pager.getBBox().width,
									class:
										c === s
											? "highcharts-legend-nav-inactive"
											: "highcharts-legend-nav-active",
								});
							}, this),
							o.styledMode ||
								(this.up.attr({
									fill: 1 === c ? a.inactiveColor : a.activeColor,
								}),
								this.upTracker.css({ cursor: 1 === c ? "default" : "pointer" }),
								this.down.attr({
									fill: c === s ? a.inactiveColor : a.activeColor,
								}),
								this.downTracker.css({
									cursor: c === s ? "default" : "pointer",
								})),
							(this.scrollOffset = -r[c - 1] + this.initialItemY),
							this.scrollGroup.animate({ translateY: this.scrollOffset }),
							(this.currentPage = c),
							this.positionCheckboxes(),
							(t = d(S(e, o.renderer.globalAnimation, !0))),
							C(function () {
								y(i, "afterScroll", { currentPage: c });
							}, t.duration));
					}),
					(M.prototype.setItemEvents = function (o, t, e) {
						for (
							var i = this,
								r = o.legendItem || {},
								s = i.chart.renderer.boxWrapper,
								n = o instanceof u,
								a = "highcharts-legend-" + (n ? "point" : "series") + "-active",
								h = i.chart.styledMode,
								e = e ? [t, r.symbol] : [r.group],
								l = function (e) {
									i.allItems.forEach(function (t) {
										o !== t &&
											[t].concat(t.linkedSeries || []).forEach(function (t) {
												t.setState(e, !n);
											});
									});
								},
								c = 0,
								d = e;
							c < d.length;
							c++
						) {
							var p = d[c];
							p &&
								p
									.on("mouseover", function () {
										o.visible && l("inactive"),
											o.setState("hover"),
											o.visible && s.addClass(a),
											h || t.css(i.options.itemHoverStyle);
									})
									.on("mouseout", function () {
										i.chart.styledMode ||
											t.css(x(o.visible ? i.itemStyle : i.itemHiddenStyle)),
											l(""),
											s.removeClass(a),
											o.setState();
									})
									.on("click", function (t) {
										function e() {
											o.setVisible && o.setVisible(),
												l(o.visible ? "inactive" : "");
										}
										var i = "legendItemClick";
										s.removeClass(a),
											(t = { browserEvent: t }),
											o.firePointEvent
												? o.firePointEvent(i, t, e)
												: y(o, i, t, e);
									});
						}
					}),
					(M.prototype.createCheckboxForItem = function (e) {
						(e.checkbox = l(
							"input",
							{
								type: "checkbox",
								className: "highcharts-legend-checkbox",
								checked: e.selected,
								defaultChecked: e.selected,
							},
							this.options.itemCheckboxStyle,
							this.chart.container
						)),
							n(e.checkbox, "click", function (t) {
								t = t.target;
								y(
									e.series || e,
									"checkboxClick",
									{ checked: t.checked, item: e },
									function () {
										e.select();
									}
								);
							});
					}),
					M
				);
			}
		),
		e(
			t,
			"Core/Series/SeriesRegistry.js",
			[
				t["Core/Globals.js"],
				t["Core/Defaults.js"],
				t["Core/Series/Point.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, n, i) {
				var o,
					a,
					h = e.defaultOptions,
					l = i.extendClass,
					c = i.merge;
				function d(t, e) {
					var i = h.plotOptions || {},
						o = e.defaultOptions,
						r = e.prototype;
					(r.type = t),
						r.pointClass || (r.pointClass = n),
						o && (i[t] = o),
						(a.seriesTypes[t] = e);
				}
				return (
					((a = o = o || {}).seriesTypes = t.seriesTypes),
					(a.registerSeriesType = d),
					(a.seriesType = function (t, e, i, o, r) {
						var s = h.plotOptions || {};
						return (
							(s[t] = c(s[(e = e || "")], i)),
							d(t, l(a.seriesTypes[e] || function () {}, o)),
							(a.seriesTypes[t].prototype.type = t),
							r && (a.seriesTypes[t].prototype.pointClass = l(n, r)),
							a.seriesTypes[t]
						);
					}),
					o
				);
			}
		),
		e(
			t,
			"Core/Chart/Chart.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Axis/Axis.js"],
				t["Core/Defaults.js"],
				t["Core/FormatUtilities.js"],
				t["Core/Foundation.js"],
				t["Core/Globals.js"],
				t["Core/Legend/Legend.js"],
				t["Core/MSPointer.js"],
				t["Core/Pointer.js"],
				t["Core/Renderer/RendererRegistry.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Renderer/SVG/SVGRenderer.js"],
				t["Core/Time.js"],
				t["Core/Utilities.js"],
				t["Core/Renderer/HTML/AST.js"],
			],
			function (t, o, e, R, z, n, N, i, r, W, H, G, p, a, l) {
				var h = t.animate,
					X = t.animObject,
					m = t.setAnimation,
					c = e.defaultOptions,
					F = e.defaultTime,
					Y = R.numberFormat,
					u = z.registerEventOptions,
					d = n.charts,
					f = n.doc,
					g = n.marginNames,
					_ = n.svg,
					y = n.win,
					v = H.seriesTypes,
					x = a.addEvent,
					U = a.attr,
					V = a.cleanRecursively,
					b = a.createElement,
					S = a.css,
					k = a.defined,
					K = a.discardElement,
					q = a.erase,
					C = a.error,
					M = a.extend,
					s = a.find,
					w = a.fireEvent,
					T = a.getStyle,
					Z = a.isArray,
					A = a.isNumber,
					P = a.isObject,
					L = a.isString,
					O = a.merge,
					E = a.objectEach,
					D = a.pick,
					j = a.pInt,
					$ = a.relativeLength,
					J = a.removeEvent,
					I = a.splat,
					Q = a.syncTimeout,
					tt = a.uniqueKey,
					t =
						((B.chart = function (t, e, i) {
							return new B(t, e, i);
						}),
						(B.prototype.getArgs = function (t, e, i) {
							L(t) || t.nodeName
								? ((this.renderTo = t), this.init(e, i))
								: this.init(t, e);
						}),
						(B.prototype.init = function (o, r) {
							var s = o.plotOptions || {};
							w(this, "init", { args: arguments }, function () {
								var t = O(c, o),
									e = t.chart,
									i =
										(E(t.plotOptions, function (t, e) {
											P(t) && (t.tooltip = (s[e] && O(s[e].tooltip)) || void 0);
										}),
										(t.tooltip.userOptions =
											(o.chart && o.chart.forExport && o.tooltip.userOptions) ||
											o.tooltip),
										(this.userOptions = o),
										(this.margin = []),
										(this.spacing = []),
										(this.bounds = { h: {}, v: {} }),
										(this.labelCollectors = []),
										(this.callback = r),
										(this.isResizing = 0),
										(e.zooming = e.zooming || {}));
								o.chart &&
									!o.chart.zooming &&
									(i.resetButton = e.resetZoomButton),
									(i.key = D(i.key, e.zoomKey)),
									(i.pinchType = D(i.pinchType, e.pinchType)),
									(i.singleTouch = D(i.singleTouch, e.zoomBySingleTouch)),
									(i.type = D(i.type, e.zoomType)),
									(this.options = t),
									(this.axes = []),
									(this.series = []),
									(this.time =
										o.time && Object.keys(o.time).length
											? new p(o.time)
											: n.time),
									(this.numberFormatter = e.numberFormatter || Y),
									(this.styledMode = e.styledMode),
									(this.hasCartesianSeries = e.showAxes);
								(this.index = d.length),
									d.push(this),
									n.chartCount++,
									u(this, e),
									(this.xAxis = []),
									(this.yAxis = []),
									(this.pointCount =
										this.colorCounter =
										this.symbolCounter =
											0),
									w(this, "afterInit"),
									this.firstRender();
							});
						}),
						(B.prototype.initSeries = function (t) {
							var e = this.options.chart,
								e = t.type || e.type || e.defaultSeriesType,
								i = v[e],
								e = (i || C(17, !0, this, { missingModuleFor: e }), new i());
							return "function" == typeof e.init && e.init(this, t), e;
						}),
						(B.prototype.setSeriesData = function () {
							this.getSeriesOrderByLinks().forEach(function (t) {
								t.points ||
									t.data ||
									!t.enabledDataSorting ||
									t.setData(t.options.data, !1);
							});
						}),
						(B.prototype.getSeriesOrderByLinks = function () {
							return this.series.concat().sort(function (t, e) {
								return t.linkedSeries.length || e.linkedSeries.length
									? e.linkedSeries.length - t.linkedSeries.length
									: 0;
							});
						}),
						(B.prototype.orderSeries = function (t) {
							for (var e = this.series, i = t || 0, o = e.length; i < o; ++i)
								e[i] && ((e[i].index = i), (e[i].name = e[i].getName()));
						}),
						(B.prototype.isInsidePlot = function (t, e, i) {
							var o,
								r = this.inverted,
								s = this.plotBox,
								n = this.plotLeft,
								a = this.plotTop,
								h = this.scrollablePlotBox,
								l = 0,
								c = 0,
								d =
									((i = void 0 === i ? {} : i).visiblePlotOnly &&
										this.scrollingContainer &&
										((l = (d = this.scrollingContainer).scrollLeft),
										(c = d.scrollTop)),
									i.series),
								h = (i.visiblePlotOnly && h) || s,
								s = i.inverted ? e : t,
								t = i.inverted ? t : e,
								e = { x: s, y: t, isInsidePlot: !0, options: i };
							return (
								i.ignoreX ||
									((o = (d && (r && !this.polar ? d.yAxis : d.xAxis)) || {
										pos: n,
										len: 1 / 0,
									}),
									((s = i.paneCoordinates ? o.pos + s : n + s) >=
										Math.max(l + n, o.pos) &&
										s <= Math.min(l + n + h.width, o.pos + o.len)) ||
										(e.isInsidePlot = !1)),
								!i.ignoreY &&
									e.isInsidePlot &&
									((s = (i.axis && !i.axis.isXAxis && i.axis) ||
										(d && (r ? d.xAxis : d.yAxis)) || { pos: a, len: 1 / 0 }),
									((l = i.paneCoordinates ? s.pos + t : a + t) >=
										Math.max(c + a, s.pos) &&
										l <= Math.min(c + a + h.height, s.pos + s.len)) ||
										(e.isInsidePlot = !1)),
								w(this, "afterIsInsidePlot", e),
								e.isInsidePlot
							);
						}),
						(B.prototype.redraw = function (t) {
							w(this, "beforeRedraw");
							var e,
								i,
								o,
								r,
								s = this,
								n = s.hasCartesianSeries ? s.axes : s.colorAxis || [],
								a = s.series,
								h = s.pointer,
								l = s.legend,
								c = s.userOptions.legend,
								d = s.renderer,
								p = d.isHidden(),
								u = [],
								f = s.isDirtyBox,
								g = s.isDirtyLegend;
							for (
								s.setResponsive && s.setResponsive(!1),
									m(!!s.hasRendered && t, s),
									p && s.temporaryDisplay(),
									s.layOutTitles(),
									o = a.length;
								o--;

							)
								if (
									((r = a[o]).options.stacking || r.options.centerInCategory) &&
									((i = !0), r.isDirty)
								) {
									e = !0;
									break;
								}
							if (e)
								for (o = a.length; o--; )
									(r = a[o]).options.stacking && (r.isDirty = !0);
							a.forEach(function (t) {
								t.isDirty &&
									("point" === t.options.legendType
										? ("function" == typeof t.updateTotals && t.updateTotals(),
										  (g = !0))
										: c && (c.labelFormatter || c.labelFormat) && (g = !0)),
									t.isDirtyData && w(t, "updatedData");
							}),
								g &&
									l &&
									l.options.enabled &&
									(l.render(), (s.isDirtyLegend = !1)),
								i && s.getStacks(),
								n.forEach(function (t) {
									t.updateNames(), t.setScale();
								}),
								s.getMargins(),
								n.forEach(function (t) {
									t.isDirty && (f = !0);
								}),
								n.forEach(function (t) {
									var e = t.min + "," + t.max;
									t.extKey !== e &&
										((t.extKey = e),
										u.push(function () {
											w(t, "afterSetExtremes", M(t.eventArgs, t.getExtremes())),
												delete t.eventArgs;
										})),
										(f || i) && t.redraw();
								}),
								f && s.drawChartBox(),
								w(s, "predraw"),
								a.forEach(function (t) {
									(f || t.isDirty) && t.visible && t.redraw(),
										(t.isDirtyData = !1);
								}),
								h && h.reset(!0),
								d.draw(),
								w(s, "redraw"),
								w(s, "render"),
								p && s.temporaryDisplay(!0),
								u.forEach(function (t) {
									t.call();
								});
						}),
						(B.prototype.get = function (e) {
							var t = this.series;
							function i(t) {
								return t.id === e || (t.options && t.options.id === e);
							}
							for (
								var o = s(this.axes, i) || s(this.series, i), r = 0;
								!o && r < t.length;
								r++
							)
								o = s(t[r].points || [], i);
							return o;
						}),
						(B.prototype.getAxes = function () {
							var e = this,
								t = this.options,
								i = (t.xAxis = I(t.xAxis || {})),
								t = (t.yAxis = I(t.yAxis || {}));
							w(this, "getAxes"),
								i.forEach(function (t, e) {
									(t.index = e), (t.isX = !0);
								}),
								t.forEach(function (t, e) {
									t.index = e;
								}),
								i.concat(t).forEach(function (t) {
									new o(e, t);
								}),
								w(this, "afterGetAxes");
						}),
						(B.prototype.getSelectedPoints = function () {
							return this.series.reduce(function (e, t) {
								return (
									t.getPointsCollection().forEach(function (t) {
										D(t.selectedStaging, t.selected) && e.push(t);
									}),
									e
								);
							}, []);
						}),
						(B.prototype.getSelectedSeries = function () {
							return this.series.filter(function (t) {
								return t.selected;
							});
						}),
						(B.prototype.setTitle = function (t, e, i) {
							this.applyDescription("title", t),
								this.applyDescription("subtitle", e),
								this.applyDescription("caption", void 0),
								this.layOutTitles(i);
						}),
						(B.prototype.applyDescription = function (e, t) {
							var i = this,
								o =
									"title" === e
										? {
												color: "#333333",
												fontSize: this.options.isStock ? "16px" : "18px",
										  }
										: { color: "#666666" },
								o = (this.options[e] = O(
									!this.styledMode && { style: o },
									this.options[e],
									t
								)),
								r = this[e];
							r && t && (this[e] = r = r.destroy()),
								o &&
									!r &&
									(((r = this.renderer
										.text(o.text, 0, 0, o.useHTML)
										.attr({
											align: o.align,
											class: "highcharts-" + e,
											zIndex: o.zIndex || 4,
										})
										.add()).update = function (t) {
										i[
											{
												title: "setTitle",
												subtitle: "setSubtitle",
												caption: "setCaption",
											}[e]
										](t);
									}),
									this.styledMode || r.css(o.style),
									(this[e] = r));
						}),
						(B.prototype.layOutTitles = function (t) {
							var n = [0, 0, 0],
								a = this.renderer,
								h = this.spacingBox,
								e =
									(["title", "subtitle", "caption"].forEach(function (t) {
										var e,
											i,
											o = this[t],
											r = this.options[t],
											s = r.verticalAlign || "top",
											t =
												"title" === t
													? "top" === s
														? -3
														: 0
													: "top" === s
													? n[0] + 2
													: 0;
										o &&
											(this.styledMode || (e = r.style && r.style.fontSize),
											(e = a.fontMetrics(e, o).b),
											o.css({
												width:
													(r.width || h.width + (r.widthAdjust || 0)) + "px",
											}),
											(i = Math.round(o.getBBox(r.useHTML).height)),
											o.align(
												M({ y: "bottom" === s ? e : t + e, height: i }, r),
												!1,
												"spacingBox"
											),
											r.floating ||
												("top" === s
													? (n[0] = Math.ceil(n[0] + i))
													: "bottom" === s && (n[2] = Math.ceil(n[2] + i))));
									}, this),
									n[0] &&
										"top" === (this.options.title.verticalAlign || "top") &&
										(n[0] += this.options.title.margin),
									n[2] &&
										"bottom" === this.options.caption.verticalAlign &&
										(n[2] += this.options.caption.margin),
									!this.titleOffset ||
										this.titleOffset.join(",") !== n.join(","));
							(this.titleOffset = n),
								w(this, "afterLayOutTitles"),
								!this.isDirtyBox &&
									e &&
									((this.isDirtyBox = this.isDirtyLegend = e),
									this.hasRendered &&
										D(t, !0) &&
										this.isDirtyBox &&
										this.redraw());
						}),
						(B.prototype.getChartSize = function () {
							var t = this,
								e = t.options.chart,
								i = e.width,
								e = e.height,
								o = t.renderTo;
							k(i) || (t.containerWidth = T(o, "width")),
								k(e) || (t.containerHeight = T(o, "height")),
								(t.chartWidth = Math.max(0, i || t.containerWidth || 600)),
								(t.chartHeight = Math.max(
									0,
									$(e, t.chartWidth) ||
										(1 < t.containerHeight ? t.containerHeight : 400)
								));
						}),
						(B.prototype.temporaryDisplay = function (t) {
							var e,
								i = this.renderTo;
							if (t)
								for (; i && i.style; )
									i.hcOrigStyle && (S(i, i.hcOrigStyle), delete i.hcOrigStyle),
										i.hcOrigDetached &&
											(f.body.removeChild(i), (i.hcOrigDetached = !1)),
										(i = i.parentNode);
							else
								for (
									;
									i &&
									i.style &&
									(f.body.contains(i) ||
										i.parentNode ||
										((i.hcOrigDetached = !0), f.body.appendChild(i)),
									("none" !== T(i, "display", !1) && !i.hcOricDetached) ||
										((i.hcOrigStyle = {
											display: i.style.display,
											height: i.style.height,
											overflow: i.style.overflow,
										}),
										(e = { display: "block", overflow: "hidden" }),
										i !== this.renderTo && (e.height = 0),
										S(i, e),
										i.offsetWidth ||
											i.style.setProperty("display", "block", "important")),
									(i = i.parentNode) !== f.body);

								);
						}),
						(B.prototype.setClassName = function (t) {
							this.container.className = "highcharts-container " + (t || "");
						}),
						(B.prototype.getContainer = function () {
							var t = this,
								e = t.options,
								i = e.chart,
								o = "data-highcharts-chart",
								r = tt(),
								s = t.renderTo,
								n =
									(s || (t.renderTo = s = i.renderTo),
									L(s) && (t.renderTo = s = f.getElementById(s)),
									s || C(13, !0, t),
									j(U(s, o))),
								n =
									(A(n) && d[n] && d[n].hasRendered && d[n].destroy(),
									U(s, o, t.index),
									(s.innerHTML = l.emptyHTML),
									i.skipClone || s.offsetWidth || t.temporaryDisplay(),
									t.getChartSize(),
									t.chartWidth),
								o = t.chartHeight,
								r =
									(S(s, { overflow: "hidden" }),
									t.styledMode ||
										(a = M(
											{
												position: "relative",
												overflow: "hidden",
												width: n + "px",
												height: o + "px",
												textAlign: "left",
												lineHeight: "normal",
												zIndex: 0,
												"-webkit-tap-highlight-color": "rgba(0,0,0,0)",
												userSelect: "none",
												"touch-action": "manipulation",
												outline: "none",
											},
											i.style || {}
										)),
									b("div", { id: r }, a, s)),
								a =
									((t.container = r),
									(t._cursor = r.style.cursor),
									i.renderer || !_ ? W.getRendererType(i.renderer) : G);
							if (
								((t.renderer = new a(
									r,
									n,
									o,
									void 0,
									i.forExport,
									e.exporting && e.exporting.allowHTML,
									t.styledMode
								)),
								m(void 0, t),
								t.setClassName(i.className),
								t.styledMode)
							)
								for (var h in e.defs) this.renderer.definition(e.defs[h]);
							else t.renderer.setStyle(i.style);
							(t.renderer.chartIndex = t.index), w(this, "afterGetContainer");
						}),
						(B.prototype.getMargins = function (t) {
							var e = this.spacing,
								i = this.margin,
								o = this.titleOffset;
							this.resetMargins(),
								o[0] &&
									!k(i[0]) &&
									(this.plotTop = Math.max(this.plotTop, o[0] + e[0])),
								o[2] &&
									!k(i[2]) &&
									(this.marginBottom = Math.max(
										this.marginBottom,
										o[2] + e[2]
									)),
								this.legend &&
									this.legend.display &&
									this.legend.adjustMargins(i, e),
								w(this, "getMargins"),
								t || this.getAxisMargins();
						}),
						(B.prototype.getAxisMargins = function () {
							function t(t) {
								t.forEach(function (t) {
									t.visible && t.getOffset();
								});
							}
							var i = this,
								o = (i.axisOffset = [0, 0, 0, 0]),
								e = i.colorAxis,
								r = i.margin;
							i.hasCartesianSeries ? t(i.axes) : e && e.length && t(e),
								g.forEach(function (t, e) {
									k(r[e]) || (i[t] += o[e]);
								}),
								i.setChartSize();
						}),
						(B.prototype.reflow = function (t) {
							var e = this,
								i = e.options.chart,
								o = e.renderTo,
								r = k(i.width) && k(i.height),
								s = i.width || T(o, "width"),
								i = i.height || T(o, "height"),
								o = t ? t.target : y;
							delete e.pointer.chartPosition,
								r ||
									e.isPrinting ||
									!s ||
									!i ||
									(o !== y && o !== f) ||
									((s === e.containerWidth && i === e.containerHeight) ||
										(a.clearTimeout(e.reflowTimeout),
										(e.reflowTimeout = Q(
											function () {
												e.container && e.setSize(void 0, void 0, !1);
											},
											t ? 100 : 0
										))),
									(e.containerWidth = s),
									(e.containerHeight = i));
						}),
						(B.prototype.setReflow = function (t) {
							var e = this;
							!1 === t || this.unbindReflow
								? !1 === t &&
								  this.unbindReflow &&
								  (this.unbindReflow = this.unbindReflow())
								: ((this.unbindReflow = x(y, "resize", function (t) {
										e.options && e.reflow(t);
								  })),
								  x(this, "destroy", this.unbindReflow));
						}),
						(B.prototype.setSize = function (t, e, i) {
							var o = this,
								r = o.renderer,
								i = ((o.isResizing += 1), m(i, o), r.globalAnimation);
							(o.oldChartHeight = o.chartHeight),
								(o.oldChartWidth = o.chartWidth),
								void 0 !== t && (o.options.chart.width = t),
								void 0 !== e && (o.options.chart.height = e),
								o.getChartSize(),
								o.styledMode ||
									(i ? h : S)(
										o.container,
										{
											width: o.chartWidth + "px",
											height: o.chartHeight + "px",
										},
										i
									),
								o.setChartSize(!0),
								r.setSize(o.chartWidth, o.chartHeight, i),
								o.axes.forEach(function (t) {
									(t.isDirty = !0), t.setScale();
								}),
								(o.isDirtyLegend = !0),
								(o.isDirtyBox = !0),
								o.layOutTitles(),
								o.getMargins(),
								o.redraw(i),
								(o.oldChartHeight = null),
								w(o, "resize"),
								Q(function () {
									o &&
										w(o, "endResize", null, function () {
											--o.isResizing;
										});
								}, X(i).duration);
						}),
						(B.prototype.setChartSize = function (t) {
							var e,
								i,
								o,
								r,
								s = this,
								n = s.inverted,
								a = s.renderer,
								h = s.chartWidth,
								l = s.chartHeight,
								c = s.options.chart,
								d = s.spacing,
								p = s.clipOffset,
								n =
									((s.plotLeft = e = Math.round(s.plotLeft)),
									(s.plotTop = i = Math.round(s.plotTop)),
									(s.plotWidth = o =
										Math.max(0, Math.round(h - e - s.marginRight))),
									(s.plotHeight = r =
										Math.max(0, Math.round(l - i - s.marginBottom))),
									(s.plotSizeX = n ? r : o),
									(s.plotSizeY = n ? o : r),
									(s.plotBorderWidth = c.plotBorderWidth || 0),
									(s.spacingBox = a.spacingBox =
										{
											x: d[3],
											y: d[0],
											width: h - d[3] - d[1],
											height: l - d[0] - d[2],
										}),
									(s.plotBox = a.plotBox = { x: e, y: i, width: o, height: r }),
									2 * Math.floor(s.plotBorderWidth / 2)),
								c = Math.ceil(Math.max(n, p[3]) / 2),
								h = Math.ceil(Math.max(n, p[0]) / 2);
							(s.clipBox = {
								x: c,
								y: h,
								width: Math.floor(s.plotSizeX - Math.max(n, p[1]) / 2 - c),
								height: Math.max(
									0,
									Math.floor(s.plotSizeY - Math.max(n, p[2]) / 2 - h)
								),
							}),
								t ||
									(s.axes.forEach(function (t) {
										t.setAxisSize(), t.setAxisTranslation();
									}),
									a.alignElements()),
								w(s, "afterSetChartSize", { skipAxes: t });
						}),
						(B.prototype.resetMargins = function () {
							w(this, "resetMargins");
							var r = this,
								s = r.options.chart;
							["margin", "spacing"].forEach(function (i) {
								var t = s[i],
									o = P(t) ? t : [t, t, t, t];
								["Top", "Right", "Bottom", "Left"].forEach(function (t, e) {
									r[i][e] = D(s[i + t], o[e]);
								});
							}),
								g.forEach(function (t, e) {
									r[t] = D(r.margin[e], r.spacing[e]);
								}),
								(r.axisOffset = [0, 0, 0, 0]),
								(r.clipOffset = [0, 0, 0, 0]);
						}),
						(B.prototype.drawChartBox = function () {
							var t,
								e,
								i = this,
								o = i.options.chart,
								r = i.renderer,
								s = i.chartWidth,
								n = i.chartHeight,
								a = i.styledMode,
								h = i.plotBGImage,
								l = o.backgroundColor,
								c = o.plotBackgroundColor,
								d = o.plotBackgroundImage,
								p = i.plotLeft,
								u = i.plotTop,
								f = i.plotWidth,
								g = i.plotHeight,
								m = i.plotBox,
								y = i.clipRect,
								v = i.clipBox,
								x = i.chartBackground,
								b = i.plotBackground,
								S = i.plotBorder,
								k = "animate";
							x ||
								((i.chartBackground = x =
									r.rect().addClass("highcharts-background").add()),
								(k = "attr")),
								a
									? (t = e = x.strokeWidth())
									: ((e = (t = o.borderWidth || 0) + (o.shadow ? 8 : 0)),
									  (l = { fill: l || "none" }),
									  (t || x["stroke-width"]) &&
											((l.stroke = o.borderColor), (l["stroke-width"] = t)),
									  x.attr(l).shadow(o.shadow)),
								x[k]({
									x: e / 2,
									y: e / 2,
									width: s - e - (t % 2),
									height: n - e - (t % 2),
									r: o.borderRadius,
								}),
								(k = "animate"),
								b ||
									((k = "attr"),
									(i.plotBackground = b =
										r.rect().addClass("highcharts-plot-background").add())),
								b[k](m),
								a ||
									(b.attr({ fill: c || "none" }).shadow(o.plotShadow),
									d &&
										(h
											? (d !== h.attr("href") && h.attr("href", d),
											  h.animate(m))
											: (i.plotBGImage = r.image(d, p, u, f, g).add()))),
								y
									? y.animate({ width: v.width, height: v.height })
									: (i.clipRect = r.clipRect(v)),
								(k = "animate"),
								S ||
									((k = "attr"),
									(i.plotBorder = S =
										r
											.rect()
											.addClass("highcharts-plot-border")
											.attr({ zIndex: 1 })
											.add())),
								a ||
									S.attr({
										stroke: o.plotBorderColor,
										"stroke-width": o.plotBorderWidth || 0,
										fill: "none",
									}),
								S[k](
									S.crisp({ x: p, y: u, width: f, height: g }, -S.strokeWidth())
								),
								(i.isDirtyBox = !1),
								w(this, "afterDrawChartBox");
						}),
						(B.prototype.propFromSeries = function () {
							var e,
								i,
								o,
								r = this,
								s = r.options.chart,
								n = r.options.series;
							["inverted", "angular", "polar"].forEach(function (t) {
								for (
									i = v[s.type || s.defaultSeriesType],
										o = s[t] || (i && i.prototype[t]),
										e = n && n.length;
									!o && e--;

								)
									(i = v[n[e].type]) && i.prototype[t] && (o = !0);
								r[t] = o;
							});
						}),
						(B.prototype.linkSeries = function () {
							var i = this,
								t = i.series;
							t.forEach(function (t) {
								t.linkedSeries.length = 0;
							}),
								t.forEach(function (t) {
									var e = t.options.linkedTo;
									L(e) &&
										(e =
											":previous" === e ? i.series[t.index - 1] : i.get(e)) &&
										e.linkedParent !== t &&
										(e.linkedSeries.push(t),
										(t.linkedParent = e).enabledDataSorting &&
											t.setDataSortingOptions(),
										(t.visible = D(
											t.options.visible,
											e.options.visible,
											t.visible
										)));
								}),
								w(this, "afterLinkSeries");
						}),
						(B.prototype.renderSeries = function () {
							this.series.forEach(function (t) {
								t.translate(), t.render();
							});
						}),
						(B.prototype.renderLabels = function () {
							var r = this,
								s = r.options.labels;
							s.items &&
								s.items.forEach(function (t) {
									var e = M(s.style, t.style),
										i = j(e.left) + r.plotLeft,
										o = j(e.top) + r.plotTop + 12;
									delete e.left,
										delete e.top,
										r.renderer
											.text(t.html, i, o)
											.attr({ zIndex: 2 })
											.css(e)
											.add();
								});
						}),
						(B.prototype.render = function () {
							function t(t) {
								t.forEach(function (t) {
									t.visible && t.render();
								});
							}
							var e = this,
								i = e.axes,
								o = e.colorAxis,
								r = e.renderer,
								s = e.options,
								n = 0,
								s =
									(e.setTitle(),
									(e.legend = new N(e, s.legend)),
									e.getStacks && e.getStacks(),
									e.getMargins(!0),
									e.setChartSize(),
									e.plotWidth),
								a =
									(i.some(function (t) {
										if (
											t.horiz &&
											t.visible &&
											t.options.labels.enabled &&
											t.series.length
										)
											return (n = 21), !0;
									}),
									(e.plotHeight = Math.max(e.plotHeight - n, 0)),
									e.plotHeight),
								h =
									(i.forEach(function (t) {
										t.setScale();
									}),
									e.getAxisMargins(),
									1.1 < s / e.plotWidth),
								l = 1.05 < a / e.plotHeight;
							(h || l) &&
								(i.forEach(function (t) {
									((t.horiz && h) || (!t.horiz && l)) && t.setTickInterval(!0);
								}),
								e.getMargins()),
								e.drawChartBox(),
								e.hasCartesianSeries ? t(i) : o && o.length && t(o),
								e.seriesGroup ||
									(e.seriesGroup = r
										.g("series-group")
										.attr({ zIndex: 3 })
										.add()),
								e.renderSeries(),
								e.renderLabels(),
								e.addCredits(),
								e.setResponsive && e.setResponsive(),
								(e.hasRendered = !0);
						}),
						(B.prototype.addCredits = function (t) {
							var e = this,
								i = O(!0, this.options.credits, t);
							i.enabled &&
								!this.credits &&
								((this.credits = this.renderer
									.text(i.text + (this.mapCredits || ""), 0, 0)
									.addClass("highcharts-credits")
									.on("click", function () {
										i.href && (y.location.href = i.href);
									})
									.attr({ align: i.position.align, zIndex: 8 })),
								e.styledMode || this.credits.css(i.style),
								this.credits.add().align(i.position),
								(this.credits.update = function (t) {
									(e.credits = e.credits.destroy()), e.addCredits(t);
								}));
						}),
						(B.prototype.destroy = function () {
							var t,
								i = this,
								e = i.axes,
								o = i.series,
								r = i.container,
								s = r && r.parentNode;
							for (
								w(i, "destroy"),
									i.renderer.forExport ? q(d, i) : (d[i.index] = void 0),
									n.chartCount--,
									i.renderTo.removeAttribute("data-highcharts-chart"),
									J(i),
									t = e.length;
								t--;

							)
								e[t] = e[t].destroy();
							for (
								this.scroller &&
									this.scroller.destroy &&
									this.scroller.destroy(),
									t = o.length;
								t--;

							)
								o[t] = o[t].destroy();
							[
								"title",
								"subtitle",
								"chartBackground",
								"plotBackground",
								"plotBGImage",
								"plotBorder",
								"seriesGroup",
								"clipRect",
								"credits",
								"pointer",
								"rangeSelector",
								"legend",
								"resetZoomButton",
								"tooltip",
								"renderer",
							].forEach(function (t) {
								var e = i[t];
								e && e.destroy && (i[t] = e.destroy());
							}),
								r && ((r.innerHTML = l.emptyHTML), J(r), s && K(r)),
								E(i, function (t, e) {
									delete i[e];
								});
						}),
						(B.prototype.firstRender = function () {
							var e = this,
								t = e.options;
							(e.isReadyToRender && !e.isReadyToRender()) ||
								(e.getContainer(),
								e.resetMargins(),
								e.setChartSize(),
								e.propFromSeries(),
								e.getAxes(),
								(Z(t.series) ? t.series : []).forEach(function (t) {
									e.initSeries(t);
								}),
								e.linkSeries(),
								e.setSeriesData(),
								w(e, "beforeRender"),
								r &&
									(i.isRequired()
										? (e.pointer = new i(e, t))
										: (e.pointer = new r(e, t))),
								e.render(),
								e.pointer.getChartPosition(),
								e.renderer.imgCount || e.hasLoaded || e.onload(),
								e.temporaryDisplay(!0));
						}),
						(B.prototype.onload = function () {
							this.callbacks.concat([this.callback]).forEach(function (t) {
								t && void 0 !== this.index && t.apply(this, [this]);
							}, this),
								w(this, "load"),
								w(this, "render"),
								k(this.index) && this.setReflow(this.options.chart.reflow),
								this.warnIfA11yModuleNotLoaded(),
								(this.hasLoaded = !0);
						}),
						(B.prototype.warnIfA11yModuleNotLoaded = function () {
							var t = this.options,
								e = this.title;
							t &&
								!this.accessibility &&
								(this.renderer.boxWrapper.attr({
									role: "img",
									"aria-label": ((e && e.element.textContent) || "").replace(
										/</g,
										"&lt;"
									),
								}),
								(t.accessibility && !1 === t.accessibility.enabled) ||
									C(
										'Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',
										!1,
										this
									));
						}),
						(B.prototype.addSeries = function (t, e, i) {
							var o,
								r = this;
							return (
								t &&
									((e = D(e, !0)),
									w(r, "addSeries", { options: t }, function () {
										(o = r.initSeries(t)),
											(r.isDirtyLegend = !0),
											r.linkSeries(),
											o.enabledDataSorting && o.setData(t.data, !1),
											w(r, "afterAddSeries", { series: o }),
											e && r.redraw(i);
									})),
								o
							);
						}),
						(B.prototype.addAxis = function (t, e, i, o) {
							return this.createAxis(e ? "xAxis" : "yAxis", {
								axis: t,
								redraw: i,
								animation: o,
							});
						}),
						(B.prototype.addColorAxis = function (t, e, i) {
							return this.createAxis("colorAxis", {
								axis: t,
								redraw: e,
								animation: i,
							});
						}),
						(B.prototype.createAxis = function (t, e) {
							t = new o(
								this,
								O(e.axis, { index: this[t].length, isX: "xAxis" === t })
							);
							return D(e.redraw, !0) && this.redraw(e.animation), t;
						}),
						(B.prototype.showLoading = function (t) {
							function e() {
								s &&
									S(s, {
										left: i.plotLeft + "px",
										top: i.plotTop + "px",
										width: i.plotWidth + "px",
										height: i.plotHeight + "px",
									});
							}
							var i = this,
								o = i.options,
								r = o.loading,
								s = i.loadingDiv,
								n = i.loadingSpan;
							s ||
								(i.loadingDiv = s =
									b(
										"div",
										{
											className: "highcharts-loading highcharts-loading-hidden",
										},
										null,
										i.container
									)),
								n ||
									((i.loadingSpan = n =
										b(
											"span",
											{ className: "highcharts-loading-inner" },
											null,
											s
										)),
									x(i, "redraw", e)),
								(s.className = "highcharts-loading"),
								l.setElementHTML(n, D(t, o.lang.loading, "")),
								i.styledMode ||
									(S(s, M(r.style, { zIndex: 10 })),
									S(n, r.labelStyle),
									i.loadingShown ||
										(S(s, { opacity: 0, display: "" }),
										h(
											s,
											{ opacity: r.style.opacity || 0.5 },
											{ duration: r.showDuration || 0 }
										))),
								(i.loadingShown = !0),
								e();
						}),
						(B.prototype.hideLoading = function () {
							var t = this.options,
								e = this.loadingDiv;
							e &&
								((e.className = "highcharts-loading highcharts-loading-hidden"),
								this.styledMode ||
									h(
										e,
										{ opacity: 0 },
										{
											duration: t.loading.hideDuration || 100,
											complete: function () {
												S(e, { display: "none" });
											},
										}
									)),
								(this.loadingShown = !1);
						}),
						(B.prototype.update = function (i, t, n, e) {
							var o,
								r,
								a = this,
								s = {
									credits: "addCredits",
									title: "setTitle",
									subtitle: "setSubtitle",
									caption: "setCaption",
								},
								h = i.isResponsiveOptions,
								l = [],
								c =
									(w(a, "update", { options: i }),
									h || a.setResponsive(!1, !0),
									(i = V(i, a.options)),
									(a.userOptions = O(a.userOptions, i)),
									i.chart),
								d =
									(c &&
										(O(!0, a.options.chart, c),
										"className" in c && a.setClassName(c.className),
										"reflow" in c && a.setReflow(c.reflow),
										("inverted" in c || "polar" in c || "type" in c) &&
											(a.propFromSeries(), (d = !0)),
										"alignTicks" in c && (d = !0),
										"events" in c && u(this, c),
										E(c, function (t, e) {
											-1 !== a.propsRequireUpdateSeries.indexOf("chart." + e) &&
												(o = !0),
												-1 !== a.propsRequireDirtyBox.indexOf(e) &&
													(a.isDirtyBox = !0),
												-1 !== a.propsRequireReflow.indexOf(e) &&
													(h ? (a.isDirtyBox = !0) : (r = !0));
										}),
										!a.styledMode &&
											c.style &&
											a.renderer.setStyle(a.options.chart.style || {})),
									!a.styledMode && i.colors && (this.options.colors = i.colors),
									i.time &&
										(this.time === F && (this.time = new p(i.time)),
										O(!0, a.options.time, i.time)),
									E(i, function (t, e) {
										a[e] && "function" == typeof a[e].update
											? a[e].update(t, !1)
											: "function" == typeof a[s[e]]
											? a[s[e]](t)
											: "colors" !== e &&
											  -1 === a.collectionsWithUpdate.indexOf(e) &&
											  O(!0, a.options[e], i[e]),
											"chart" !== e &&
												-1 !== a.propsRequireUpdateSeries.indexOf(e) &&
												(o = !0);
									}),
									this.collectionsWithUpdate.forEach(function (r) {
										var s;
										i[r] &&
											((s = []),
											a[r].forEach(function (t, e) {
												t.options.isInternal || s.push(D(t.options.index, e));
											}),
											I(i[r]).forEach(function (t, e) {
												var i,
													o = k(t.id);
												(i =
													!(i = o ? a.get(t.id) : i) &&
													a[r] &&
													(i = a[r][s ? s[e] : e]) &&
													o &&
													k(i.options.id)
														? void 0
														: i) &&
													i.coll === r &&
													(i.update(t, !1), n && (i.touched = !0)),
													!i &&
														n &&
														a.collectionsWithInit[r] &&
														(a.collectionsWithInit[r][0].apply(
															a,
															[t]
																.concat(a.collectionsWithInit[r][1] || [])
																.concat([!1])
														).touched = !0);
											}),
											n &&
												a[r].forEach(function (t) {
													t.touched || t.options.isInternal
														? delete t.touched
														: l.push(t);
												}));
									}),
									l.forEach(function (t) {
										t.chart && t.remove && t.remove(!1);
									}),
									d &&
										a.axes.forEach(function (t) {
											t.update({}, !1);
										}),
									o &&
										a.getSeriesOrderByLinks().forEach(function (t) {
											t.chart && t.update({}, !1);
										}, this),
									c && c.width),
								c =
									c &&
									(L(c.height) ? $(c.height, d || a.chartWidth) : c.height);
							r || (A(d) && d !== a.chartWidth) || (A(c) && c !== a.chartHeight)
								? a.setSize(d, c, e)
								: D(t, !0) && a.redraw(e),
								w(a, "afterUpdate", { options: i, redraw: t, animation: e });
						}),
						(B.prototype.setSubtitle = function (t, e) {
							this.applyDescription("subtitle", t), this.layOutTitles(e);
						}),
						(B.prototype.setCaption = function (t, e) {
							this.applyDescription("caption", t), this.layOutTitles(e);
						}),
						(B.prototype.showResetZoom = function () {
							var t = this,
								e = c.lang,
								i = t.options.chart.zooming.resetButton,
								o = i.theme,
								r =
									"chart" === i.relativeTo || "spacingBox" === i.relativeTo
										? null
										: "scrollablePlotBox";
							function s() {
								t.zoomOut();
							}
							w(this, "beforeShowResetZoom", null, function () {
								t.resetZoomButton = t.renderer
									.button(e.resetZoom, null, null, s, o)
									.attr({ align: i.position.align, title: e.resetZoomTitle })
									.addClass("highcharts-reset-zoom")
									.add()
									.align(i.position, !1, r);
							}),
								w(this, "afterShowResetZoom");
						}),
						(B.prototype.zoomOut = function () {
							w(this, "selection", { resetSelection: !0 }, this.zoom);
						}),
						(B.prototype.zoom = function (t) {
							var o,
								r = this,
								s = r.pointer,
								n = !1,
								e =
									(!t || t.resetSelection
										? (r.axes.forEach(function (t) {
												o = t.zoom();
										  }),
										  (s.initiated = !1))
										: t.xAxis.concat(t.yAxis).forEach(function (t) {
												var e = t.axis,
													i = e.isXAxis;
												((s[i ? "zoomX" : "zoomY"] &&
													k(s.mouseDownX) &&
													k(s.mouseDownY) &&
													r.isInsidePlot(
														s.mouseDownX - r.plotLeft,
														s.mouseDownY - r.plotTop,
														{ axis: e }
													)) ||
													!k(r.inverted ? s.mouseDownX : s.mouseDownY)) &&
													((o = e.zoom(t.min, t.max)),
													e.displayBtn && (n = !0));
										  }),
									r.resetZoomButton);
							n && !e
								? r.showResetZoom()
								: !n && P(e) && (r.resetZoomButton = e.destroy()),
								o &&
									r.redraw(
										D(
											r.options.chart.animation,
											t && t.animation,
											r.pointCount < 100
										)
									);
						}),
						(B.prototype.pan = function (p, t) {
							var u,
								f = this,
								e = f.hoverPoints,
								t = "object" == typeof t ? t : { enabled: t, type: "x" },
								i = f.options.chart,
								g = (i && i.panning && (i.panning = t), t.type);
							w(this, "pan", { originalEvent: p }, function () {
								e &&
									e.forEach(function (t) {
										t.setState();
									});
								var t = f.xAxis,
									d =
										("xy" === g
											? (t = t.concat(f.yAxis))
											: "y" === g && (t = f.yAxis),
										{});
								t.forEach(function (t) {
									var e, i, o, r, s, n, a, h, l, c;
									t.options.panningEnabled &&
										!t.options.isInternal &&
										((i = t.horiz),
										(e = p[i ? "chartX" : "chartY"]),
										(c = f[(i = i ? "mouseDownX" : "mouseDownY")]),
										(o = t.minPointOffset || 0),
										(n =
											(t.reversed && !f.inverted) || (!t.reversed && f.inverted)
												? -1
												: 1),
										(r = t.getExtremes()),
										(l = t.toValue(c - e, !0) + o * n),
										(n =
											(c =
												t.toValue(c + t.len - e, !0) -
												(o * n || (t.isXAxis && t.pointRangePadding) || 0)) <
											l),
										(h = t.hasVerticalPanning()),
										(s = n ? c : l),
										(n = n ? l : c),
										(a = t.panningState),
										!h ||
											t.isXAxis ||
											(a && !a.isDirty) ||
											t.series.forEach(function (t) {
												var e = t.getProcessedData(!0),
													e = t.getExtremes(e.yData, !0);
												(a = a || {
													startMin: Number.MAX_VALUE,
													startMax: -Number.MAX_VALUE,
												}),
													A(e.dataMin) &&
														A(e.dataMax) &&
														((a.startMin = Math.min(
															D(t.options.threshold, 1 / 0),
															e.dataMin,
															a.startMin
														)),
														(a.startMax = Math.max(
															D(t.options.threshold, -1 / 0),
															e.dataMax,
															a.startMax
														)));
											}),
										(l = Math.min(
											D(a && a.startMin, r.dataMin),
											o
												? r.min
												: t.toValue(t.toPixels(r.min) - t.minPixelPadding)
										)),
										(c = Math.max(
											D(a && a.startMax, r.dataMax),
											o
												? r.max
												: t.toValue(t.toPixels(r.max) + t.minPixelPadding)
										)),
										(t.panningState = a),
										t.isOrdinal ||
											(0 < (h = l - s) && ((n += h), (s = l)),
											0 < (h = n - c) && ((n = c), (s -= h)),
											t.series.length &&
												s !== r.min &&
												n !== r.max &&
												l <= s &&
												n <= c &&
												(t.setExtremes(s, n, !1, !1, { trigger: "pan" }),
												!f.resetZoomButton &&
													s !== l &&
													n !== c &&
													g.match("y") &&
													(f.showResetZoom(), (t.displayBtn = !1)),
												(u = !0)),
											(d[i] = e)));
								}),
									E(d, function (t, e) {
										f[e] = t;
									}),
									u && f.redraw(!1),
									S(f.container, { cursor: "move" });
							});
						}),
						B);
				function B(t, e, i) {
					(this.axes = void 0),
						(this.axisOffset = void 0),
						(this.bounds = void 0),
						(this.chartHeight = void 0),
						(this.chartWidth = void 0),
						(this.clipBox = void 0),
						(this.colorCounter = void 0),
						(this.container = void 0),
						(this.eventOptions = void 0),
						(this.index = void 0),
						(this.isResizing = void 0),
						(this.labelCollectors = void 0),
						(this.legend = void 0),
						(this.margin = void 0),
						(this.numberFormatter = void 0),
						(this.options = void 0),
						(this.plotBox = void 0),
						(this.plotHeight = void 0),
						(this.plotLeft = void 0),
						(this.plotTop = void 0),
						(this.plotWidth = void 0),
						(this.pointCount = void 0),
						(this.pointer = void 0),
						(this.renderer = void 0),
						(this.renderTo = void 0),
						(this.series = void 0),
						(this.sharedClips = {}),
						(this.spacing = void 0),
						(this.spacingBox = void 0),
						(this.symbolCounter = void 0),
						(this.time = void 0),
						(this.titleOffset = void 0),
						(this.userOptions = void 0),
						(this.xAxis = void 0),
						(this.yAxis = void 0),
						this.getArgs(t, e, i);
				}
				return (
					M(t.prototype, {
						callbacks: [],
						collectionsWithInit: {
							xAxis: [t.prototype.addAxis, [!0]],
							yAxis: [t.prototype.addAxis, [!1]],
							series: [t.prototype.addSeries],
						},
						collectionsWithUpdate: ["xAxis", "yAxis", "series"],
						propsRequireDirtyBox: [
							"backgroundColor",
							"borderColor",
							"borderWidth",
							"borderRadius",
							"plotBackgroundColor",
							"plotBackgroundImage",
							"plotBorderColor",
							"plotBorderWidth",
							"plotShadow",
							"shadow",
						],
						propsRequireReflow: [
							"margin",
							"marginTop",
							"marginRight",
							"marginBottom",
							"marginLeft",
							"spacing",
							"spacingTop",
							"spacingRight",
							"spacingBottom",
							"spacingLeft",
						],
						propsRequireUpdateSeries: [
							"chart.inverted",
							"chart.polar",
							"chart.ignoreHiddenSeries",
							"chart.type",
							"colors",
							"plotOptions",
							"time",
							"tooltip",
						],
					}),
					t
				);
			}
		),
		e(t, "Core/Legend/LegendSymbol.js", [t["Core/Utilities.js"]], function (t) {
			var e,
				d = t.extend,
				p = t.merge,
				u = t.pick;
			return (
				((t = e = e || {}).drawLineMarker = function (t) {
					var e = (this.legendItem = this.legendItem || {}),
						i = this.options,
						o = t.symbolWidth,
						r = t.symbolHeight,
						s = r / 2,
						n = this.chart.renderer,
						a = e.group,
						t = t.baseline - Math.round(0.3 * t.fontMetrics.b),
						h = {},
						l = i.marker,
						c = 0;
					this.chart.styledMode ||
						((h = { "stroke-width": Math.min(i.lineWidth || 0, 24) }),
						i.dashStyle
							? (h.dashstyle = i.dashStyle)
							: "square" !== i.linecap && (h["stroke-linecap"] = "round")),
						(e.line = n.path().addClass("highcharts-graph").attr(h).add(a)),
						h["stroke-linecap"] && (c = Math.min(e.line.strokeWidth(), o) / 2),
						e.line.attr({
							d: [
								["M", c, t],
								["L", o - c, t],
							],
						}),
						l &&
							!1 !== l.enabled &&
							o &&
							((i = Math.min(u(l.radius, s), s)),
							0 === this.symbol.indexOf("url") &&
								((l = p(l, { width: r, height: r })), (i = 0)),
							(e.symbol = h =
								n
									.symbol(
										this.symbol,
										o / 2 - i,
										t - i,
										2 * i,
										2 * i,
										d({ context: "legend" }, l)
									)
									.addClass("highcharts-point")
									.add(a)),
							(h.isMarker = !0));
				}),
				(t.drawRectangle = function (t, e) {
					var e = e.legendItem || {},
						i = t.options,
						o = t.symbolHeight,
						r = (i = i.squareSymbol) ? o : t.symbolWidth;
					e.symbol = this.chart.renderer
						.rect(
							i ? (t.symbolWidth - o) / 2 : 0,
							t.baseline - o + 1,
							r,
							o,
							u(t.options.symbolRadius, o / 2)
						)
						.addClass("highcharts-point")
						.attr({ zIndex: 3 })
						.add(e.group);
				}),
				e
			);
		}),
		e(t, "Core/Series/SeriesDefaults.js", [], function () {
			return {
				lineWidth: 2,
				allowPointSelect: !1,
				crisp: !0,
				showCheckbox: !1,
				animation: { duration: 1e3 },
				events: {},
				marker: {
					enabledThreshold: 2,
					lineColor: "#ffffff",
					lineWidth: 0,
					radius: 4,
					states: {
						normal: { animation: !0 },
						hover: {
							animation: { duration: 50 },
							enabled: !0,
							radiusPlus: 2,
							lineWidthPlus: 1,
						},
						select: {
							fillColor: "#cccccc",
							lineColor: "#000000",
							lineWidth: 2,
						},
					},
				},
				point: { events: {} },
				dataLabels: {
					animation: {},
					align: "center",
					borderWidth: 0,
					defer: !0,
					formatter: function () {
						var t = this.series.chart.numberFormatter;
						return "number" != typeof this.y ? "" : t(this.y, -1);
					},
					padding: 5,
					style: {
						fontSize: "11px",
						fontWeight: "bold",
						color: "contrast",
						textOutline: "1px contrast",
					},
					verticalAlign: "bottom",
					x: 0,
					y: 0,
				},
				cropThreshold: 300,
				opacity: 1,
				pointRange: 0,
				softThreshold: !0,
				states: {
					normal: { animation: !0 },
					hover: {
						animation: { duration: 50 },
						lineWidthPlus: 1,
						marker: {},
						halo: { size: 10, opacity: 0.25 },
					},
					select: { animation: { duration: 0 } },
					inactive: { animation: { duration: 50 }, opacity: 0.2 },
				},
				stickyTracking: !0,
				turboThreshold: 1e3,
				findNearestPointBy: "x",
			};
		}),
		e(
			t,
			"Core/Series/Series.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Defaults.js"],
				t["Core/Foundation.js"],
				t["Core/Globals.js"],
				t["Core/Legend/LegendSymbol.js"],
				t["Core/Series/Point.js"],
				t["Core/Series/SeriesDefaults.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Renderer/SVG/SVGElement.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, o, r, l, s, n, h, c) {
				var d = t.animObject,
					p = t.setAnimation,
					u = e.defaultOptions,
					a = i.registerEventOptions,
					f = o.hasTouch,
					g = o.svg,
					m = o.win,
					v = n.seriesTypes,
					y = (c.addEvent, c.arrayMax),
					x = c.arrayMin,
					A = c.clamp,
					b = c.cleanRecursively,
					P = c.correctFloat,
					L = c.defined,
					S = c.erase,
					C = c.error,
					k = c.extend,
					R = c.find,
					O = c.fireEvent,
					M = c.getNestedProperty,
					E = c.isArray,
					D = c.isNumber,
					z = c.isString,
					w = c.merge,
					T = c.objectEach,
					j = c.pick,
					N = c.removeEvent,
					W = c.splat,
					I = c.syncTimeout,
					t =
						((B.prototype.init = function (t, e) {
							O(this, "init", { options: e });
							var i,
								o = this,
								r = t.series,
								e =
									((this.eventsToUnbind = []),
									(o.chart = t),
									(o.options = o.setOptions(e)),
									o.options),
								s =
									((o.linkedSeries = []),
									o.bindAxes(),
									k(o, {
										name: e.name,
										state: "",
										visible: !1 !== e.visible,
										selected: !0 === e.selected,
									}),
									a(this, e),
									e.events);
							((s && s.click) ||
								(e.point && e.point.events && e.point.events.click) ||
								e.allowPointSelect) &&
								(t.runTrackerClick = !0),
								o.getColor(),
								o.getSymbol(),
								o.parallelArrays.forEach(function (t) {
									o[t + "Data"] || (o[t + "Data"] = []);
								}),
								o.isCartesian && (t.hasCartesianSeries = !0),
								r.length && (i = r[r.length - 1]),
								(o._i = j(i && i._i, -1) + 1),
								(o.opacity = o.options.opacity),
								t.orderSeries(this.insert(r)),
								e.dataSorting && e.dataSorting.enabled
									? o.setDataSortingOptions()
									: o.points || o.data || o.setData(e.data, !1),
								O(this, "afterInit");
						}),
						(B.prototype.is = function (t) {
							return v[t] && this instanceof v[t];
						}),
						(B.prototype.insert = function (t) {
							var e,
								i = this.options.index;
							if (D(i)) {
								for (e = t.length; e--; )
									if (i >= j(t[e].options.index, t[e]._i)) {
										t.splice(e + 1, 0, this);
										break;
									}
								-1 === e && t.unshift(this), (e += 1);
							} else t.push(this);
							return j(e, t.length - 1);
						}),
						(B.prototype.bindAxes = function () {
							var o,
								r = this,
								s = r.options,
								t = r.chart;
							O(this, "bindAxes", null, function () {
								(r.axisTypes || []).forEach(function (e) {
									var i = 0;
									t[e].forEach(function (t) {
										(o = t.options),
											((s[e] === i && !o.isInternal) ||
												(void 0 !== s[e] && s[e] === o.id) ||
												(void 0 === s[e] && 0 === o.index)) &&
												(r.insert(t.series), ((r[e] = t).isDirty = !0)),
											o.isInternal || i++;
									}),
										r[e] || r.optionalAxis === e || C(18, !0, t);
								});
							}),
								O(this, "afterBindAxes");
						}),
						(B.prototype.updateParallelArrays = function (i, o) {
							var r = i.series,
								e = arguments,
								t = D(o)
									? function (t) {
											var e = "y" === t && r.toYData ? r.toYData(i) : i[t];
											r[t + "Data"][o] = e;
									  }
									: function (t) {
											Array.prototype[o].apply(
												r[t + "Data"],
												Array.prototype.slice.call(e, 2)
											);
									  };
							r.parallelArrays.forEach(t);
						}),
						(B.prototype.hasData = function () {
							return (
								(this.visible &&
									void 0 !== this.dataMax &&
									void 0 !== this.dataMin) ||
								(this.visible && this.yData && 0 < this.yData.length)
							);
						}),
						(B.prototype.autoIncrement = function (t) {
							var e,
								i = this.options,
								o = i.pointIntervalUnit,
								r = i.relativeXValue,
								s = this.chart.time,
								n = this.xIncrement,
								n = j(n, i.pointStart, 0);
							return (
								(this.pointInterval = i =
									j(this.pointInterval, i.pointInterval, 1)),
								r && D(t) && (i *= t),
								o &&
									((e = new s.Date(n)),
									"day" === o
										? s.set("Date", e, s.get("Date", e) + i)
										: "month" === o
										? s.set("Month", e, s.get("Month", e) + i)
										: "year" === o &&
										  s.set("FullYear", e, s.get("FullYear", e) + i),
									(i = e.getTime() - n)),
								r && D(t) ? n + i : ((this.xIncrement = n + i), n)
							);
						}),
						(B.prototype.setDataSortingOptions = function () {
							var t = this.options;
							k(this, {
								requireSorting: !1,
								sorted: !1,
								enabledDataSorting: !0,
								allowDG: !1,
							}),
								L(t.pointRange) || (t.pointRange = 1);
						}),
						(B.prototype.setOptions = function (t) {
							var e = this.chart,
								i = e.options,
								o = i.plotOptions,
								r = e.userOptions || {},
								t = w(t),
								e = e.styledMode,
								s = { plotOptions: o, userOptions: t },
								n = (O(this, "setOptions", s), s.plotOptions[this.type]),
								a = r.plotOptions || {},
								s =
									((this.userOptions = s.userOptions),
									w(n, o.series, r.plotOptions && r.plotOptions[this.type], t)),
								r =
									((this.tooltipOptions = w(
										u.tooltip,
										u.plotOptions.series && u.plotOptions.series.tooltip,
										u.plotOptions[this.type].tooltip,
										i.tooltip.userOptions,
										o.series && o.series.tooltip,
										o[this.type].tooltip,
										t.tooltip
									)),
									(this.stickyTracking = j(
										t.stickyTracking,
										a[this.type] && a[this.type].stickyTracking,
										a.series && a.series.stickyTracking,
										!(!this.tooltipOptions.shared || this.noSharedTooltip) ||
											s.stickyTracking
									)),
									null === n.marker && delete s.marker,
									(this.zoneAxis = s.zoneAxis),
									(this.zones = (s.zones || []).slice()));
							return (
								(!s.negativeColor && !s.negativeFillColor) ||
									s.zones ||
									((i = {
										value: s[this.zoneAxis + "Threshold"] || s.threshold || 0,
										className: "highcharts-negative",
									}),
									e ||
										((i.color = s.negativeColor),
										(i.fillColor = s.negativeFillColor)),
									r.push(i)),
								r.length &&
									L(r[r.length - 1].value) &&
									r.push(
										e ? {} : { color: this.color, fillColor: this.fillColor }
									),
								O(this, "afterSetOptions", { options: s }),
								s
							);
						}),
						(B.prototype.getName = function () {
							return j(this.options.name, "Series " + (this.index + 1));
						}),
						(B.prototype.getCyclic = function (t, e, i) {
							var o,
								r,
								s = this.chart,
								n = this.userOptions,
								a = t + "Index",
								h = t + "Counter",
								l = i
									? i.length
									: j(s.options.chart[t + "Count"], s[t + "Count"]);
							e ||
								((r = j(n[a], n["_" + a])),
								L(r)
									? (o = r)
									: (s.series.length || (s[h] = 0),
									  (n["_" + a] = o = s[h] % l),
									  (s[h] += 1)),
								i && (e = i[o])),
								void 0 !== o && (this[a] = o),
								(this[t] = e);
						}),
						(B.prototype.getColor = function () {
							this.chart.styledMode
								? this.getCyclic("color")
								: this.options.colorByPoint
								? (this.color = "#cccccc")
								: this.getCyclic(
										"color",
										this.options.color || u.plotOptions[this.type].color,
										this.chart.options.colors
								  );
						}),
						(B.prototype.getPointsCollection = function () {
							return (this.hasGroupedData ? this.points : this.data) || [];
						}),
						(B.prototype.getSymbol = function () {
							var t = this.options.marker;
							this.getCyclic("symbol", t.symbol, this.chart.options.symbols);
						}),
						(B.prototype.findPointIndex = function (e, t) {
							var i,
								o,
								r,
								s = e.id,
								n = e.x,
								a = this.points,
								h = this.options.dataSorting;
							if (s) {
								s = this.chart.get(s);
								s instanceof l && (i = s);
							} else if (
								this.linkedParent ||
								this.enabledDataSorting ||
								this.options.relativeXValue
							) {
								s = function (t) {
									return !t.touched && t.index === e.index;
								};
								if (
									(h && h.matchByName
										? (s = function (t) {
												return !t.touched && t.name === e.name;
										  })
										: this.options.relativeXValue &&
										  (s = function (t) {
												return !t.touched && t.options.x === e.x;
										  }),
									!(i = R(a, s)))
								)
									return;
							}
							return (
								i && void 0 !== (r = i && i.index) && (o = !0),
								-1 !==
									(r = void 0 === r && D(n) ? this.xData.indexOf(n, t) : r) &&
									void 0 !== r &&
									this.cropped &&
									(r = r >= this.cropStart ? r - this.cropStart : r),
								(r = !o && D(r) && a[r] && a[r].touched ? void 0 : r)
							);
						}),
						(B.prototype.updateData = function (t, e) {
							var r,
								i,
								o,
								s,
								n = this.options,
								a = n.dataSorting,
								h = this.points,
								l = [],
								c = this.requireSorting,
								d = t.length === h.length,
								p = !0;
							if (
								((this.xIncrement = null),
								t.forEach(function (t, e) {
									var i =
											(L(t) &&
												this.pointClass.prototype.optionsToObject.call(
													{ series: this },
													t
												)) ||
											{},
										o = i.x;
									i.id || D(o)
										? (-1 === (o = this.findPointIndex(i, s)) || void 0 === o
												? l.push(t)
												: h[o] && t !== n.data[o]
												? (h[o].update(t, !1, null, !1),
												  (h[o].touched = !0),
												  c && (s = o + 1))
												: h[o] && (h[o].touched = !0),
										  (!d ||
												e !== o ||
												(a && a.enabled) ||
												this.hasDerivedData) &&
												(r = !0))
										: l.push(t);
								}, this),
								r)
							)
								for (i = h.length; i--; )
									(o = h[i]) && !o.touched && o.remove && o.remove(!1, e);
							else
								!d || (a && a.enabled)
									? (p = !1)
									: (t.forEach(function (t, e) {
											t !== h[e].y &&
												h[e].update &&
												h[e].update(t, !1, null, !1);
									  }),
									  (l.length = 0));
							return (
								h.forEach(function (t) {
									t && (t.touched = !1);
								}),
								!!p &&
									(l.forEach(function (t) {
										this.addPoint(t, !1, null, null, !1);
									}, this),
									null === this.xIncrement &&
										this.xData &&
										this.xData.length &&
										((this.xIncrement = y(this.xData)), this.autoIncrement()),
									!0)
							);
						}),
						(B.prototype.setData = function (t, e, i, o) {
							void 0 === e && (e = !0);
							var r,
								s,
								n,
								a,
								h = this,
								l = h.points,
								c = (l && l.length) || 0,
								d = h.options,
								p = h.chart,
								u = d.dataSorting,
								f = h.xAxis,
								g = d.turboThreshold,
								m = this.xData,
								y = this.yData,
								v = h.pointArrayMap,
								x = v && v.length,
								v = d.keys,
								b = 0,
								S = 1,
								k =
									(p.options.chart.allowMutatingData ||
										(d.data && delete h.options.data,
										h.userOptions.data && delete h.userOptions.data,
										(a = w(!0, t))),
									(t = a || t || []).length);
							if (
								(u && u.enabled && (t = this.sortData(t)),
								!(n =
									p.options.chart.allowMutatingData &&
									!1 !== o &&
									k &&
									c &&
									!h.cropped &&
									!h.hasGroupedData &&
									h.visible &&
									!h.boosted
										? this.updateData(t, i)
										: n))
							) {
								if (
									((h.xIncrement = null),
									(h.colorCounter = 0),
									this.parallelArrays.forEach(function (t) {
										h[t + "Data"].length = 0;
									}),
									g && g < k)
								)
									if (((a = h.getFirstValidPoint(t)), D(a)))
										for (r = 0; r < k; r++)
											(m[r] = this.autoIncrement()), (y[r] = t[r]);
									else if (E(a))
										if (x)
											if (a.length === x)
												for (r = 0; r < k; r++)
													(m[r] = this.autoIncrement()), (y[r] = t[r]);
											else
												for (r = 0; r < k; r++)
													(s = t[r]), (m[r] = s[0]), (y[r] = s.slice(1, x + 1));
										else if (
											(v &&
												((b = 0 <= (b = v.indexOf("x")) ? b : 0),
												(S = 0 <= (S = v.indexOf("y")) ? S : 1)),
											b === (S = 1 === a.length ? 0 : S))
										)
											for (r = 0; r < k; r++)
												(m[r] = this.autoIncrement()), (y[r] = t[r][S]);
										else
											for (r = 0; r < k; r++)
												(s = t[r]), (m[r] = s[b]), (y[r] = s[S]);
									else C(12, !1, p);
								else
									for (r = 0; r < k; r++)
										void 0 !== t[r] &&
											(h.pointClass.prototype.applyOptions.apply(
												(s = { series: h }),
												[t[r]]
											),
											h.updateParallelArrays(s, r));
								for (
									y && z(y[0]) && C(14, !0, p),
										h.data = [],
										h.options.data = h.userOptions.data = t,
										r = c;
									r--;

								)
									l[r] && l[r].destroy && l[r].destroy();
								f && (f.minRange = f.userMinRange),
									(h.isDirty = p.isDirtyBox = !0),
									(h.isDirtyData = !!l),
									(i = !1);
							}
							"point" === d.legendType &&
								(this.processData(), this.generatePoints()),
								e && p.redraw(i);
						}),
						(B.prototype.sortData = function (r) {
							function s(t, e) {
								return (
									(L(e) &&
										t.pointClass.prototype.optionsToObject.call(
											{ series: t },
											e
										)) ||
									{}
								);
							}
							var i = this,
								o = i.options.dataSorting.sortKey || "y";
							return (
								r.forEach(function (t, e) {
									(r[e] = s(i, t)), (r[e].index = e);
								}, this),
								r
									.concat()
									.sort(function (t, e) {
										(t = M(o, t)), (e = M(o, e));
										return e < t ? -1 : t < e ? 1 : 0;
									})
									.forEach(function (t, e) {
										t.x = e;
									}, this),
								i.linkedSeries &&
									i.linkedSeries.forEach(function (i) {
										var t = i.options,
											o = t.data;
										(t.dataSorting && t.dataSorting.enabled) ||
											!o ||
											(o.forEach(function (t, e) {
												(o[e] = s(i, t)),
													r[e] && ((o[e].x = r[e].x), (o[e].index = e));
											}),
											i.setData(o, !1));
									}),
								r
							);
						}),
						(B.prototype.getProcessedData = function (t) {
							var e,
								i,
								o,
								r,
								s,
								n,
								a = this,
								h = a.xAxis,
								l = a.options,
								c = l.cropThreshold,
								t = t || a.getExtremesFromAll || l.getExtremesFromAll,
								l = a.isCartesian,
								d = h && h.val2lin,
								p = !(!h || !h.logarithmic),
								u = 0,
								f = a.xData,
								g = a.yData,
								m = a.requireSorting,
								y = !1,
								v = f.length;
							for (
								h &&
									((s = (n = h.getExtremes()).min),
									(n = n.max),
									(y = !(!h.categories || h.names.length))),
									l &&
										a.sorted &&
										!t &&
										(!c || c < v || a.forceCrop) &&
										(f[v - 1] < s || f[0] > n
											? ((f = []), (g = []))
											: a.yData &&
											  (f[0] < s || f[v - 1] > n) &&
											  ((f = (h = this.cropData(a.xData, a.yData, s, n))
													.xData),
											  (g = h.yData),
											  (u = h.start),
											  (e = !0))),
									r = f.length || 1;
								--r;

							)
								0 < (i = p ? d(f[r]) - d(f[r - 1]) : f[r] - f[r - 1]) &&
								(void 0 === o || i < o)
									? (o = i)
									: i < 0 && m && !y && (C(15, !1, a.chart), (m = !1));
							return {
								xData: f,
								yData: g,
								cropped: e,
								cropStart: u,
								closestPointRange: o,
							};
						}),
						(B.prototype.processData = function (t) {
							var e = this,
								i = e.xAxis;
							if (
								e.isCartesian &&
								!e.isDirty &&
								!i.isDirty &&
								!e.yAxis.isDirty &&
								!t
							)
								return !1;
							i = e.getProcessedData();
							(e.cropped = i.cropped),
								(e.cropStart = i.cropStart),
								(e.processedXData = i.xData),
								(e.processedYData = i.yData),
								(e.closestPointRange = e.basePointRange = i.closestPointRange),
								O(e, "afterProcessData");
						}),
						(B.prototype.cropData = function (t, e, i, o, r) {
							var s,
								n,
								a = t.length,
								h = 0,
								l = a;
							for (r = j(r, this.cropShoulder), s = 0; s < a; s++)
								if (t[s] >= i) {
									h = Math.max(0, s - r);
									break;
								}
							for (n = s; n < a; n++)
								if (t[n] > o) {
									l = n + r;
									break;
								}
							return {
								xData: t.slice(h, l),
								yData: e.slice(h, l),
								start: h,
								end: l,
							};
						}),
						(B.prototype.generatePoints = function () {
							var t,
								e,
								i,
								o,
								r = this,
								s = r.options,
								n = r.processedData || s.data,
								a = r.processedXData,
								h = r.processedYData,
								l = r.pointClass,
								c = a.length,
								d = r.cropStart || 0,
								p = r.hasGroupedData,
								u = s.keys,
								f = [],
								g = s.dataGrouping && s.dataGrouping.groupAll ? d : 0,
								m = r.data;
							for (
								m || p || (((s = []).length = n.length), (m = r.data = s)),
									u && p && (r.options.keys = !1),
									o = 0;
								o < c;
								o++
							)
								(e = d + o),
									p
										? (((i = new l().init(
												r,
												[a[o]].concat(W(h[o]))
										  )).dataGroup = r.groupMap[g + o]),
										  i.dataGroup.options &&
												((i.options = i.dataGroup.options),
												k(i, i.dataGroup.options),
												delete i.dataLabels))
										: (i = m[e]) ||
										  void 0 === n[e] ||
										  (m[e] = i = new l().init(r, n[e], a[o])),
									i && ((i.index = p ? g + o : e), (f[o] = i));
							if (((r.options.keys = u), m && (c !== (t = m.length) || p)))
								for (o = 0; o < t; o++)
									o !== d || p || (o += c),
										m[o] && (m[o].destroyElements(), (m[o].plotX = void 0));
							(r.data = m), (r.points = f), O(this, "afterGeneratePoints");
						}),
						(B.prototype.getXExtremes = function (t) {
							return { min: x(t), max: y(t) };
						}),
						(B.prototype.getExtremes = function (t, e) {
							var i,
								o,
								r,
								s,
								n,
								a = this.xAxis,
								h = this.yAxis,
								l = this.processedXData || this.xData,
								c = [],
								d = this.requireSorting ? this.cropShoulder : 0,
								p = !!h && h.positiveValuesOnly,
								u = 0,
								f = 0,
								g = 0,
								m = (t = t || this.stackedYData || this.processedYData || [])
									.length;
							for (
								a && ((u = (h = a.getExtremes()).min), (f = h.max)), s = 0;
								s < m;
								s++
							)
								if (
									((o = l[s]),
									(r = t[s]),
									(i = (D(r) || E(r)) && (r.length || 0 < r || !p)),
									(o =
										e ||
										this.getExtremesFromAll ||
										this.options.getExtremesFromAll ||
										this.cropped ||
										!a ||
										((l[s + d] || o) >= u && (l[s - d] || o) <= f)),
									i && o)
								)
									if ((n = r.length)) for (; n--; ) D(r[n]) && (c[g++] = r[n]);
									else c[g++] = r;
							h = { activeYData: c, dataMin: x(c), dataMax: y(c) };
							return O(this, "afterGetExtremes", { dataExtremes: h }), h;
						}),
						(B.prototype.applyExtremes = function () {
							var t = this.getExtremes();
							return (this.dataMin = t.dataMin), (this.dataMax = t.dataMax), t;
						}),
						(B.prototype.getFirstValidPoint = function (t) {
							for (var e = t.length, i = 0, o = null; null === o && i < e; )
								(o = t[i]), i++;
							return o;
						}),
						(B.prototype.translate = function () {
							this.processedXData || this.processData(), this.generatePoints();
							var t,
								e,
								i,
								o,
								r = this,
								s = r.options,
								n = s.stacking,
								a = r.xAxis,
								h = a.categories,
								l = r.enabledDataSorting,
								c = r.yAxis,
								d = r.points,
								p = d.length,
								u = r.pointPlacementToXValue(),
								f = Boolean(u),
								g = s.threshold,
								m = s.startFromThreshold ? g : 0,
								y = this.zoneAxis || "y",
								v = Number.MAX_VALUE;
							function x(t) {
								return A(t, -1e5, 1e5);
							}
							for (t = 0; t < p; t++) {
								var b = d[t],
									S = b.x,
									k = void 0,
									C = void 0,
									M = b.y,
									w = b.low,
									T =
										n &&
										c.stacking &&
										c.stacking.stacks[
											(r.negStacks && M < (m ? 0 : g) ? "-" : "") + r.stackKey
										];
								((c.positiveValuesOnly && !c.validatePositiveValue(M)) ||
									(a.positiveValuesOnly && !a.validatePositiveValue(S))) &&
									(b.isNull = !0),
									(b.plotX = e =
										P(x(a.translate(S, 0, 0, 0, 1, u, "flags" === this.type)))),
									n &&
										r.visible &&
										T &&
										T[S] &&
										((o = r.getStackIndicator(o, S, r.index)),
										!b.isNull && o.key && (C = (k = T[S]).points[o.key]),
										k &&
											E(C) &&
											((w = C[0]),
											(M = C[1]),
											w === m &&
												o.key === T[S].base &&
												(w = j(D(g) ? g : c.min)),
											c.positiveValuesOnly && L(w) && w <= 0 && (w = void 0),
											(b.total = b.stackTotal = j(k.total)),
											(b.percentage =
												L(b.y) && k.total ? (b.y / k.total) * 100 : void 0),
											(b.stackY = M),
											r.irregularWidths ||
												k.setOffset(
													r.pointXOffset || 0,
													r.barW || 0,
													void 0,
													void 0,
													void 0,
													r.xAxis
												))),
									(b.yBottom = L(w) ? x(c.translate(w, 0, 1, 0, 1)) : void 0),
									r.dataModify && (M = r.dataModify.modifyValue(M, t)),
									(b.plotY = void 0),
									!D(M) ||
										(void 0 !== (C = c.translate(M, !1, !0, !1, !0)) &&
											(b.plotY = x(C))),
									(b.isInside = this.isPointInside(b)),
									(b.clientX = f ? P(a.translate(S, 0, 0, 0, 1, u)) : e),
									(b.negative = b[y] < (s[y + "Threshold"] || g || 0)),
									(b.category = j(h && h[b.x], b.x)),
									b.isNull ||
										!1 === b.visible ||
										(void 0 !== i && (v = Math.min(v, Math.abs(e - i))),
										(i = e)),
									(b.zone = this.zones.length ? b.getZone() : void 0),
									!b.graphic && r.group && l && (b.isNew = !0);
							}
							(r.closestPointRangePx = v), O(this, "afterTranslate");
						}),
						(B.prototype.getValidPoints = function (t, e, i) {
							var o = this.chart;
							return (t || this.points || []).filter(function (t) {
								return (
									!(
										e &&
										!o.isInsidePlot(t.plotX, t.plotY, { inverted: o.inverted })
									) &&
									!1 !== t.visible &&
									(i || !t.isNull)
								);
							});
						}),
						(B.prototype.getClipBox = function () {
							var t = this.chart,
								e = this.xAxis,
								i = this.yAxis,
								o = w(t.clipBox);
							return (
								e && e.len !== t.plotSizeX && (o.width = e.len),
								i && i.len !== t.plotSizeY && (o.height = i.len),
								o
							);
						}),
						(B.prototype.getSharedClipKey = function () {
							return (
								(this.sharedClipKey =
									(this.options.xAxis || 0) + "," + (this.options.yAxis || 0)),
								this.sharedClipKey
							);
						}),
						(B.prototype.setClip = function () {
							var t = this.chart,
								e = this.group,
								i = this.markerGroup,
								o = t.sharedClips,
								t = t.renderer,
								r = this.getClipBox(),
								s = this.getSharedClipKey(),
								n = o[s];
							n ? n.animate(r) : (o[s] = n = t.clipRect(r)),
								e && e.clip(!1 === this.options.clip ? void 0 : n),
								i && i.clip();
						}),
						(B.prototype.animate = function (t) {
							var i,
								e = this.chart,
								o = this.group,
								r = this.markerGroup,
								s = e.inverted,
								n = d(this.options.animation),
								a = [
									this.getSharedClipKey(),
									n.duration,
									n.easing,
									n.defer,
								].join(","),
								h = e.sharedClips[a],
								l = e.sharedClips[a + "m"];
							t && o
								? ((t = this.getClipBox()),
								  h
										? h.attr("height", t.height)
										: ((t.width = 0),
										  s && (t.x = e.plotHeight),
										  (h = e.renderer.clipRect(t)),
										  (e.sharedClips[a] = h),
										  (t = {
												x: -99,
												y: -99,
												width: s ? e.plotWidth + 199 : 99,
												height: s ? 99 : e.plotHeight + 199,
										  }),
										  (l = e.renderer.clipRect(t)),
										  (e.sharedClips[a + "m"] = l)),
								  o.clip(h),
								  r && r.clip(l))
								: h &&
								  !h.hasClass("highcharts-animating") &&
								  ((t = this.getClipBox()),
								  (i = n.step),
								  r &&
										r.element.childNodes.length &&
										(n.step = function (t, e) {
											i && i.apply(e, arguments),
												"width" === e.prop &&
													l &&
													l.element &&
													l.attr(s ? "height" : "width", t + 99);
										}),
								  h.addClass("highcharts-animating").animate(t, n));
						}),
						(B.prototype.afterAnimate = function () {
							var o = this;
							this.setClip(),
								T(this.chart.sharedClips, function (t, e, i) {
									t &&
										!o.chart.container.querySelector(
											'[clip-path="url(#'.concat(t.id, ')"]')
										) &&
										(t.destroy(), delete i[e]);
								}),
								(this.finishedAnimating = !0),
								O(this, "afterAnimate");
						}),
						(B.prototype.drawPoints = function (t) {
							void 0 === t && (t = this.points);
							var e,
								i = this,
								o = i.chart,
								r = o.styledMode,
								s = i.colorAxis,
								n = i.options.marker,
								a = i[i.specialGroup || "markerGroup"],
								h = i.xAxis,
								l = j(
									n.enabled,
									!(h && !h.isRadial) || null,
									i.closestPointRangePx >= n.enabledThreshold * n.radius
								);
							if (!1 !== n.enabled || i._hasPointMarkers)
								for (e = 0; e < t.length; e++) {
									var c,
										d,
										p,
										u,
										f,
										g = (d = (c = t[e]).graphic) ? "animate" : "attr",
										m = c.marker || {},
										y = !!c.marker;
									((l && void 0 === m.enabled) || m.enabled) &&
									!c.isNull &&
									!1 !== c.visible
										? ((f = j(m.symbol, i.symbol, "rect")),
										  (p = i.markerAttribs(c, c.selected && "select")),
										  i.enabledDataSorting &&
												(c.startXPos = h.reversed ? -(p.width || 0) : h.width),
										  (u = !1 !== c.isInside),
										  !d &&
												u &&
												(0 < (p.width || 0) || c.hasImage) &&
												((c.graphic = d =
													o.renderer
														.symbol(f, p.x, p.y, p.width, p.height, y ? m : n)
														.add(a)),
												i.enabledDataSorting &&
													o.hasRendered &&
													(d.attr({ x: c.startXPos }), (g = "animate"))),
										  d &&
												"animate" === g &&
												d[u ? "show" : "hide"](u).animate(p),
										  d &&
												((f = i.pointAttribs(
													c,
													r || !c.selected ? void 0 : "select"
												)),
												r ? s && d.css({ fill: f.fill }) : d[g](f)),
										  d && d.addClass(c.getClassName(), !0))
										: d && (c.graphic = d.destroy());
								}
						}),
						(B.prototype.markerAttribs = function (t, e) {
							var i = this.options,
								o = i.marker,
								r = t.marker || {},
								s = r.symbol || o.symbol,
								n = {},
								a = j(r.radius, o && o.radius),
								e =
									(e &&
										((o = o.states[e]),
										(r = r.states && r.states[e]),
										(a = j(
											r && r.radius,
											o && o.radius,
											a && a + ((o && o.radiusPlus) || 0)
										))),
									(t.hasImage = s && 0 === s.indexOf("url")),
									t.hasImage && (a = 0),
									t.pos());
							return (
								D(a) &&
									e &&
									((n.x = e[0] - a),
									(n.y = e[1] - a),
									i.crisp && (n.x = Math.floor(n.x))),
								a && (n.width = n.height = 2 * a),
								n
							);
						}),
						(B.prototype.pointAttribs = function (t, e) {
							var i = this.options.marker,
								o = t && t.options,
								r = (o && o.marker) || {},
								o = o && o.color,
								s = t && t.color,
								t = t && t.zone && t.zone.color,
								n = this.color,
								a = j(r.lineWidth, i.lineWidth),
								h = 1,
								n = o || t || s || n,
								o = r.fillColor || i.fillColor || n,
								t = r.lineColor || i.lineColor || n;
							return (
								(e = e || "normal") &&
									((s = i.states[e] || {}),
									(n = (r.states && r.states[e]) || {}),
									(a = j(
										n.lineWidth,
										s.lineWidth,
										a + j(n.lineWidthPlus, s.lineWidthPlus, 0)
									)),
									(o = n.fillColor || s.fillColor || o),
									(t = n.lineColor || s.lineColor || t),
									(h = j(n.opacity, s.opacity, h))),
								{ stroke: t, "stroke-width": a, fill: o, opacity: h }
							);
						}),
						(B.prototype.destroy = function (i) {
							var t,
								e,
								o,
								r = this,
								s = r.chart,
								n = /AppleWebKit\/533/.test(m.navigator.userAgent),
								a = r.data || [];
							for (
								O(r, "destroy", { keepEventsForUpdate: i }),
									this.removeEvents(i),
									(r.axisTypes || []).forEach(function (t) {
										(o = r[t]) &&
											o.series &&
											(S(o.series, r), (o.isDirty = o.forceRedraw = !0));
									}),
									r.legendItem && r.chart.legend.destroyItem(r),
									t = a.length;
								t--;

							)
								(e = a[t]) && e.destroy && e.destroy();
							r.clips &&
								r.clips.forEach(function (t) {
									return t.destroy();
								}),
								c.clearTimeout(r.animationTimeout),
								T(r, function (t, e) {
									t instanceof h &&
										!t.survive &&
										t[n && "group" === e ? "hide" : "destroy"]();
								}),
								s.hoverSeries === r && (s.hoverSeries = void 0),
								S(s.series, r),
								s.orderSeries(),
								T(r, function (t, e) {
									(i && "hcEvents" === e) || delete r[e];
								});
						}),
						(B.prototype.applyZones = function () {
							var i,
								o,
								r,
								s,
								n,
								a,
								h,
								l,
								c = this,
								d = this.chart,
								p = d.renderer,
								t = this.zones,
								u = this.clips || [],
								f = this.graph,
								g = this.area,
								m = Math.max(d.plotWidth, d.plotHeight),
								y = this[(this.zoneAxis || "y") + "Axis"],
								v = d.inverted,
								x = !1;
							t.length && (f || g) && y && void 0 !== y.min
								? ((s = y.reversed),
								  (n = y.horiz),
								  f && !this.showLine && f.hide(),
								  g && g.hide(),
								  (r = y.getExtremes()),
								  t.forEach(function (t, e) {
										(a = s
											? n
												? d.plotWidth
												: 0
											: (!n && y.toPixels(r.min)) || 0),
											(a = A(j(i, a), 0, m)),
											(i = A(
												Math.round(y.toPixels(j(t.value, r.max), !0) || 0),
												0,
												m
											)),
											x && (a = i = y.toPixels(r.max)),
											(h = Math.abs(a - i)),
											(l = Math.min(a, i)),
											(a = Math.max(a, i)),
											y.isXAxis
												? ((o = { x: v ? a : l, y: 0, width: h, height: m }),
												  n || (o.x = d.plotHeight - o.x))
												: ((o = { x: 0, y: v ? a : l, width: m, height: h }),
												  n && (o.y = d.plotWidth - o.y)),
											v &&
												p.isVML &&
												(o = y.isXAxis
													? {
															x: 0,
															y: s ? l : a,
															height: o.width,
															width: d.chartWidth,
													  }
													: {
															x: o.y - d.plotLeft - d.spacingBox.x,
															y: 0,
															width: o.height,
															height: d.chartHeight,
													  }),
											u[e] ? u[e].animate(o) : (u[e] = p.clipRect(o)),
											(h = c["zone-area-" + e]),
											(l = c["zone-graph-" + e]),
											f && l && l.clip(u[e]),
											g && h && h.clip(u[e]),
											(x = t.value > r.max),
											c.resetZones && 0 === i && (i = void 0);
								  }),
								  (this.clips = u))
								: c.visible && (f && f.show(), g && g.show());
						}),
						(B.prototype.plotGroup = function (t, e, i, o, r) {
							var s = this[t],
								n = !s,
								i = { visibility: i, zIndex: o || 0.1 };
							return (
								void 0 === this.opacity ||
									this.chart.styledMode ||
									"inactive" === this.state ||
									(i.opacity = this.opacity),
								n && (this[t] = s = this.chart.renderer.g().add(r)),
								s.addClass(
									"highcharts-" +
										e +
										" highcharts-series-" +
										this.index +
										" highcharts-" +
										this.type +
										"-series " +
										(L(this.colorIndex)
											? "highcharts-color-" + this.colorIndex + " "
											: "") +
										(this.options.className || "") +
										(s.hasClass("highcharts-tracker")
											? " highcharts-tracker"
											: ""),
									!0
								),
								s.attr(i)[n ? "attr" : "animate"](this.getPlotBox(e)),
								s
							);
						}),
						(B.prototype.getPlotBox = function (t) {
							var e = this.xAxis,
								i = this.yAxis,
								o = this.chart,
								t =
									o.inverted &&
									!o.polar &&
									e &&
									!1 !== this.invertible &&
									"series" === t;
							return (
								o.inverted && ((e = i), (i = this.xAxis)),
								{
									translateX: e ? e.left : o.plotLeft,
									translateY: i ? i.top : o.plotTop,
									rotation: t ? 90 : 0,
									rotationOriginX: t ? (e.len - i.len) / 2 : 0,
									rotationOriginY: t ? (e.len + i.len) / 2 : 0,
									scaleX: t ? -1 : 1,
									scaleY: 1,
								}
							);
						}),
						(B.prototype.removeEvents = function (t) {
							t || N(this),
								this.eventsToUnbind.length &&
									(this.eventsToUnbind.forEach(function (t) {
										t();
									}),
									(this.eventsToUnbind.length = 0));
						}),
						(B.prototype.render = function () {
							var t = this,
								e = t.chart,
								i = t.options,
								o = d(i.animation),
								r = t.visible ? "inherit" : "hidden",
								s = i.zIndex,
								n = t.hasRendered,
								a = e.seriesGroup,
								e =
									(e.inverted,
									!t.finishedAnimating && e.renderer.isSVG ? o.duration : 0);
							O(this, "render"), t.plotGroup("group", "series", r, s, a);
							(t.markerGroup = t.plotGroup("markerGroup", "markers", r, s, a)),
								!1 !== i.clip && t.setClip(),
								t.animate && e && t.animate(!0),
								t.drawGraph && (t.drawGraph(), t.applyZones()),
								t.visible && t.drawPoints(),
								t.drawDataLabels && t.drawDataLabels(),
								t.redrawPoints && t.redrawPoints(),
								t.drawTracker &&
									!1 !== t.options.enableMouseTracking &&
									t.drawTracker(),
								t.animate && e && t.animate(),
								n ||
									(e && o.defer && (e += o.defer),
									(t.animationTimeout = I(function () {
										t.afterAnimate();
									}, e || 0))),
								(t.isDirty = !1),
								(t.hasRendered = !0),
								O(t, "afterRender");
						}),
						(B.prototype.redraw = function () {
							var t = this.isDirty || this.isDirtyData;
							this.translate(), this.render(), t && delete this.kdTree;
						}),
						(B.prototype.searchPoint = function (t, e) {
							var i = this.xAxis,
								o = this.yAxis,
								r = this.chart.inverted;
							return this.searchKDTree(
								{
									clientX: r ? i.len - t.chartY + i.pos : t.chartX - i.pos,
									plotY: r ? o.len - t.chartX + o.pos : t.chartY - o.pos,
								},
								e,
								t
							);
						}),
						(B.prototype.buildKDTree = function (t) {
							this.buildingKdTree = !0;
							var n = this,
								e = -1 < n.options.findNearestPointBy.indexOf("y") ? 2 : 1;
							delete n.kdTree,
								I(
									function () {
										(n.kdTree = (function t(e, i, o) {
											var r,
												s = e && e.length;
											if (s)
												return (
													(r = n.kdAxisArray[i % o]),
													e.sort(function (t, e) {
														return t[r] - e[r];
													}),
													{
														point: e[(s = Math.floor(s / 2))],
														left: t(e.slice(0, s), i + 1, o),
														right: t(e.slice(s + 1), i + 1, o),
													}
												);
										})(n.getValidPoints(null, !n.directTouch), e, e)),
											(n.buildingKdTree = !1);
									},
									n.options.kdNow || (t && "touchstart" === t.type) ? 0 : 1
								);
						}),
						(B.prototype.searchKDTree = function (t, e, i) {
							var c = this,
								d = this.kdAxisArray[0],
								p = this.kdAxisArray[1],
								u = e ? "distX" : "dist",
								e = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
							function f(t, e, i, o) {
								var r = e.point,
									s = c.kdAxisArray[i % o],
									n = r,
									a =
										((h = r),
										(a =
											((l =
												L((a = t)[d]) && L(h[d])
													? Math.pow(a[d] - h[d], 2)
													: null) || 0) +
											((L(a[p]) && L(h[p]) ? Math.pow(a[p] - h[p], 2) : null) ||
												0)),
										(h.dist = L(a) ? Math.sqrt(a) : Number.MAX_VALUE),
										(h.distX = L(l) ? Math.sqrt(l) : Number.MAX_VALUE),
										t[s] - r[s]),
									h = a < 0 ? "left" : "right",
									l = a < 0 ? "right" : "left";
								return (
									e[h] && (n = (s = f(t, e[h], i + 1, o))[u] < n[u] ? s : r),
									(n =
										e[l] && Math.sqrt(a * a) < n[u]
											? (h = f(t, e[l], i + 1, o))[u] < n[u]
												? h
												: n
											: n)
								);
							}
							if (
								(this.kdTree || this.buildingKdTree || this.buildKDTree(i),
								this.kdTree)
							)
								return f(t, this.kdTree, e, e);
						}),
						(B.prototype.pointPlacementToXValue = function () {
							var t = this.options,
								e = t.pointPlacement,
								t = t.pointRange,
								i = this.xAxis;
							return (
								"between" === e && (e = i.reversed ? -0.5 : 0.5),
								D(e) ? e * (t || i.pointRange) : 0
							);
						}),
						(B.prototype.isPointInside = function (t) {
							var e = this.chart,
								i = this.xAxis,
								o = this.yAxis;
							return (
								void 0 !== t.plotY &&
								void 0 !== t.plotX &&
								0 <= t.plotY &&
								t.plotY <= (o ? o.len : e.plotHeight) &&
								0 <= t.plotX &&
								t.plotX <= (i ? i.len : e.plotWidth)
							);
						}),
						(B.prototype.drawTracker = function () {
							function e(t) {
								s.hoverSeries !== i && i.onMouseOver();
							}
							var i = this,
								o = i.options,
								t = o.trackByArea,
								r = [].concat(t ? i.areaPath : i.graphPath),
								s = i.chart,
								n = s.pointer,
								a = s.renderer,
								h = s.options.tooltip.snap,
								l = i.tracker,
								c = "rgba(192,192,192," + (g ? 1e-4 : 0.002) + ")";
							l
								? l.attr({ d: r })
								: i.graph &&
								  ((i.tracker = a
										.path(r)
										.attr({
											visibility: i.visible ? "inherit" : "hidden",
											zIndex: 2,
										})
										.addClass(
											t ? "highcharts-tracker-area" : "highcharts-tracker-line"
										)
										.add(i.group)),
								  s.styledMode ||
										i.tracker.attr({
											"stroke-linecap": "round",
											"stroke-linejoin": "round",
											stroke: c,
											fill: t ? c : "none",
											"stroke-width": i.graph.strokeWidth() + (t ? 0 : 2 * h),
										}),
								  [i.tracker, i.markerGroup, i.dataLabelsGroup].forEach(
										function (t) {
											t &&
												(t
													.addClass("highcharts-tracker")
													.on("mouseover", e)
													.on("mouseout", function (t) {
														n.onTrackerMouseOut(t);
													}),
												o.cursor &&
													!s.styledMode &&
													t.css({ cursor: o.cursor }),
												f && t.on("touchstart", e));
										}
								  )),
								O(this, "afterDrawTracker");
						}),
						(B.prototype.addPoint = function (t, e, i, o, r) {
							var s,
								n = this,
								a = n.options,
								h = n.data,
								l = n.chart,
								c = n.xAxis,
								c = c && c.hasNames && c.names,
								d = a.data,
								p = n.xData,
								u = ((e = j(e, !0)), { series: n }),
								f = (n.pointClass.prototype.applyOptions.apply(u, [t]), u.x),
								g = p.length;
							if (n.requireSorting && f < p[g - 1])
								for (s = !0; g && p[g - 1] > f; ) g--;
							n.updateParallelArrays(u, "splice", g, 0, 0),
								n.updateParallelArrays(u, g),
								c && u.name && (c[f] = u.name),
								d.splice(g, 0, t),
								(s || n.processedData) &&
									(n.data.splice(g, 0, null), n.processData()),
								"point" === a.legendType && n.generatePoints(),
								i &&
									(h[0] && h[0].remove
										? h[0].remove(!1)
										: (h.shift(),
										  n.updateParallelArrays(u, "shift"),
										  d.shift())),
								!1 !== r && O(n, "addPoint", { point: u }),
								(n.isDirty = !0),
								(n.isDirtyData = !0),
								e && l.redraw(o);
						}),
						(B.prototype.removePoint = function (t, e, i) {
							function o() {
								a && a.length === s.length && a.splice(t, 1),
									s.splice(t, 1),
									r.options.data.splice(t, 1),
									r.updateParallelArrays(n || { series: r }, "splice", t, 1),
									n && n.destroy(),
									(r.isDirty = !0),
									(r.isDirtyData = !0),
									e && h.redraw();
							}
							var r = this,
								s = r.data,
								n = s[t],
								a = r.points,
								h = r.chart;
							p(i, h),
								(e = j(e, !0)),
								n ? n.firePointEvent("remove", null, o) : o();
						}),
						(B.prototype.remove = function (t, e, i, o) {
							var r = this,
								s = r.chart;
							function n() {
								r.destroy(o),
									(s.isDirtyLegend = s.isDirtyBox = !0),
									s.linkSeries(),
									j(t, !0) && s.redraw(e);
							}
							!1 !== i ? O(r, "remove", null, n) : n();
						}),
						(B.prototype.update = function (t, e) {
							(t = b(t, this.userOptions)), O(this, "update", { options: t });
							var i,
								o,
								r = this,
								s = r.chart,
								n = r.userOptions,
								a = r.initialType || r.type,
								h = s.options.plotOptions,
								l = v[a].prototype,
								c = r.finishedAnimating && { animation: !1 },
								d = {},
								p = ["eventOptions", "navigatorSeries", "baseSeries"],
								u = t.type || n.type || s.options.chart.type,
								f = !(
									this.hasDerivedData ||
									(u && u !== this.type) ||
									void 0 !== t.pointStart ||
									void 0 !== t.pointInterval ||
									void 0 !== t.relativeXValue ||
									t.joinBy ||
									t.mapData ||
									r.hasOptionChanged("dataGrouping") ||
									r.hasOptionChanged("pointStart") ||
									r.hasOptionChanged("pointInterval") ||
									r.hasOptionChanged("pointIntervalUnit") ||
									r.hasOptionChanged("keys")
								),
								u = u || a,
								c =
									(f &&
										(p.push(
											"data",
											"isDirtyData",
											"points",
											"processedData",
											"processedXData",
											"processedYData",
											"xIncrement",
											"cropped",
											"_hasPointMarkers",
											"_hasPointLabels",
											"clips",
											"nodes",
											"layout",
											"level",
											"mapMap",
											"mapData",
											"minY",
											"maxY",
											"minX",
											"maxX"
										),
										!1 !== t.visible && p.push("area", "graph"),
										r.parallelArrays.forEach(function (t) {
											p.push(t + "Data");
										}),
										t.data &&
											(t.dataSorting && k(r.options.dataSorting, t.dataSorting),
											this.setData(t.data, !1))),
									(t = w(
										n,
										c,
										{
											index: (void 0 === n.index ? r : n).index,
											pointStart: j(
												h && h.series && h.series.pointStart,
												n.pointStart,
												r.xData[0]
											),
										},
										!f && { data: r.options.data },
										t
									)),
									f && t.data && (t.data = r.options.data),
									(p = [
										"group",
										"markerGroup",
										"dataLabelsGroup",
										"transformGroup",
										"shadowGroup",
									].concat(p)).forEach(function (t) {
										(p[t] = r[t]), delete r[t];
									}),
									!1);
							if (v[u]) {
								if (((c = u !== r.type), r.remove(!1, !1, !1, !0), c))
									if (Object.setPrototypeOf)
										Object.setPrototypeOf(r, v[u].prototype);
									else {
										var h =
											Object.hasOwnProperty.call(r, "hcEvents") && r.hcEvents;
										for (i in l) r[i] = void 0;
										k(r, v[u].prototype),
											h ? (r.hcEvents = h) : delete r.hcEvents;
									}
							} else C(17, !0, s, { missingModuleFor: u });
							if (
								(p.forEach(function (t) {
									r[t] = p[t];
								}),
								r.init(s, t),
								f && this.points)
							) {
								!1 === (o = r.options).visible
									? ((d.graphic = 1), (d.dataLabel = 1))
									: r._hasPointLabels ||
									  ((l = o.marker),
									  (h = o.dataLabels),
									  (u = n.marker || {}),
									  !l ||
											(!1 !== l.enabled &&
												u.symbol === l.symbol &&
												u.height === l.height &&
												u.width === l.width) ||
											(d.graphic = 1),
									  h && !1 === h.enabled && (d.dataLabel = 1));
								for (var g = 0, m = this.points; g < m.length; g++) {
									var y = m[g];
									y &&
										y.series &&
										(y.resolveColor(),
										Object.keys(d).length && y.destroyElements(d),
										!1 === o.showInLegend &&
											y.legendItem &&
											s.legend.destroyItem(y));
								}
							}
							(r.initialType = a),
								s.linkSeries(),
								c && r.linkedSeries.length && (r.isDirtyData = !0),
								O(this, "afterUpdate"),
								j(e, !0) && s.redraw(f && void 0);
						}),
						(B.prototype.setName = function (t) {
							(this.name = this.options.name = this.userOptions.name = t),
								(this.chart.isDirtyLegend = !0);
						}),
						(B.prototype.hasOptionChanged = function (t) {
							var e = this.chart,
								i = this.options[t],
								e = e.options.plotOptions,
								o = this.userOptions[t];
							return o
								? i !== o
								: i !==
										j(
											e && e[this.type] && e[this.type][t],
											e && e.series && e.series[t],
											i
										);
						}),
						(B.prototype.onMouseOver = function () {
							var t = this.chart,
								e = t.hoverSeries;
							t.pointer.setHoverChartIndex(),
								e && e !== this && e.onMouseOut(),
								this.options.events.mouseOver && O(this, "mouseOver"),
								this.setState("hover"),
								(t.hoverSeries = this);
						}),
						(B.prototype.onMouseOut = function () {
							var t = this.options,
								e = this.chart,
								i = e.tooltip,
								o = e.hoverPoint;
							(e.hoverSeries = null),
								o && o.onMouseOut(),
								this && t.events.mouseOut && O(this, "mouseOut"),
								!i ||
									this.stickyTracking ||
									(i.shared && !this.noSharedTooltip) ||
									i.hide(),
								e.series.forEach(function (t) {
									t.setState("", !0);
								});
						}),
						(B.prototype.setState = function (e, t) {
							var i,
								o = this,
								r = o.options,
								s = o.graph,
								n = r.inactiveOtherPoints,
								a = r.states,
								h = j(
									a[e || "normal"] && a[e || "normal"].animation,
									o.chart.options.chart.animation
								),
								l = r.lineWidth,
								c = 0,
								d = r.opacity;
							if (
								((e = e || ""),
								o.state !== e &&
									([o.group, o.markerGroup, o.dataLabelsGroup].forEach(
										function (t) {
											t &&
												(o.state &&
													t.removeClass("highcharts-series-" + o.state),
												e && t.addClass("highcharts-series-" + e));
										}
									),
									(o.state = e),
									!o.chart.styledMode))
							) {
								if (a[e] && !1 === a[e].enabled) return;
								if (
									(e &&
										((l = a[e].lineWidth || l + (a[e].lineWidthPlus || 0)),
										(d = j(a[e].opacity, d))),
									s && !s.dashstyle && D(l))
								)
									for (
										s.animate((i = { "stroke-width": l }), h);
										o["zone-graph-" + c];

									)
										o["zone-graph-" + c].animate(i, h), (c += 1);
								n ||
									[
										o.group,
										o.markerGroup,
										o.dataLabelsGroup,
										o.labelBySeries,
									].forEach(function (t) {
										t && t.animate({ opacity: d }, h);
									});
							}
							t && n && o.points && o.setAllPointsToState(e || void 0);
						}),
						(B.prototype.setAllPointsToState = function (e) {
							this.points.forEach(function (t) {
								t.setState && t.setState(e);
							});
						}),
						(B.prototype.setVisible = function (e, t) {
							var i = this,
								o = i.chart,
								r = o.options.chart.ignoreHiddenSeries,
								s = i.visible,
								n =
									((i.visible =
										e =
										i.options.visible =
										i.userOptions.visible =
											void 0 === e ? !s : e),
									e ? "show" : "hide");
							[
								"group",
								"dataLabelsGroup",
								"markerGroup",
								"tracker",
								"tt",
							].forEach(function (t) {
								i[t] && i[t][n]();
							}),
								(o.hoverSeries !== i &&
									(o.hoverPoint && o.hoverPoint.series) !== i) ||
									i.onMouseOut(),
								i.legendItem && o.legend.colorizeItem(i, e),
								(i.isDirty = !0),
								i.options.stacking &&
									o.series.forEach(function (t) {
										t.options.stacking && t.visible && (t.isDirty = !0);
									}),
								i.linkedSeries.forEach(function (t) {
									t.setVisible(e, !1);
								}),
								r && (o.isDirtyBox = !0),
								O(i, n),
								!1 !== t && o.redraw();
						}),
						(B.prototype.show = function () {
							this.setVisible(!0);
						}),
						(B.prototype.hide = function () {
							this.setVisible(!1);
						}),
						(B.prototype.select = function (t) {
							(this.selected =
								t =
								this.options.selected =
									void 0 === t ? !this.selected : t),
								this.checkbox && (this.checkbox.checked = t),
								O(this, t ? "select" : "unselect");
						}),
						(B.prototype.shouldShowTooltip = function (t, e, i) {
							return (
								((i = void 0 === i ? {} : i).series = this),
								(i.visiblePlotOnly = !0),
								this.chart.isInsidePlot(t, e, i)
							);
						}),
						(B.defaultOptions = s),
						(B.types = n.seriesTypes),
						(B.registerType = n.registerSeriesType),
						B);
				function B() {
					(this._i = void 0),
						(this.chart = void 0),
						(this.data = void 0),
						(this.eventOptions = void 0),
						(this.eventsToUnbind = void 0),
						(this.index = void 0),
						(this.linkedSeries = void 0),
						(this.options = void 0),
						(this.points = void 0),
						(this.processedXData = void 0),
						(this.processedYData = void 0),
						(this.tooltipOptions = void 0),
						(this.userOptions = void 0),
						(this.xAxis = void 0),
						(this.yAxis = void 0),
						(this.zones = void 0);
				}
				return (
					k(t.prototype, {
						axisTypes: ["xAxis", "yAxis"],
						coll: "series",
						colorCounter: 0,
						cropShoulder: 1,
						directTouch: !1,
						drawLegendSymbol: r.drawLineMarker,
						isCartesian: !0,
						kdAxisArray: ["clientX", "plotY"],
						parallelArrays: ["x", "y"],
						pointClass: l,
						requireSorting: !0,
						sorted: !0,
					}),
					(n.series = t)
				);
			}
		),
		e(
			t,
			"Extensions/ScrollablePlotArea.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Axis/Axis.js"],
				t["Core/Chart/Chart.js"],
				t["Core/Series/Series.js"],
				t["Core/Renderer/RendererRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, s, e, i, n, o) {
				var a = t.stop,
					h = o.addEvent,
					l = o.createElement,
					c = o.defined,
					d = o.merge,
					p = o.pick;
				h(e, "afterSetChartSize", function (t) {
					var r,
						e = this.options.chart.scrollablePlotArea,
						i = e && e.minWidth,
						e = e && e.minHeight;
					this.renderer.forExport ||
						(i
							? ((this.scrollablePixelsX = i =
									Math.max(0, i - this.chartWidth)),
							  i &&
									((this.scrollablePlotBox = this.renderer.scrollablePlotBox =
										d(this.plotBox)),
									(this.plotBox.width = this.plotWidth += i),
									this.inverted
										? (this.clipBox.height += i)
										: (this.clipBox.width += i),
									(r = { 1: { name: "right", value: i } })))
							: e &&
							  ((this.scrollablePixelsY = i =
									Math.max(0, e - this.chartHeight)),
							  c(i) &&
									((this.scrollablePlotBox = this.renderer.scrollablePlotBox =
										d(this.plotBox)),
									(this.plotBox.height = this.plotHeight += i),
									this.inverted
										? (this.clipBox.width += i)
										: (this.clipBox.height += i),
									(r = { 2: { name: "bottom", value: i } }))),
						r &&
							!t.skipAxes &&
							this.axes.forEach(function (o) {
								r[o.side]
									? (o.getPlotLinePath = function () {
											var t = r[o.side].name,
												e = r[o.side].value,
												i = this[t];
											return (
												(this[t] = i - e),
												(e = s.prototype.getPlotLinePath.apply(
													this,
													arguments
												)),
												(this[t] = i),
												e
											);
									  })
									: (o.setAxisSize(), o.setAxisTranslation());
							}));
				}),
					h(e, "render", function () {
						this.scrollablePixelsX || this.scrollablePixelsY
							? (this.setUpScrolling && this.setUpScrolling(),
							  this.applyFixed())
							: this.fixedDiv && this.applyFixed();
					}),
					(e.prototype.setUpScrolling = function () {
						var t,
							e = this,
							i = {
								WebkitOverflowScrolling: "touch",
								overflowX: "hidden",
								overflowY: "hidden",
							};
						this.scrollablePixelsX && (i.overflowX = "auto"),
							this.scrollablePixelsY && (i.overflowY = "auto"),
							(this.scrollingParent = l(
								"div",
								{ className: "highcharts-scrolling-parent" },
								{ position: "relative" },
								this.renderTo
							)),
							(this.scrollingContainer = l(
								"div",
								{ className: "highcharts-scrolling" },
								i,
								this.scrollingParent
							)),
							h(this.scrollingContainer, "scroll", function () {
								e.pointer &&
									(delete e.pointer.chartPosition,
									e.hoverPoint && (t = e.hoverPoint),
									e.pointer.runPointActions(void 0, t, !0));
							}),
							(this.innerContainer = l(
								"div",
								{ className: "highcharts-inner-container" },
								null,
								this.scrollingContainer
							)),
							this.innerContainer.appendChild(this.container),
							(this.setUpScrolling = null);
					}),
					(e.prototype.moveFixedElements = function () {
						var t,
							e = this.container,
							i = this.fixedRenderer,
							o = [
								".highcharts-breadcrumbs-group",
								".highcharts-contextbutton",
								".highcharts-credits",
								".highcharts-legend",
								".highcharts-legend-checkbox",
								".highcharts-navigator-series",
								".highcharts-navigator-xaxis",
								".highcharts-navigator-yaxis",
								".highcharts-navigator",
								".highcharts-reset-zoom",
								".highcharts-drillup-button",
								".highcharts-scrollbar",
								".highcharts-subtitle",
								".highcharts-title",
							];
						this.scrollablePixelsX && !this.inverted
							? (t = ".highcharts-yaxis")
							: (this.scrollablePixelsX && this.inverted) ||
							  (this.scrollablePixelsY && !this.inverted)
							? (t = ".highcharts-xaxis")
							: this.scrollablePixelsY &&
							  this.inverted &&
							  (t = ".highcharts-yaxis"),
							t &&
								o.push(
									t + ":not(.highcharts-radial-axis)",
									t + "-labels:not(.highcharts-radial-axis-labels)"
								),
							o.forEach(function (t) {
								[].forEach.call(e.querySelectorAll(t), function (t) {
									(t.namespaceURI === i.SVG_NS
										? i.box
										: i.box.parentNode
									).appendChild(t),
										(t.style.pointerEvents = "auto");
								});
							});
					}),
					(e.prototype.applyFixed = function () {
						var t = !this.fixedDiv,
							e = this.options.chart,
							i = e.scrollablePlotArea,
							o = n.getRendererType(),
							o =
								(t
									? ((this.fixedDiv = l(
											"div",
											{ className: "highcharts-fixed" },
											{
												position: "absolute",
												overflow: "hidden",
												pointerEvents: "none",
												zIndex: ((e.style && e.style.zIndex) || 0) + 2,
												top: 0,
											},
											null,
											!0
									  )),
									  this.scrollingContainer &&
											this.scrollingContainer.parentNode.insertBefore(
												this.fixedDiv,
												this.scrollingContainer
											),
									  (this.renderTo.style.overflow = "visible"),
									  (this.fixedRenderer = e =
											new o(
												this.fixedDiv,
												this.chartWidth,
												this.chartHeight,
												this.options.chart.style
											)),
									  (this.scrollableMask = e
											.path()
											.attr({
												fill: this.options.chart.backgroundColor || "#fff",
												"fill-opacity": p(i.opacity, 0.85),
												zIndex: -1,
											})
											.addClass("highcharts-scrollable-mask")
											.add()),
									  h(this, "afterShowResetZoom", this.moveFixedElements),
									  h(this, "afterApplyDrilldown", this.moveFixedElements),
									  h(this, "afterLayOutTitles", this.moveFixedElements))
									: this.fixedRenderer.setSize(
											this.chartWidth,
											this.chartHeight
									  ),
								(this.scrollableDirty || t) &&
									((this.scrollableDirty = !1), this.moveFixedElements()),
								(o = this.chartWidth + (this.scrollablePixelsX || 0)),
								(e = this.chartHeight + (this.scrollablePixelsY || 0)),
								a(this.container),
								(this.container.style.width = o + "px"),
								(this.container.style.height = e + "px"),
								this.renderer.boxWrapper.attr({
									width: o,
									height: e,
									viewBox: [0, 0, o, e].join(" "),
								}),
								this.chartBackground.attr({ width: o, height: e }),
								(this.scrollingContainer.style.height =
									this.chartHeight + "px"),
								t &&
									(i.scrollPositionX &&
										(this.scrollingContainer.scrollLeft =
											this.scrollablePixelsX * i.scrollPositionX),
									i.scrollPositionY &&
										(this.scrollingContainer.scrollTop =
											this.scrollablePixelsY * i.scrollPositionY)),
								this.axisOffset),
							e = this.plotTop - o[0] - 1,
							t = this.plotLeft - o[3] - 1,
							i = this.plotTop + this.plotHeight + o[2] + 1,
							o = this.plotLeft + this.plotWidth + o[1] + 1,
							r =
								this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
							s =
								this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0),
							e = this.scrollablePixelsX
								? [
										["M", 0, e],
										["L", this.plotLeft - 1, e],
										["L", this.plotLeft - 1, i],
										["L", 0, i],
										["Z"],
										["M", r, e],
										["L", this.chartWidth, e],
										["L", this.chartWidth, i],
										["L", r, i],
										["Z"],
								  ]
								: this.scrollablePixelsY
								? [
										["M", t, 0],
										["L", t, this.plotTop - 1],
										["L", o, this.plotTop - 1],
										["L", o, 0],
										["Z"],
										["M", t, s],
										["L", t, this.chartHeight],
										["L", o, this.chartHeight],
										["L", o, s],
										["Z"],
								  ]
								: [["M", 0, 0]];
						"adjustHeight" !== this.redrawTrigger &&
							this.scrollableMask.attr({ d: e });
					}),
					h(s, "afterInit", function () {
						this.chart.scrollableDirty = !0;
					}),
					h(i, "show", function () {
						this.chart.scrollableDirty = !0;
					});
			}
		),
		e(
			t,
			"Core/Axis/Stacking/StackItem.js",
			[
				t["Core/FormatUtilities.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var r = t.format,
					p = e.series,
					o = i.destroyObjectProperties,
					u = i.pick,
					f = i.isNumber;
				function s(t, e, i, o, r) {
					var s = t.chart.inverted,
						n = t.reversed,
						t = ((this.axis = t), (this.isNegative = !!i != !!n));
					(this.options = e = e || {}),
						(this.x = o),
						(this.total = null),
						(this.cumulative = null),
						(this.points = {}),
						(this.hasValidPoints = !1),
						(this.stack = r),
						(this.leftCliff = 0),
						(this.rightCliff = 0),
						(this.alignOptions = {
							align: e.align || (s ? (t ? "left" : "right") : "center"),
							verticalAlign:
								e.verticalAlign || (s ? "middle" : t ? "bottom" : "top"),
							y: e.y,
							x: e.x,
						}),
						(this.textAlign =
							e.textAlign || (s ? (t ? "right" : "left") : "center"));
				}
				return (
					(s.prototype.destroy = function () {
						o(this, this.axis);
					}),
					(s.prototype.render = function (t) {
						var e = this.axis.chart,
							i = this.options,
							o = i.format,
							o = o ? r(o, this, e) : i.formatter.call(this);
						this.label
							? this.label.attr({ text: o, visibility: "hidden" })
							: ((this.label = e.renderer.label(
									o,
									null,
									void 0,
									i.shape,
									void 0,
									void 0,
									i.useHTML,
									!1,
									"stack-labels"
							  )),
							  (o = {
									r: i.borderRadius || 0,
									text: o,
									padding: u(i.padding, 5),
									visibility: "hidden",
							  }),
							  e.styledMode ||
									((o.fill = i.backgroundColor),
									(o.stroke = i.borderColor),
									(o["stroke-width"] = i.borderWidth),
									this.label.css(i.style || {})),
							  this.label.attr(o),
							  this.label.added || this.label.add(t)),
							(this.label.labelrank = e.plotSizeY);
					}),
					(s.prototype.setOffset = function (t, e, i, o, r, s) {
						var n = this.alignOptions,
							a = this.axis,
							h = this.label,
							l = this.options,
							c = this.textAlign,
							d = a.chart,
							t = this.getStackBox({
								xOffset: t,
								width: e,
								boxBottom: i,
								boxTop: o,
								defaultX: r,
								xAxis: s,
							}),
							e = n.verticalAlign;
						h &&
							t &&
							((i = h.getBBox()),
							(o = h.padding),
							(r = "justify" === u(l.overflow, "justify")),
							(s = void 0),
							(n.x = l.x || 0),
							(n.y = l.y || 0),
							(c = (e = this.adjustStackPosition({
								labelBox: i,
								verticalAlign: e,
								textAlign: c,
							})).x),
							(e = e.y),
							(t.x -= c),
							(t.y -= e),
							h.align(n, !1, t),
							(r = (s = d.isInsidePlot(
								h.alignAttr.x + n.x + c,
								h.alignAttr.y + n.y + e
							))
								? r
								: !1) &&
								p.prototype.justifyDataLabel.call(a, h, n, h.alignAttr, i, t),
							h.attr({
								x: h.alignAttr.x,
								y: h.alignAttr.y,
								rotation: l.rotation,
								rotationOriginX: i.width / 2,
								rotationOriginY: i.height / 2,
							}),
							h[
								(s = u(!r && l.crop, !0)
									? f(h.x) &&
									  f(h.y) &&
									  d.isInsidePlot(h.x - o + h.width, h.y) &&
									  d.isInsidePlot(h.x + o, h.y)
									: s)
									? "show"
									: "hide"
							]());
					}),
					(s.prototype.adjustStackPosition = function (t) {
						var e = t.labelBox,
							i = t.verticalAlign,
							t = t.textAlign,
							o = {
								bottom: 0,
								middle: 1,
								top: 2,
								right: 1,
								center: 0,
								left: -1,
							};
						return {
							x: e.width / 2 + (e.width / 2) * o[t],
							y: (e.height / 2) * o[i],
						};
					}),
					(s.prototype.getStackBox = function (t) {
						var e = this.axis,
							i = e.chart,
							o = t.boxTop,
							r = t.defaultX,
							s = t.xOffset,
							n = t.width,
							a = t.boxBottom,
							o = e.stacking.usePercentage ? 100 : u(o, this.total, 0),
							o = e.toPixels(o),
							t = t.xAxis || i.xAxis[0],
							r = u(r, t.toPixels(this.x)) + s,
							t = e.toPixels(a || 0),
							s = Math.abs(o - t),
							e = i.inverted,
							a = this.isNegative;
						return e
							? {
									x: (a ? o : o - s) - i.plotLeft,
									y: r - i.plotTop,
									width: s,
									height: n,
							  }
							: {
									x: r - i.plotLeft,
									y: (a ? o - s : o) - i.plotTop,
									width: n,
									height: s,
							  };
					}),
					s
				);
			}
		),
		e(
			t,
			"Core/Axis/Stacking/StackingAxis.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Axis/Axis.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Axis/Stacking/StackItem.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, w, o) {
				var s = t.getDeferredAnimation,
					r = i.series.prototype,
					n = o.addEvent,
					T = o.correctFloat,
					A = o.defined,
					a = o.destroyObjectProperties,
					h = o.fireEvent,
					P = o.isArray,
					l = o.isNumber,
					c = o.objectEach,
					L = o.pick;
				function d() {
					var i = this,
						o = i.inverted;
					i.yAxis.forEach(function (t) {
						t.stacking &&
							t.stacking.stacks &&
							t.hasVisibleSeries &&
							(t.stacking.oldStacks = t.stacking.stacks);
					}),
						i.series.forEach(function (t) {
							var e = (t.xAxis && t.xAxis.options) || {};
							!t.options.stacking ||
								(!0 !== t.visible &&
									!1 !== i.options.chart.ignoreHiddenSeries) ||
								(t.stackKey = [
									t.type,
									L(t.options.stack, ""),
									o ? e.top : e.left,
									o ? e.height : e.width,
								].join(","));
						});
				}
				function p() {
					var i,
						t = this.stacking;
					t &&
						((i = t.stacks),
						c(i, function (t, e) {
							a(t), (i[e] = null);
						}),
						t && t.stackTotalGroup && t.stackTotalGroup.destroy());
				}
				function u() {
					"yAxis" !== this.coll ||
						this.stacking ||
						(this.stacking = new S(this));
				}
				function f(t, e, i, o) {
					return (
						!A(t) || t.x !== e || (o && t.stackKey !== o)
							? (t = { x: e, index: 0, key: o, stackKey: o })
							: t.index++,
						(t.key = [i, e, t.index].join(",")),
						t
					);
				}
				function g() {
					var r,
						s = this,
						t = s.yAxis,
						e = s.stackKey,
						n = t.stacking.stacks,
						a = s.processedXData,
						t = s.options.stacking,
						h = s[t + "Stacker"];
					h &&
						[e, "-" + e].forEach(function (t) {
							for (var e, i, o = a.length; o--; )
								(e = a[o]),
									(r = s.getStackIndicator(r, e, s.index, t)),
									(i = (e = n[t] && n[t][e]) && e.points[r.key]) &&
										h.call(s, i, e, o);
						});
				}
				function m(t, e, i) {
					e = e.total ? 100 / e.total : 0;
					(t[0] = T(t[0] * e)),
						(t[1] = T(t[1] * e)),
						(this.stackedYData[i] = t[1]);
				}
				function y() {
					var i = this.yAxis.stacking;
					this.options.centerInCategory &&
					(this.is("column") || this.is("columnrange")) &&
					!this.options.stacking &&
					1 < this.chart.series.length
						? r.setStackedPoints.call(this, "group")
						: i &&
						  c(i.stacks, function (t, e) {
								"group" === e.slice(-5) &&
									(c(t, function (t) {
										return t.destroy();
									}),
									delete i.stacks[e]);
						  });
				}
				function v(t) {
					var e = this.chart,
						i = t || this.options.stacking;
					if (
						i &&
						(!0 === this.visible || !1 === e.options.chart.ignoreHiddenSeries)
					) {
						var o,
							r,
							s,
							n,
							a,
							h,
							l,
							c = this,
							d = c.processedXData,
							p = c.processedYData,
							u = [],
							f = p.length,
							g = c.options,
							m = g.threshold,
							y = L(g.startFromThreshold && m, 0),
							v = g.stack,
							x = t ? "" + c.type + ",".concat(i) : c.stackKey,
							b = "-" + x,
							S = c.negStacks,
							k = "group" === i ? e.yAxis[0] : c.yAxis,
							C = k.stacking.stacks,
							M = k.stacking.oldStacks;
						for (k.stacking.stacksTouched += 1, a = 0; a < f; a++)
							(h = d[a]),
								(l = p[a]),
								(n = (o = c.getStackIndicator(o, h, c.index)).key),
								C[(s = (r = S && l < (y ? 0 : m)) ? b : x)] || (C[s] = {}),
								C[s][h] ||
									(M[s] && M[s][h]
										? ((C[s][h] = M[s][h]), (C[s][h].total = null))
										: (C[s][h] = new w(k, k.options.stackLabels, !!r, h, v))),
								(s = C[s][h]),
								null !== l
									? ((s.points[n] = s.points[c.index] = [L(s.cumulative, y)]),
									  A(s.cumulative) || (s.base = n),
									  (s.touched = k.stacking.stacksTouched),
									  0 < o.index &&
											!1 === c.singleStacks &&
											(s.points[n][0] = s.points[c.index + "," + h + ",0"][0]))
									: (s.points[n] = s.points[c.index] = null),
								"percent" === i
									? ((r = r ? x : b),
									  S && C[r] && C[r][h]
											? ((r = C[r][h]),
											  (s.total = r.total =
													Math.max(r.total, s.total) + Math.abs(l) || 0))
											: (s.total = T(s.total + (Math.abs(l) || 0))))
									: "group" === i
									? null !== (l = P(l) ? l[0] : l) &&
									  (s.total = (s.total || 0) + 1)
									: (s.total = T(s.total + (l || 0))),
								(s.cumulative =
									"group" === i
										? (s.total || 1) - 1
										: L(s.cumulative, y) + (l || 0)),
								null !== l &&
									(s.points[n].push(s.cumulative),
									(u[a] = s.cumulative),
									(s.hasValidPoints = !0));
						"percent" === i && (k.stacking.usePercentage = !0),
							"group" !== i && (this.stackedYData = u),
							(k.stacking.oldStacks = {});
					}
				}
				(k.prototype.buildStacks = function () {
					var t,
						e,
						i = this.axis,
						o = i.series,
						r = i.options.reversedStacks,
						s = o.length;
					for (this.usePercentage = !1, e = s; e--; )
						(t = o[r ? e : s - e - 1]).setStackedPoints(), t.setGroupedPoints();
					for (e = 0; e < s; e++) o[e].modifyStacks();
					h(i, "afterBuildStacks");
				}),
					(k.prototype.cleanStacks = function () {
						var t;
						this.oldStacks && (t = this.stacks = this.oldStacks),
							c(t, function (t) {
								c(t, function (t) {
									t.cumulative = t.total;
								});
							});
					}),
					(k.prototype.resetStacks = function () {
						var o = this;
						c(this.stacks, function (i) {
							c(i, function (t, e) {
								l(t.touched) && t.touched < o.stacksTouched
									? (t.destroy(), delete i[e])
									: ((t.total = null), (t.cumulative = null));
							});
						});
					}),
					(k.prototype.renderStackTotals = function () {
						var t = this.axis,
							e = t.chart,
							i = e.renderer,
							o = this.stacks,
							t = t.options.stackLabels && t.options.stackLabels.animation,
							t = s(e, t || !1),
							r = (this.stackTotalGroup =
								this.stackTotalGroup ||
								i.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add());
						r.translate(e.plotLeft, e.plotTop),
							c(o, function (t) {
								c(t, function (t) {
									t.render(r);
								});
							}),
							r.animate({ opacity: 1 }, t);
					});
				var x,
					b,
					S = k;
				function k(t) {
					(this.oldStacks = {}),
						(this.stacks = {}),
						(this.stacksTouched = 0),
						(this.axis = t);
				}
				return (
					(x = x || {}),
					(b = []),
					(x.compose = function (t, e, i) {
						-1 === b.indexOf(t) &&
							(b.push(t), n(t, "init", u), n(t, "destroy", p)),
							-1 === b.indexOf(e) && (b.push(e), (e.prototype.getStacks = d)),
							-1 === b.indexOf(i) &&
								(b.push(i),
								((t = i.prototype).getStackIndicator = f),
								(t.modifyStacks = g),
								(t.percentStacker = m),
								(t.setGroupedPoints = y),
								(t.setStackedPoints = v));
					}),
					x
				);
			}
		),
		e(
			t,
			"Series/Line/LineSeries.js",
			[
				t["Core/Series/Series.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var o,
					r,
					s =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					g = i.defined,
					i = i.merge,
					s =
						(s(n, (r = t)),
						(n.prototype.drawGraph = function () {
							var s = this,
								n = this.options,
								a = (this.gappedPath || this.getGraphPath).call(this),
								h = this.chart.styledMode,
								t = [["graph", "highcharts-graph"]];
							h ||
								t[0].push(n.lineColor || this.color || "#cccccc", n.dashStyle),
								(t = s.getZonesGraphs(t)).forEach(function (t, e) {
									var i = t[0],
										o = s[i],
										r = o ? "animate" : "attr";
									o
										? ((o.endX = s.preventGraphAnimation ? null : a.xMap),
										  o.animate({ d: a }))
										: a.length &&
										  (s[i] = o =
												s.chart.renderer
													.path(a)
													.addClass(t[1])
													.attr({ zIndex: 1 })
													.add(s.group)),
										o &&
											!h &&
											((i = {
												stroke: t[2],
												"stroke-width": n.lineWidth || 0,
												fill: (s.fillGraph && s.color) || "none",
											}),
											t[3]
												? (i.dashstyle = t[3])
												: "square" !== n.linecap &&
												  (i["stroke-linecap"] = i["stroke-linejoin"] =
														"round"),
											o[r](i).shadow(e < 2 && n.shadow)),
										o && ((o.startX = a.xMap), (o.isArea = a.isArea));
								});
						}),
						(n.prototype.getGraphPath = function (n, a, h) {
							var l,
								c = this,
								d = c.options,
								p = [],
								u = [],
								f = d.step,
								t = (n = n || c.points).reversed;
							return (
								t && n.reverse(),
								(f = { right: 1, center: 2 }[f] || (f && 3)) &&
									t &&
									(f = 4 - f),
								(n = this.getValidPoints(
									n,
									!1,
									!(d.connectNulls && !a && !h)
								)).forEach(function (t, e) {
									var i,
										o = t.plotX,
										r = t.plotY,
										s = n[e - 1];
									(t.leftCliff || (s && s.rightCliff)) && !h && (l = !0),
										(l =
											t.isNull && !g(a) && 0 < e
												? !d.connectNulls
												: !(!t.isNull || a) ||
												  (0 === e || l
														? (i = [["M", t.plotX, t.plotY]])
														: c.getPointSpline
														? (i = [c.getPointSpline(n, t, e)])
														: f
														? (i =
																1 === f
																	? [["L", s.plotX, r]]
																	: 2 === f
																	? [
																			["L", (s.plotX + o) / 2, s.plotY],
																			["L", (s.plotX + o) / 2, r],
																	  ]
																	: [["L", o, s.plotY]]).push(["L", o, r])
														: (i = [["L", o, r]]),
												  u.push(t.x),
												  f && (u.push(t.x), 2 === f && u.push(t.x)),
												  p.push.apply(p, i),
												  !1));
								}),
								(p.xMap = u),
								(c.graphPath = p)
							);
						}),
						(n.prototype.getZonesGraphs = function (i) {
							return (
								this.zones.forEach(function (t, e) {
									e = [
										"zone-graph-" + e,
										"highcharts-graph highcharts-zone-graph-" +
											e +
											" " +
											(t.className || ""),
									];
									this.chart.styledMode ||
										e.push(
											t.color || this.color,
											t.dashStyle || this.options.dashStyle
										),
										i.push(e);
								}, this),
								i
							);
						}),
						(n.defaultOptions = i(t.defaultOptions, {})),
						n);
				function n() {
					var t = (null !== r && r.apply(this, arguments)) || this;
					return (
						(t.data = void 0), (t.options = void 0), (t.points = void 0), t
					);
				}
				return e.registerSeriesType("line", s), s;
			}
		),
		e(
			t,
			"Series/Area/AreaSeries.js",
			[
				t["Core/Color/Color.js"],
				t["Core/Legend/LegendSymbol.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, o) {
				var r,
					h,
					s =
						(this && this.__extends) ||
						((r = function (t, e) {
							return (r =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							r(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					l = t.parse,
					b = i.seriesTypes.line,
					t = o.extend,
					n = o.merge,
					a = o.objectEach,
					S = o.pick,
					o =
						(s(c, (h = b)),
						(c.prototype.drawGraph = function () {
							(this.areaPath = []), h.prototype.drawGraph.apply(this);
							var s = this,
								n = this.areaPath,
								a = this.options,
								t = this.zones,
								i = [["area", "highcharts-area", this.color, a.fillColor]];
							t.forEach(function (t, e) {
								i.push([
									"zone-area-" + e,
									"highcharts-area highcharts-zone-area-" +
										e +
										" " +
										t.className,
									t.color || s.color,
									t.fillColor || a.fillColor,
								]);
							}),
								i.forEach(function (t) {
									var e = t[0],
										i = {},
										o = s[e],
										r = o ? "animate" : "attr";
									o
										? ((o.endX = s.preventGraphAnimation ? null : n.xMap),
										  o.animate({ d: n }))
										: ((i.zIndex = 0),
										  ((o = s[e] =
												s.chart.renderer
													.path(n)
													.addClass(t[1])
													.add(s.group)).isArea = !0)),
										s.chart.styledMode ||
											(i.fill = S(
												t[3],
												l(t[2]).setOpacity(S(a.fillOpacity, 0.75)).get()
											)),
										o[r](i),
										(o.startX = n.xMap),
										(o.shiftUnit = a.step ? 2 : 1);
								});
						}),
						(c.prototype.getGraphPath = function (a) {
							function t(t, e, i) {
								var o,
									r,
									t = a[t],
									s = l && f[t.x].points[u],
									n = t[i + "Null"] || 0,
									t = t[i + "Cliff"] || 0,
									i = !0;
								t || n
									? ((o = (n ? s[0] : s[1]) + t), (r = s[0] + t), (i = !!n))
									: !l && a[e] && a[e].isNull && (o = r = g),
									void 0 !== o &&
										(p.push({
											plotX: h,
											plotY: null === o ? m : c.getThreshold(o),
											isNull: i,
											isCliff: !0,
										}),
										d.push({
											plotX: h,
											plotY: null === r ? m : c.getThreshold(r),
											doCurve: !1,
										}));
							}
							var h,
								e,
								i,
								o = b.prototype.getGraphPath,
								r = this.options,
								l = r.stacking,
								c = this.yAxis,
								d = [],
								p = [],
								u = this.index,
								f = c.stacking.stacks[this.stackKey],
								g = r.threshold,
								m = Math.round(c.getThreshold(r.threshold)),
								s = S(r.connectNulls, "percent" === l);
							a = a || this.points;
							for (
								var n = 0, y = (a = l ? this.getStackPoints(a) : a).length;
								n < y;
								++n
							)
								l ||
									(a[n].leftCliff =
										a[n].rightCliff =
										a[n].leftNull =
										a[n].rightNull =
											void 0),
									(e = a[n].isNull),
									(h = S(a[n].rectPlotX, a[n].plotX)),
									(i = l ? S(a[n].yBottom, m) : m),
									(e && !s) ||
										(s || t(n, n - 1, "left"),
										(e && !l && s) ||
											(p.push(a[n]), d.push({ x: n, plotX: h, plotY: i })),
										s || t(n, n + 1, "right"));
							var r = o.call(this, p, !0, !0),
								v = ((d.reversed = !0), o.call(this, d, !0, !0)),
								x = v[0],
								x =
									(x && "M" === x[0] && (v[0] = ["L", x[1], x[2]]),
									r.concat(v)),
								v = (x.length && x.push(["Z"]), o.call(this, p, !1, s));
							return (x.xMap = r.xMap), (this.areaPath = x), v;
						}),
						(c.prototype.getStackPoints = function (t) {
							var d = this,
								o = [],
								p = [],
								r = this.xAxis,
								s = this.yAxis,
								u = s.stacking.stacks[this.stackKey],
								f = {},
								g = s.series,
								m = g.length,
								y = s.options.reversedStacks ? 1 : -1,
								v = g.indexOf(d);
							if (((t = t || this.points), this.options.stacking)) {
								for (var e = 0; e < t.length; e++)
									(t[e].leftNull = t[e].rightNull = void 0), (f[t[e].x] = t[e]);
								a(u, function (t, e) {
									null !== t.total && p.push(e);
								}),
									p.sort(function (t, e) {
										return t - e;
									});
								var x = g.map(function (t) {
									return t.visible;
								});
								p.forEach(function (a, h) {
									var l,
										t = 0;
									if (f[a] && !f[a].isNull)
										o.push(f[a]),
											[-1, 1].forEach(function (t) {
												var e = 1 === t ? "rightNull" : "leftNull",
													i = 1 === t ? "rightCliff" : "leftCliff",
													o = u[p[h + t]],
													r = 0;
												if (o)
													for (var s = v; 0 <= s && s < m; ) {
														var n = g[s].index;
														(c = o.points[n]) ||
															(n === d.index
																? (f[a][e] = !0)
																: x[s] &&
																  (l = u[a].points[n]) &&
																  (r -= l[1] - l[0])),
															(s += y);
													}
												f[a][i] = r;
											});
									else {
										for (var e = v; 0 <= e && e < m; ) {
											var c,
												i = g[e].index;
											if ((c = u[a].points[i])) {
												t = c[1];
												break;
											}
											e += y;
										}
										(t = S(t, 0)),
											(t = s.translate(t, 0, 1, 0, 1)),
											o.push({
												isNull: !0,
												plotX: r.translate(a, 0, 0, 0, 1),
												x: a,
												plotY: t,
												yBottom: t,
											});
									}
								});
							}
							return o;
						}),
						(c.defaultOptions = n(b.defaultOptions, { threshold: 0 })),
						c);
				function c() {
					var t = (null !== h && h.apply(this, arguments)) || this;
					return (
						(t.data = void 0), (t.options = void 0), (t.points = void 0), t
					);
				}
				return (
					t(o.prototype, {
						singleStacks: !1,
						drawLegendSymbol: e.drawRectangle,
					}),
					i.registerSeriesType("area", o),
					o
				);
			}
		),
		e(
			t,
			"Series/Spline/SplineSeries.js",
			[t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]],
			function (t, e) {
				var o,
					i,
					r =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					s = t.seriesTypes.line,
					n = e.merge,
					u = e.pick,
					e =
						(r(a, (i = s)),
						(a.prototype.getPointSpline = function (t, e, i) {
							var o,
								r,
								s,
								n,
								a,
								h,
								l = e.plotX || 0,
								c = e.plotY || 0,
								d = t[i - 1],
								t = t[i + 1];
							function p(t) {
								return t && !t.isNull && !1 !== t.doCurve && !e.isCliff;
							}
							p(d) &&
								p(t) &&
								((i = d.plotX || 0),
								(o = d.plotY || 0),
								(a = t.plotX || 0),
								(r = 0),
								(n = (1.5 * c + o) / 2.5),
								(h = (1.5 * c + (t = t.plotY || 0)) / 2.5),
								(h += r =
									(a = (1.5 * l + a) / 2.5) !== (s = (1.5 * l + i) / 2.5)
										? ((h - n) * (a - l)) / (a - s) + c - h
										: r),
								o < (n += r) && c < n
									? (h = 2 * c - (n = Math.max(o, c)))
									: n < o && n < c && (h = 2 * c - (n = Math.min(o, c))),
								t < h && c < h
									? (n = 2 * c - (h = Math.max(t, c)))
									: h < t && h < c && (n = 2 * c - (h = Math.min(t, c))),
								(e.rightContX = a),
								(e.rightContY = h));
							i = [
								"C",
								u(d.rightContX, d.plotX, 0),
								u(d.rightContY, d.plotY, 0),
								u(s, l, 0),
								u(n, c, 0),
								l,
								c,
							];
							return (d.rightContX = d.rightContY = void 0), i;
						}),
						(a.defaultOptions = n(s.defaultOptions)),
						a);
				function a() {
					var t = (null !== i && i.apply(this, arguments)) || this;
					return (
						(t.data = void 0), (t.options = void 0), (t.points = void 0), t
					);
				}
				return t.registerSeriesType("spline", e), e;
			}
		),
		e(
			t,
			"Series/AreaSpline/AreaSplineSeries.js",
			[
				t["Series/Spline/SplineSeries.js"],
				t["Core/Legend/LegendSymbol.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, o) {
				var r,
					s,
					n =
						(this && this.__extends) ||
						((r = function (t, e) {
							return (r =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							r(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					a = i.seriesTypes,
					h = a.area,
					a = a.area.prototype,
					l = o.extend,
					o = o.merge,
					n =
						(n(c, (s = t)),
						(c.defaultOptions = o(t.defaultOptions, h.defaultOptions)),
						c);
				function c() {
					var t = (null !== s && s.apply(this, arguments)) || this;
					return (
						(t.data = void 0), (t.points = void 0), (t.options = void 0), t
					);
				}
				return (
					l(n.prototype, {
						getGraphPath: a.getGraphPath,
						getStackPoints: a.getStackPoints,
						drawGraph: a.drawGraph,
						drawLegendSymbol: e.drawRectangle,
					}),
					i.registerSeriesType("areaspline", n),
					n
				);
			}
		),
		e(t, "Series/Column/ColumnSeriesDefaults.js", [], function () {
			return {
				borderRadius: 0,
				centerInCategory: !1,
				groupPadding: 0.2,
				marker: null,
				pointPadding: 0.1,
				minPointLength: 0,
				cropThreshold: 50,
				pointRange: null,
				states: {
					hover: { halo: !1, brightness: 0.1 },
					select: { color: "#cccccc", borderColor: "#000000" },
				},
				dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 },
				startFromThreshold: !0,
				stickyTracking: !1,
				tooltip: { distance: 6 },
				threshold: 0,
				borderColor: "#ffffff",
			};
		}),
		e(
			t,
			"Series/Column/ColumnSeries.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Color/Color.js"],
				t["Series/Column/ColumnSeriesDefaults.js"],
				t["Core/Globals.js"],
				t["Core/Legend/LegendSymbol.js"],
				t["Core/Series/Series.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, o, r, s, n, a) {
				var h,
					l,
					c =
						(this && this.__extends) ||
						((h = function (t, e) {
							return (h =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							h(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					d = t.animObject,
					p = e.parse,
					u = o.hasTouch,
					t = o.noop,
					C = a.clamp,
					M = (a.css, a.defined),
					f = a.extend,
					g = a.fireEvent,
					m = a.isArray,
					w = a.isNumber,
					y = a.merge,
					T = a.pick,
					v = a.objectEach,
					e =
						(c(x, (l = s)),
						(x.prototype.animate = function (t) {
							var i,
								o = this,
								r = this.yAxis,
								e = o.options,
								s = this.chart.inverted,
								n = {},
								a = s ? "translateX" : "translateY";
							t
								? ((n.scaleY = 0.001),
								  (t = C(r.toPixels(e.threshold), r.pos, r.pos + r.len)),
								  s ? (n.translateX = t - r.len) : (n.translateY = t),
								  o.clipBox && o.setClip(),
								  o.group.attr(n))
								: ((i = Number(o.group.attr(a))),
								  o.group.animate(
										{ scaleY: 1 },
										f(d(o.options.animation), {
											step: function (t, e) {
												o.group &&
													((n[a] = i + e.pos * (r.pos - i)), o.group.attr(n));
											},
										})
								  ));
						}),
						(x.prototype.init = function (t, e) {
							l.prototype.init.apply(this, arguments);
							var i = this;
							(t = i.chart).hasRendered &&
								t.series.forEach(function (t) {
									t.type === i.type && (t.isDirty = !0);
								});
						}),
						(x.prototype.getColumnMetrics = function () {
							var r,
								s = this,
								t = s.options,
								e = s.xAxis,
								n = s.yAxis,
								i = e.options.reversedStacks,
								i = (e.reversed && !i) || (!e.reversed && i),
								a = {},
								h = 0,
								o =
									(!1 === t.grouping
										? (h = 1)
										: s.chart.series.forEach(function (t) {
												var e,
													i = t.yAxis,
													o = t.options;
												t.type !== s.type ||
													(!t.visible &&
														s.chart.options.chart.ignoreHiddenSeries) ||
													n.len !== i.len ||
													n.pos !== i.pos ||
													(o.stacking && "group" !== o.stacking
														? ((r = t.stackKey),
														  void 0 === a[r] && (a[r] = h++),
														  (e = a[r]))
														: !1 !== o.grouping && (e = h++),
													(t.columnIndex = e));
										  }),
									Math.min(
										Math.abs(e.transA) *
											((e.ordinal && e.ordinal.slope) ||
												t.pointRange ||
												e.closestPointRange ||
												e.tickInterval ||
												1),
										e.len
									)),
								l = o * t.groupPadding,
								c = (o - 2 * l) / (h || 1),
								e = Math.min(
									t.maxPointWidth || e.len,
									T(t.pointWidth, c * (1 - 2 * t.pointPadding))
								),
								t = (s.columnIndex || 0) + (i ? 1 : 0);
							return (
								(s.columnMetrics = {
									width: e,
									offset: (c - e) / 2 + (l + t * c - o / 2) * (i ? -1 : 1),
									paddedWidth: c,
									columnCount: h,
								}),
								s.columnMetrics
							);
						}),
						(x.prototype.crispCol = function (t, e, i, o) {
							var r = this.chart,
								s = this.borderWidth,
								n = -(s % 2 ? 0.5 : 0),
								s = s % 2 ? 0.5 : 1,
								r =
									(r.inverted && r.renderer.isVML && (s += 1),
									this.options.crisp &&
										(i = Math.round(t + i) + n - (t = Math.round(t) + n)),
									Math.round(e + o) + s),
								n = Math.abs(e) <= 0.5 && 0.5 < r;
							return (
								(o = r - (e = Math.round(e) + s)),
								n && o && (--e, (o += 1)),
								{ x: t, y: e, width: i, height: o }
							);
						}),
						(x.prototype.adjustForMissingColumns = function (t, e, i, o) {
							var r,
								s,
								n,
								a,
								h = this,
								l = this.options.stacking;
							return (
								!i.isNull &&
									1 < o.columnCount &&
									((r = this.yAxis.options.reversedStacks),
									(s = 0),
									(n = r ? 0 : -o.columnCount),
									v(
										this.yAxis.stacking && this.yAxis.stacking.stacks,
										function (t) {
											var e;
											"number" == typeof i.x &&
												(e = t[i.x.toString()]) &&
												((t = e.points[h.index]),
												l
													? (t && (s = n), e.hasValidPoints && (r ? n++ : n--))
													: m(t) &&
													  ((t = Object.keys(e.points)
															.filter(function (t) {
																return (
																	!t.match(",") &&
																	e.points[t] &&
																	1 < e.points[t].length
																);
															})
															.map(parseFloat)
															.sort(function (t, e) {
																return e - t;
															})),
													  (s = t.indexOf(h.index)),
													  (n = t.length)));
										}
									),
									(a = (n - 1) * o.paddedWidth + e),
									(t = (i.plotX || 0) + a / 2 - e - s * o.paddedWidth)),
								t
							);
						}),
						(x.prototype.translate = function () {
							var l = this,
								c = l.chart,
								d = l.options,
								t = (l.dense = l.closestPointRange * l.xAxis.transA < 2),
								t = (l.borderWidth = T(d.borderWidth, t ? 0 : 1)),
								p = l.xAxis,
								u = l.yAxis,
								f = d.threshold,
								g = (l.translatedThreshold = u.getThreshold(f)),
								m = T(d.minPointLength, 5),
								y = l.getColumnMetrics(),
								v = y.width,
								x = (l.pointXOffset = y.offset),
								b = l.dataMin,
								S = l.dataMax,
								k = (l.barW = Math.max(v, 1 + 2 * t));
							c.inverted && (g -= 0.5),
								d.pointPadding && (k = Math.ceil(k)),
								s.prototype.translate.apply(l),
								l.points.forEach(function (t) {
									var e,
										i = T(t.yBottom, g),
										o = 999 + Math.abs(i),
										r = t.plotX || 0,
										o = C(t.plotY, -o, u.len + o),
										s = Math.min(o, i),
										n = Math.max(o, i) - s,
										a = v,
										r = r + x,
										h = k;
									m &&
										Math.abs(n) < m &&
										((n = m),
										(e =
											(!u.reversed && !t.negative) ||
											(u.reversed && t.negative)),
										w(f) &&
											w(S) &&
											t.y === f &&
											S <= f &&
											(u.min || 0) < f &&
											(b !== S || (u.max || 0) <= f) &&
											(e = !e),
										(s = Math.abs(s - g) > m ? i - m : g - (e ? m : 0))),
										M(t.options.pointWidth) &&
											((a = h = Math.ceil(t.options.pointWidth)),
											(r -= Math.round((a - v) / 2))),
										d.centerInCategory &&
											(r = l.adjustForMissingColumns(r, a, t, y)),
										(t.barX = r),
										(t.pointWidth = a),
										(t.tooltipPos = c.inverted
											? [
													C(
														u.len + u.pos - c.plotLeft - o,
														u.pos - c.plotLeft,
														u.len + u.pos - c.plotLeft
													),
													p.len + p.pos - c.plotTop - r - h / 2,
													n,
											  ]
											: [
													p.left - c.plotLeft + r + h / 2,
													C(
														o + u.pos - c.plotTop,
														u.pos - c.plotTop,
														u.len + u.pos - c.plotTop
													),
													n,
											  ]),
										(t.shapeType = l.pointClass.prototype.shapeType || "rect"),
										(t.shapeArgs = l.crispCol.apply(
											l,
											t.isNull ? [r, g, h, 0] : [r, s, h, n]
										));
								});
						}),
						(x.prototype.drawGraph = function () {
							this.group[this.dense ? "addClass" : "removeClass"](
								"highcharts-dense-data"
							);
						}),
						(x.prototype.pointAttribs = function (t, e) {
							var i,
								o = this.options,
								r = this.pointAttrToOptions || {},
								s = r.stroke || "borderColor",
								r = r["stroke-width"] || "borderWidth",
								n = (t && t.color) || this.color,
								a = (t && t[s]) || o[s] || n,
								h = (t && t.options.dashStyle) || o.dashStyle,
								l = (t && t[r]) || o[r] || this[r] || 0,
								c = T(t && t.opacity, o.opacity, 1),
								t =
									(t &&
										this.zones.length &&
										((i = t.getZone()),
										(n =
											t.options.color ||
											(i && (i.color || t.nonZonedColor)) ||
											this.color),
										i &&
											((a = i.borderColor || a),
											(h = i.dashStyle || h),
											(l = i.borderWidth || l))),
									e &&
										t &&
										((o = (i = y(
											o.states[e],
											(t.options.states && t.options.states[e]) || {}
										)).brightness),
										(n =
											i.color ||
											(void 0 !== o && p(n).brighten(i.brightness).get()) ||
											n),
										(a = i[s] || a),
										(l = i[r] || l),
										(h = i.dashStyle || h),
										(c = T(i.opacity, c))),
									{ fill: n, stroke: a, "stroke-width": l, opacity: c });
							return h && (t.dashstyle = h), t;
						}),
						(x.prototype.drawPoints = function (t) {
							void 0 === t && (t = this.points);
							var s,
								n = this,
								a = this.chart,
								h = n.options,
								l = a.renderer,
								c = h.animationLimit || 250;
							t.forEach(function (t) {
								var e = t.plotY,
									i = t.graphic,
									o = !!i,
									r = i && a.pointCount < c ? "animate" : "attr";
								w(e) && null !== t.y
									? ((s = t.shapeArgs),
									  i && t.hasNewShapeType() && (i = i.destroy()),
									  n.enabledDataSorting &&
											(t.startXPos = n.xAxis.reversed
												? -((s && s.width) || 0)
												: n.xAxis.width),
									  i ||
											((t.graphic = i =
												l[t.shapeType](s).add(t.group || n.group)),
											i &&
												n.enabledDataSorting &&
												a.hasRendered &&
												a.pointCount < c &&
												(i.attr({ x: t.startXPos }),
												(o = !0),
												(r = "animate"))),
									  i && o && i[r](y(s)),
									  h.borderRadius && i[r]({ r: h.borderRadius }),
									  a.styledMode ||
											i[r](n.pointAttribs(t, t.selected && "select")).shadow(
												!1 !== t.allowShadow && h.shadow,
												null,
												h.stacking && !h.borderRadius
											),
									  i &&
											(i.addClass(t.getClassName(), !0),
											i.attr({ visibility: t.visible ? "inherit" : "hidden" })))
									: i && (t.graphic = i.destroy());
							});
						}),
						(x.prototype.drawTracker = function (t) {
							void 0 === t && (t = this.points);
							function e(t) {
								var e = s.getPointFromEvent(t);
								void 0 !== e && ((s.isDirectTouch = !0), e.onMouseOver(t));
							}
							var i,
								o = this,
								r = o.chart,
								s = r.pointer;
							t.forEach(function (e) {
								(i = m(e.dataLabels)
									? e.dataLabels
									: e.dataLabel
									? [e.dataLabel]
									: []),
									e.graphic && (e.graphic.element.point = e),
									i.forEach(function (t) {
										t.div ? (t.div.point = e) : (t.element.point = e);
									});
							}),
								o._hasTracking ||
									(o.trackerGroups.forEach(function (t) {
										o[t] &&
											(o[t]
												.addClass("highcharts-tracker")
												.on("mouseover", e)
												.on("mouseout", function (t) {
													s.onTrackerMouseOut(t);
												}),
											u && o[t].on("touchstart", e),
											!r.styledMode &&
												o.options.cursor &&
												o[t].css({ cursor: o.options.cursor }));
									}),
									(o._hasTracking = !0)),
								g(this, "afterDrawTracker");
						}),
						(x.prototype.remove = function () {
							var e = this,
								t = e.chart;
							t.hasRendered &&
								t.series.forEach(function (t) {
									t.type === e.type && (t.isDirty = !0);
								}),
								s.prototype.remove.apply(e, arguments);
						}),
						(x.defaultOptions = y(s.defaultOptions, i)),
						x);
				function x() {
					var t = (null !== l && l.apply(this, arguments)) || this;
					return (
						(t.borderWidth = void 0),
						(t.data = void 0),
						(t.group = void 0),
						(t.options = void 0),
						(t.points = void 0),
						t
					);
				}
				return (
					f(e.prototype, {
						cropShoulder: 0,
						directTouch: !0,
						drawLegendSymbol: r.drawRectangle,
						getSymbol: t,
						negStacks: !0,
						trackerGroups: ["group", "dataLabelsGroup"],
					}),
					n.registerSeriesType("column", e),
					e
				);
			}
		),
		e(
			t,
			"Core/Series/DataLabel.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/FormatUtilities.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var o,
					r,
					s = t.getDeferredAnimation,
					x = e.format,
					b = i.defined,
					v = i.extend,
					n = i.fireEvent,
					a = i.isArray,
					h = i.isString,
					l = i.merge,
					S = i.objectEach,
					k = i.pick,
					c = i.splat;
				function d(e, i, t, o, r) {
					function s(t) {
						d && h.xAxis && !y && h.setDataLabelStartPos(e, i, r, m, t);
					}
					var n,
						a,
						h = this,
						l = this.chart,
						c = this.isCartesian && l.inverted,
						d = this.enabledDataSorting,
						p = e.plotX,
						u = e.plotY,
						f = t.rotation,
						g = t.align,
						m =
							b(p) &&
							b(u) &&
							l.isInsidePlot(p, Math.round(u), {
								inverted: c,
								paneCoordinates: !0,
								series: h,
							}),
						y = "justify" === k(t.overflow, d ? "none" : "justify"),
						u =
							this.visible &&
							!1 !== e.visible &&
							b(p) &&
							(e.series.forceDL ||
								(d && !y) ||
								m ||
								(k(t.inside, !!this.options.stacking) &&
									o &&
									l.isInsidePlot(p, c ? o.x + 1 : o.y + o.height - 1, {
										inverted: c,
										paneCoordinates: !0,
										series: h,
									}))),
						p = e.pos();
					u &&
						p &&
						(f && i.attr({ align: g }),
						(c = i.getBBox(!0)),
						(g = [0, 0]),
						(a = l.renderer.fontMetrics(
							l.styledMode ? void 0 : t.style.fontSize,
							i
						).b),
						(o = v({ x: p[0], y: Math.round(p[1]), width: 0, height: 0 }, o)),
						v(t, { width: c.width, height: c.height }),
						f
							? ((y = !1),
							  (a = l.renderer.rotCorr(a, f)),
							  (n = {
									x: o.x + (t.x || 0) + o.width / 2 + a.x,
									y:
										o.y +
										(t.y || 0) +
										{ top: 0, middle: 0.5, bottom: 1 }[t.verticalAlign] *
											o.height,
							  }),
							  (g = [c.x - Number(i.attr("x")), c.y - Number(i.attr("y"))]),
							  s(n),
							  i[r ? "attr" : "animate"](n))
							: (s(o), i.align(t, void 0, o), (n = i.alignAttr)),
						y && 0 <= o.height
							? this.justifyDataLabel(i, t, n, c, o, r)
							: k(t.crop, !0) &&
							  ((a = n.x),
							  (o = n.y),
							  (a += g[0]),
							  (o += g[1]),
							  (u =
									l.isInsidePlot(a, o, { paneCoordinates: !0, series: h }) &&
									l.isInsidePlot(a + c.width, o + c.height, {
										paneCoordinates: !0,
										series: h,
									}))),
						t.shape &&
							!f &&
							i[r ? "attr" : "animate"]({ anchorX: p[0], anchorY: p[1] })),
						r && d && (i.placed = !1),
						u || (d && !y) ? i.show() : (i.hide(), (i.placed = !1));
				}
				function p(t) {
					void 0 === t && (t = this.points);
					var u,
						f = this,
						g = f.chart,
						m = f.options,
						e = f.hasRendered || 0,
						y = g.renderer,
						i = g.options.chart,
						o = i.backgroundColor,
						i = i.plotBackgroundColor,
						v = y.getContrast((h(i) && i) || (h(o) && o) || "#000000"),
						i = (r = m.dataLabels).animation,
						o = r.defer ? s(g, i, f) : { defer: 0, duration: 0 },
						r = C(
							C(
								g.options.plotOptions &&
									g.options.plotOptions.series &&
									g.options.plotOptions.series.dataLabels,
								g.options.plotOptions &&
									g.options.plotOptions[f.type] &&
									g.options.plotOptions[f.type].dataLabels
							),
							r
						);
					n(this, "drawDataLabels"),
						(a(r) || r.enabled || f._hasPointLabels) &&
							((u = f.plotGroup(
								"dataLabelsGroup",
								"data-labels",
								e ? "inherit" : "hidden",
								r.zIndex || 6
							)).attr({ opacity: +e }),
							e ||
								((i = f.dataLabelsGroup) &&
									(f.visible && u.show(),
									i[m.animation ? "animate" : "attr"]({ opacity: 1 }, o))),
							t.forEach(function (p) {
								c(
									C(r, p.dlOptions || (p.options && p.options.dataLabels))
								).forEach(function (t, e) {
									var i,
										o,
										r,
										s,
										n,
										a =
											t.enabled &&
											(!p.isNull || p.dataLabelOnNull) &&
											((h = p),
											!(l = (l = t).filter) ||
												((a = l.operator),
												(h = h[l.property]),
												(l = l.value),
												(">" === a && l < h) ||
													("<" === a && h < l) ||
													(">=" === a && l <= h) ||
													("<=" === a && h <= l) ||
													("==" === a && h == l) ||
													("===" === a && h === l))),
										h = p.connectors ? p.connectors[e] : p.connector,
										l = p.dataLabels ? p.dataLabels[e] : p.dataLabel,
										c = !l,
										d = k(t.distance, p.labelDistance);
									a &&
										((s = p.getLabelConfig()),
										(r = k(t[p.formatPrefix + "Format"], t.format)),
										(r = b(r)
											? x(r, s, g)
											: (t[p.formatPrefix + "Formatter"] || t.formatter).call(
													s,
													t
											  )),
										(s = t.style),
										(n = t.rotation),
										g.styledMode ||
											((s.color = k(t.color, s.color, f.color, "#000000")),
											"contrast" === s.color
												? ((p.contrastColor = y.getContrast(
														p.color || f.color
												  )),
												  (s.color =
														(!b(d) && t.inside) || d < 0 || m.stacking
															? p.contrastColor
															: v))
												: delete p.contrastColor,
											m.cursor && (s.cursor = m.cursor)),
										(i = {
											r: t.borderRadius || 0,
											rotation: n,
											padding: t.padding,
											zIndex: 1,
										}),
										g.styledMode ||
											((d = t.backgroundColor),
											(o = t.borderColor),
											(i.fill = "auto" === d ? p.color : d),
											(i.stroke = "auto" === o ? p.color : o),
											(i["stroke-width"] = t.borderWidth)),
										S(i, function (t, e) {
											void 0 === t && delete i[e];
										})),
										!l ||
											(a &&
												b(r) &&
												!!l.div == !!t.useHTML &&
												((l.rotation && t.rotation) ||
													l.rotation === t.rotation)) ||
											((c = !0),
											(p.dataLabel = l = p.dataLabel && p.dataLabel.destroy()),
											p.dataLabels &&
												(1 === p.dataLabels.length
													? delete p.dataLabels
													: delete p.dataLabels[e]),
											e || delete p.dataLabel,
											h &&
												((p.connector = p.connector.destroy()),
												p.connectors &&
													(1 === p.connectors.length
														? delete p.connectors
														: delete p.connectors[e]))),
										a && b(r)
											? (l
													? (i.text = r)
													: ((p.dataLabels = p.dataLabels || []),
													  (l = p.dataLabels[e] =
															n
																? y
																		.text(r, 0, 0, t.useHTML)
																		.addClass("highcharts-data-label")
																: y.label(
																		r,
																		0,
																		0,
																		t.shape,
																		null,
																		null,
																		t.useHTML,
																		null,
																		"data-label"
																  )),
													  e || (p.dataLabel = l),
													  l.addClass(
															" highcharts-data-label-color-" +
																p.colorIndex +
																" " +
																(t.className || "") +
																(t.useHTML ? " highcharts-tracker" : "")
													  )),
											  (l.options = t),
											  l.attr(i),
											  g.styledMode || l.css(s).shadow(t.shadow),
											  (d = t[p.formatPrefix + "TextPath"] || t.textPath) &&
													!t.useHTML &&
													(l.setTextPath(
														(p.getDataLabelPath && p.getDataLabelPath(l)) ||
															p.graphic,
														d
													),
													p.dataLabelPath &&
														!d.enabled &&
														(p.dataLabelPath = p.dataLabelPath.destroy())),
											  l.added || l.add(u),
											  f.alignDataLabel(p, l, t, null, c))
											: l && l.hide();
								});
							})),
						n(this, "afterDrawDataLabels");
				}
				function u(t, e, i, o, r, s) {
					var n,
						a = this.chart,
						h = e.align,
						l = e.verticalAlign,
						c = (!t.box && t.padding) || 0,
						d = e.x,
						d = void 0 === d ? 0 : d,
						p = e.y,
						p = void 0 === p ? 0 : p,
						u = (i.x || 0) + c;
					return (
						u < 0 &&
							("right" === h && 0 <= d
								? ((e.align = "left"), (e.inside = !0))
								: (d -= u),
							(n = !0)),
						(u = (i.x || 0) + o.width - c) > a.plotWidth &&
							("left" === h && d <= 0
								? ((e.align = "right"), (e.inside = !0))
								: (d += a.plotWidth - u),
							(n = !0)),
						(u = i.y + c) < 0 &&
							("bottom" === l && 0 <= p
								? ((e.verticalAlign = "top"), (e.inside = !0))
								: (p -= u),
							(n = !0)),
						(u = (i.y || 0) + o.height - c) > a.plotHeight &&
							("top" === l && p <= 0
								? ((e.verticalAlign = "bottom"), (e.inside = !0))
								: (p += a.plotHeight - u),
							(n = !0)),
						n && ((e.x = d), (e.y = p), (t.placed = !s), t.align(e, void 0, r)),
						n
					);
				}
				function C(e, i) {
					var t,
						o = [];
					if (a(e) && !a(i))
						o = e.map(function (t) {
							return l(t, i);
						});
					else if (a(i) && !a(e))
						o = i.map(function (t) {
							return l(e, t);
						});
					else if (a(e) || a(i))
						for (t = Math.max(e.length, i.length); t--; ) o[t] = l(e[t], i[t]);
					else o = l(e, i);
					return o;
				}
				function f(t, e, i, o, r) {
					var s = this.chart,
						n = s.inverted,
						a = this.xAxis,
						h = a.reversed,
						l = n ? e.height / 2 : e.width / 2,
						t = t.pointWidth,
						t = t ? t / 2 : 0;
					(e.startXPos = n ? r.x : h ? -l - t : a.width - l + t),
						(e.startYPos = n ? (h ? this.yAxis.height - l + t : -l - t) : r.y),
						o
							? "hidden" === e.visibility &&
							  (e.show(), e.attr({ opacity: 0 }).animate({ opacity: 1 }))
							: e.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, e.hide),
						s.hasRendered &&
							(i && e.attr({ x: e.startXPos, y: e.startYPos }),
							(e.placed = !0));
				}
				return (
					(o = o || {}),
					(r = []),
					(o.compose = function (t) {
						var e;
						-1 === r.indexOf(t) &&
							((e = t.prototype),
							r.push(t),
							(e.alignDataLabel = d),
							(e.drawDataLabels = p),
							(e.justifyDataLabel = u),
							(e.setDataLabelStartPos = f));
					}),
					o
				);
			}
		),
		e(
			t,
			"Series/Column/ColumnDataLabel.js",
			[
				t["Core/Series/DataLabel.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (e, t, i) {
				var o,
					r,
					d = t.series,
					p = i.merge,
					u = i.pick;
				function s(t, e, i, o, r) {
					var s = this.chart.inverted,
						n = t.series,
						a = (n.xAxis ? n.xAxis.len : this.chart.plotSizeX) || 0,
						n = (n.yAxis ? n.yAxis.len : this.chart.plotSizeY) || 0,
						h = t.dlBox || t.shapeArgs,
						l = u(t.below, t.plotY > u(this.translatedThreshold, n)),
						c = u(i.inside, !!this.options.stacking);
					h &&
						((o = p(h)).y < 0 && ((o.height += o.y), (o.y = 0)),
						0 < (h = o.y + o.height - n) && h < o.height && (o.height -= h),
						s &&
							(o = {
								x: n - o.y - o.height,
								y: a - o.x - o.width,
								width: o.height,
								height: o.width,
							}),
						c ||
							(s
								? ((o.x += l ? 0 : o.width), (o.width = 0))
								: ((o.y += l ? o.height : 0), (o.height = 0)))),
						(i.align = u(i.align, !s || c ? "center" : l ? "right" : "left")),
						(i.verticalAlign = u(
							i.verticalAlign,
							s || c ? "middle" : l ? "top" : "bottom"
						)),
						d.prototype.alignDataLabel.call(this, t, e, i, o, r),
						i.inside && t.contrastColor && e.css({ color: t.contrastColor });
				}
				return (
					(o = o || {}),
					(r = []),
					(o.compose = function (t) {
						e.compose(d),
							-1 === r.indexOf(t) &&
								(r.push(t), (t.prototype.alignDataLabel = s));
					}),
					o
				);
			}
		),
		e(
			t,
			"Series/Bar/BarSeries.js",
			[
				t["Series/Column/ColumnSeries.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var o,
					r,
					s =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					n = i.extend,
					i = i.merge,
					s = (s(a, (r = t)), (a.defaultOptions = i(t.defaultOptions, {})), a);
				function a() {
					var t = (null !== r && r.apply(this, arguments)) || this;
					return (
						(t.data = void 0), (t.options = void 0), (t.points = void 0), t
					);
				}
				return (
					n(s.prototype, { inverted: !0 }), e.registerSeriesType("bar", s), s
				);
			}
		),
		e(t, "Series/Scatter/ScatterSeriesDefaults.js", [], function () {
			return {
				lineWidth: 0,
				findNearestPointBy: "xy",
				jitter: { x: 0, y: 0 },
				marker: { enabled: !0 },
				tooltip: {
					headerFormat:
						'<span style="color:{point.color}">●</span> <span style="font-size: 10px"> {series.name}</span><br/>',
					pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
				},
			};
		}),
		e(
			t,
			"Series/Scatter/ScatterSeries.js",
			[
				t["Series/Scatter/ScatterSeriesDefaults.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var o,
					r,
					s =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					n = e.seriesTypes,
					a = n.column,
					n = n.line,
					h = i.addEvent,
					l = i.extend,
					i = i.merge,
					s =
						(s(c, (r = n)),
						(c.prototype.applyJitter = function () {
							var h = this,
								l = this.options.jitter,
								c = this.points.length;
							l &&
								this.points.forEach(function (n, a) {
									["x", "y"].forEach(function (t, e) {
										var i,
											o,
											r,
											s = "plot" + t.toUpperCase();
										l[t] &&
											!n.isNull &&
											((o = h[t + "Axis"]),
											(r = l[t] * o.transA),
											o &&
												!o.isLog &&
												((i = Math.max(0, n[s] - r)),
												(o = Math.min(o.len, n[s] + r)),
												(n[s] =
													i +
													(o - i) *
														((r = a + e * c),
														(r = 1e4 * Math.sin(r)) - Math.floor(r))),
												"x" === t && (n.clientX = n.plotX)));
									});
								});
						}),
						(c.prototype.drawGraph = function () {
							this.options.lineWidth
								? r.prototype.drawGraph.call(this)
								: this.graph && (this.graph = this.graph.destroy());
						}),
						(c.defaultOptions = i(n.defaultOptions, t)),
						c);
				function c() {
					var t = (null !== r && r.apply(this, arguments)) || this;
					return (
						(t.data = void 0), (t.options = void 0), (t.points = void 0), t
					);
				}
				return (
					l(s.prototype, {
						drawTracker: a.prototype.drawTracker,
						sorted: !1,
						requireSorting: !1,
						noSharedTooltip: !0,
						trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
						takeOrdinalPosition: !1,
					}),
					h(s, "afterTranslate", function () {
						this.applyJitter();
					}),
					e.registerSeriesType("scatter", s),
					s
				);
			}
		),
		e(
			t,
			"Series/CenteredUtilities.js",
			[
				t["Core/Globals.js"],
				t["Core/Series/Series.js"],
				t["Core/Utilities.js"],
			],
			function (t, f, e) {
				var i,
					o = t.deg2rad,
					g = e.fireEvent,
					m = e.isNumber,
					y = e.pick,
					v = e.relativeLength;
				return (
					((t = i = i || {}).getCenter = function () {
						var t,
							e,
							i,
							o = this.options,
							r = this.chart,
							s = 2 * (o.slicedOffset || 0),
							n = r.plotWidth - 2 * s,
							a = r.plotHeight - 2 * s,
							h = o.center,
							l = Math.min(n, a),
							c = o.thickness,
							d = o.size,
							p = o.innerSize || 0,
							u =
								("string" == typeof d && (d = parseFloat(d)),
								"string" == typeof p && (p = parseFloat(p)),
								[
									y(h[0], "50%"),
									y(h[1], "50%"),
									y(d && d < 0 ? void 0 : o.size, "100%"),
									y(p && p < 0 ? void 0 : o.innerSize || 0, "0%"),
								]);
						for (
							!r.angular || this instanceof f || (u[3] = 0), e = 0;
							e < 4;
							++e
						)
							(i = u[e]),
								(t = e < 2 || (2 === e && /%$/.test(i))),
								(u[e] = v(i, [n, a, l, u[2]][e]) + (t ? s : 0));
						return (
							u[3] > u[2] && (u[3] = u[2]),
							m(c) && 2 * c < u[2] && 0 < c && (u[3] = u[2] - 2 * c),
							g(this, "afterGetCenter", { positions: u }),
							u
						);
					}),
					(t.getStartAndEndRadians = function (t, e) {
						return (
							(t = m(t) ? t : 0),
							(e = m(e) && t < e && e - t < 360 ? e : t + 360),
							{ start: o * (t + -90), end: o * (e + -90) }
						);
					}),
					i
				);
			}
		),
		e(
			t,
			"Series/Pie/PiePoint.js",
			[
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Series/Point.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i) {
				var o,
					r,
					s =
						(this && this.__extends) ||
						((o = function (t, e) {
							return (o =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							o(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					n = t.setAnimation,
					a = i.addEvent,
					h = i.defined,
					t = i.extend,
					l = i.isNumber,
					c = i.pick,
					d = i.relativeLength,
					i =
						(s(p, (r = e)),
						(p.prototype.getConnectorPath = function () {
							var t = this.labelPosition,
								e = this.series.options.dataLabels,
								i = this.connectorShapes,
								o = e.connectorShape;
							return (o = i[o] ? i[o] : o).call(
								this,
								{ x: t.final.x, y: t.final.y, alignment: t.alignment },
								t.connectorPosition,
								e
							);
						}),
						(p.prototype.getTranslate = function () {
							return this.sliced
								? this.slicedTranslation
								: { translateX: 0, translateY: 0 };
						}),
						(p.prototype.haloPath = function (t) {
							var e = this.shapeArgs;
							return this.sliced || !this.visible
								? []
								: this.series.chart.renderer.symbols.arc(
										e.x,
										e.y,
										e.r + t,
										e.r + t,
										{ innerR: e.r - 1, start: e.start, end: e.end }
								  );
						}),
						(p.prototype.init = function () {
							function t(t) {
								e.slice("select" === t.type);
							}
							var e = this;
							r.prototype.init.apply(this, arguments),
								(this.name = c(this.name, "Slice"));
							return a(this, "select", t), a(this, "unselect", t), this;
						}),
						(p.prototype.isValid = function () {
							return l(this.y) && 0 <= this.y;
						}),
						(p.prototype.setVisible = function (e, t) {
							var i = this,
								o = this.series,
								r = o.chart,
								s = o.options.ignoreHiddenPoint;
							(t = c(t, s)),
								e !== this.visible &&
									((this.visible =
										this.options.visible =
										e =
											void 0 === e ? !this.visible : e),
									(o.options.data[o.data.indexOf(this)] = this.options),
									["graphic", "dataLabel", "connector", "shadowGroup"].forEach(
										function (t) {
											i[t] && i[t][e ? "show" : "hide"](e);
										}
									),
									this.legendItem && r.legend.colorizeItem(this, e),
									e || "hover" !== this.state || this.setState(""),
									s && (o.isDirty = !0),
									t && r.redraw());
						}),
						(p.prototype.slice = function (t, e, i) {
							var o = this.series,
								r = o.chart;
							n(i, r),
								(e = c(e, !0)),
								(this.sliced =
									this.options.sliced =
									t =
										h(t) ? t : !this.sliced),
								(o.options.data[o.data.indexOf(this)] = this.options),
								this.graphic && this.graphic.animate(this.getTranslate()),
								this.shadowGroup &&
									this.shadowGroup.animate(this.getTranslate());
						}),
						p);
				function p() {
					var t = (null !== r && r.apply(this, arguments)) || this;
					return (
						(t.labelDistance = void 0),
						(t.options = void 0),
						(t.series = void 0),
						t
					);
				}
				return (
					t(i.prototype, {
						connectorShapes: {
							fixedOffset: function (t, e, i) {
								var o = e.breakAt,
									e = e.touchingSliceAt,
									i = i.softConnector
										? [
												"C",
												t.x + ("left" === t.alignment ? -5 : 5),
												t.y,
												2 * o.x - e.x,
												2 * o.y - e.y,
												o.x,
												o.y,
										  ]
										: ["L", o.x, o.y];
								return [["M", t.x, t.y], i, ["L", e.x, e.y]];
							},
							straight: function (t, e) {
								e = e.touchingSliceAt;
								return [
									["M", t.x, t.y],
									["L", e.x, e.y],
								];
							},
							crookedLine: function (t, e, i) {
								var e = e.touchingSliceAt,
									o = this.series,
									r = o.center[0],
									s = o.chart.plotWidth,
									o = o.chart.plotLeft,
									n = t.alignment,
									a = this.shapeArgs.r,
									i = d(i.crookDistance, 1),
									s =
										"left" === n
											? r + a + (s + o - r - a) * (1 - i)
											: o + (r - a) * i,
									o = ["L", s, t.y],
									r = !0,
									a =
										(("left" === n ? s > t.x || s < e.x : s < t.x || s > e.x) &&
											(r = !1),
										[["M", t.x, t.y]]);
								return r && a.push(o), a.push(["L", e.x, e.y]), a;
							},
						},
					}),
					i
				);
			}
		),
		e(t, "Series/Pie/PieSeriesDefaults.js", [], function () {
			return {
				center: [null, null],
				clip: !1,
				colorByPoint: !0,
				dataLabels: {
					allowOverlap: !0,
					connectorPadding: 5,
					connectorShape: "fixedOffset",
					crookDistance: "70%",
					distance: 30,
					enabled: !0,
					formatter: function () {
						return this.point.isNull ? void 0 : this.point.name;
					},
					softConnector: !0,
					x: 0,
				},
				fillColor: void 0,
				ignoreHiddenPoint: !0,
				inactiveOtherPoints: !0,
				legendType: "point",
				marker: null,
				size: null,
				showInLegend: !1,
				slicedOffset: 10,
				stickyTracking: !1,
				tooltip: { followPointer: !0 },
				borderColor: "#ffffff",
				borderWidth: 1,
				lineWidth: void 0,
				states: { hover: { brightness: 0.1 } },
			};
		}),
		e(
			t,
			"Series/Pie/PieSeries.js",
			[
				t["Series/CenteredUtilities.js"],
				t["Series/Column/ColumnSeries.js"],
				t["Core/Globals.js"],
				t["Core/Legend/LegendSymbol.js"],
				t["Series/Pie/PiePoint.js"],
				t["Series/Pie/PieSeriesDefaults.js"],
				t["Core/Series/Series.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Renderer/SVG/Symbols.js"],
				t["Core/Utilities.js"],
			],
			function (t, e, i, o, r, s, n, a, h, l) {
				var c,
					d,
					p =
						(this && this.__extends) ||
						((c = function (t, e) {
							return (c =
								Object.setPrototypeOf ||
								({ __proto__: [] } instanceof Array &&
									function (t, e) {
										t.__proto__ = e;
									}) ||
								function (t, e) {
									for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
								})(t, e);
						}),
						function (t, e) {
							function i() {
								this.constructor = t;
							}
							c(t, e),
								(t.prototype =
									null === e
										? Object.create(e)
										: ((i.prototype = e.prototype), new i()));
						}),
					v = t.getStartAndEndRadians,
					i = i.noop,
					u = l.clamp,
					f = l.extend,
					x = l.fireEvent,
					g = l.merge,
					b = l.pick,
					S = l.relativeLength,
					l =
						(p(m, (d = n)),
						(m.prototype.animate = function (t) {
							var o = this,
								e = o.points,
								r = o.startAngleRad;
							t ||
								e.forEach(function (t) {
									var e = t.graphic,
										i = t.shapeArgs;
									e &&
										i &&
										(e.attr({
											r: b(t.startR, o.center && o.center[3] / 2),
											start: r,
											end: r,
										}),
										e.animate(
											{ r: i.r, start: i.start, end: i.end },
											o.options.animation
										));
								});
						}),
						(m.prototype.drawEmpty = function () {
							var t,
								e,
								i = this.startAngleRad,
								o = this.endAngleRad,
								r = this.options;
							0 === this.total && this.center
								? ((t = this.center[0]),
								  (e = this.center[1]),
								  this.graph ||
										(this.graph = this.chart.renderer
											.arc(t, e, this.center[1] / 2, 0, i, o)
											.addClass("highcharts-empty-series")
											.add(this.group)),
								  this.graph.attr({
										d: h.arc(t, e, this.center[2] / 2, 0, {
											start: i,
											end: o,
											innerR: this.center[3] / 2,
										}),
								  }),
								  this.chart.styledMode ||
										this.graph.attr({
											"stroke-width": r.borderWidth,
											fill: r.fillColor || "none",
											stroke: r.color || "#cccccc",
										}))
								: this.graph && (this.graph = this.graph.destroy());
						}),
						(m.prototype.drawPoints = function () {
							var e = this.chart.renderer;
							this.points.forEach(function (t) {
								t.graphic &&
									t.hasNewShapeType() &&
									(t.graphic = t.graphic.destroy()),
									t.graphic ||
										((t.graphic = e[t.shapeType](t.shapeArgs).add(
											t.series.group
										)),
										(t.delayedRendering = !0));
							});
						}),
						(m.prototype.generatePoints = function () {
							d.prototype.generatePoints.call(this), this.updateTotals();
						}),
						(m.prototype.getX = function (t, e, i) {
							var o = this.center,
								r = this.radii ? this.radii[i.index] || 0 : o[2] / 2,
								t = Math.asin(u((t - o[1]) / (r + i.labelDistance), -1, 1));
							return (
								o[0] +
								(e ? -1 : 1) * (Math.cos(t) * (r + i.labelDistance)) +
								(0 < i.labelDistance
									? (e ? -1 : 1) * this.options.dataLabels.padding
									: 0)
							);
						}),
						(m.prototype.hasData = function () {
							return !!this.processedXData.length;
						}),
						(m.prototype.redrawPoints = function () {
							var o,
								r,
								s,
								n,
								a = this,
								h = a.chart,
								l = h.renderer,
								c = a.options.shadow;
							this.drawEmpty(),
								!c ||
									a.shadowGroup ||
									h.styledMode ||
									(a.shadowGroup = l
										.g("shadow")
										.attr({ zIndex: -1 })
										.add(a.group)),
								a.points.forEach(function (t) {
									var e,
										i = {};
									(r = t.graphic),
										!t.isNull && r
											? ((e = void 0),
											  (n = t.shapeArgs),
											  (o = t.getTranslate()),
											  h.styledMode ||
													((e = t.shadowGroup),
													(e =
														c && !e
															? (t.shadowGroup = l
																	.g("shadow")
																	.add(a.shadowGroup))
															: e) && e.attr(o),
													(s = a.pointAttribs(t, t.selected && "select"))),
											  t.delayedRendering
													? (r.setRadialReference(a.center).attr(n).attr(o),
													  h.styledMode ||
															r
																.attr(s)
																.attr({ "stroke-linejoin": "round" })
																.shadow(c, e),
													  (t.delayedRendering = !1))
													: (r.setRadialReference(a.center),
													  h.styledMode || g(!0, i, s),
													  g(!0, i, n, o),
													  r.animate(i)),
											  r.attr({
													visibility: t.visible ? "inherit" : "hidden",
											  }),
											  r.addClass(t.getClassName(), !0))
											: r && (t.graphic = r.destroy());
								});
						}),
						(m.prototype.sortByAngle = function (t, i) {
							t.sort(function (t, e) {
								return void 0 !== t.angle && (e.angle - t.angle) * i;
							});
						}),
						(m.prototype.translate = function (t) {
							x(this, "translate"), this.generatePoints();
							var e,
								i,
								o,
								r,
								s = this.options,
								n = s.slicedOffset,
								a = n + (s.borderWidth || 0),
								h = v(s.startAngle, s.endAngle),
								l = (this.startAngleRad = h.start),
								c = (this.endAngleRad = h.end) - l,
								d = this.points,
								p = s.dataLabels.distance,
								u = s.ignoreHiddenPoint,
								f = d.length,
								g = 0;
							for (
								t || (this.center = t = this.getCenter()), o = 0;
								o < f;
								o++
							) {
								(i = l + g * c),
									!(r = d[o]).isValid() ||
										(u && !r.visible) ||
										(g += r.percentage / 100);
								var m = l + g * c,
									y = {
										x: t[0],
										y: t[1],
										r: t[2] / 2,
										innerR: t[3] / 2,
										start: Math.round(1e3 * i) / 1e3,
										end: Math.round(1e3 * m) / 1e3,
									};
								(r.shapeType = "arc"),
									(r.shapeArgs = y),
									(r.labelDistance = b(
										r.options.dataLabels && r.options.dataLabels.distance,
										p
									)),
									(r.labelDistance = S(r.labelDistance, y.r)),
									(this.maxLabelDistance = Math.max(
										this.maxLabelDistance || 0,
										r.labelDistance
									)),
									(y = (m + i) / 2) > 1.5 * Math.PI
										? (y -= 2 * Math.PI)
										: y < -Math.PI / 2 && (y += 2 * Math.PI),
									(r.slicedTranslation = {
										translateX: Math.round(Math.cos(y) * n),
										translateY: Math.round(Math.sin(y) * n),
									}),
									(m = (Math.cos(y) * t[2]) / 2),
									(i = (Math.sin(y) * t[2]) / 2),
									(r.tooltipPos = [t[0] + 0.7 * m, t[1] + 0.7 * i]),
									(r.half = y < -Math.PI / 2 || y > Math.PI / 2 ? 1 : 0),
									(r.angle = y),
									(e = Math.min(a, r.labelDistance / 5)),
									(r.labelPosition = {
										natural: {
											x: t[0] + m + Math.cos(y) * r.labelDistance,
											y: t[1] + i + Math.sin(y) * r.labelDistance,
										},
										final: {},
										alignment:
											r.labelDistance < 0
												? "center"
												: r.half
												? "right"
												: "left",
										connectorPosition: {
											breakAt: {
												x: t[0] + m + Math.cos(y) * e,
												y: t[1] + i + Math.sin(y) * e,
											},
											touchingSliceAt: { x: t[0] + m, y: t[1] + i },
										},
									});
							}
							x(this, "afterTranslate");
						}),
						(m.prototype.updateTotals = function () {
							for (
								var t,
									e = this.points,
									i = e.length,
									o = this.options.ignoreHiddenPoint,
									r = 0,
									s = 0;
								s < i;
								s++
							)
								!(t = e[s]).isValid() || (o && !t.visible) || (r += t.y);
							for (this.total = r, s = 0; s < i; s++)
								((t = e[s]).percentage =
									0 < r && (t.visible || !o) ? (t.y / r) * 100 : 0),
									(t.total = r);
						}),
						(m.defaultOptions = g(n.defaultOptions, s)),
						m);
				function m() {
					var t = (null !== d && d.apply(this, arguments)) || this;
					return (
						(t.center = void 0),
						(t.data = void 0),
						(t.maxLabelDistance = void 0),
						(t.options = void 0),
						(t.points = void 0),
						t
					);
				}
				return (
					f(l.prototype, {
						axisTypes: [],
						directTouch: !0,
						drawGraph: void 0,
						drawLegendSymbol: o.drawRectangle,
						drawTracker: e.prototype.drawTracker,
						getCenter: t.getCenter,
						getSymbol: i,
						isCartesian: !1,
						noSharedTooltip: !0,
						pointAttribs: e.prototype.pointAttribs,
						pointClass: r,
						requireSorting: !1,
						searchPoint: i,
						trackerGroups: ["group", "dataLabelsGroup"],
					}),
					a.registerSeriesType("pie", l),
					l
				);
			}
		),
		e(
			t,
			"Series/Pie/PieDataLabel.js",
			[
				t["Core/Series/DataLabel.js"],
				t["Core/Globals.js"],
				t["Core/Renderer/RendererUtilities.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Core/Utilities.js"],
			],
			function (e, t, i, o, r) {
				var s,
					n,
					a,
					h = t.noop,
					O = i.distribute,
					E = o.series,
					D = r.arrayMax,
					l = r.clamp,
					j = r.defined,
					I = r.merge,
					B = r.pick,
					c = r.relativeLength;
				function d() {
					var l,
						i,
						o,
						c,
						d,
						p,
						u,
						f,
						g,
						m,
						y,
						v = this,
						t = v.data,
						x = v.chart,
						b = v.options.dataLabels || {},
						S = b.connectorPadding,
						k = x.plotWidth,
						C = x.plotHeight,
						M = x.plotLeft,
						e = Math.round(x.chartWidth / 3),
						w = v.center,
						T = w[2] / 2,
						A = w[1],
						r = [[], []],
						P = [0, 0, 0, 0],
						L = v.dataLabelPositioners;
					v.visible &&
						(b.enabled || v._hasPointLabels) &&
						(t.forEach(function (t) {
							t.dataLabel &&
								t.visible &&
								t.dataLabel.shortened &&
								(t.dataLabel
									.attr({ width: "auto" })
									.css({ width: "auto", textOverflow: "clip" }),
								(t.dataLabel.shortened = !1));
						}),
						E.prototype.drawDataLabels.apply(v),
						t.forEach(function (t) {
							t.dataLabel &&
								(t.visible
									? (r[t.half].push(t),
									  (t.dataLabel._pos = null),
									  j(b.style.width) ||
											j(
												t.options.dataLabels &&
													t.options.dataLabels.style &&
													t.options.dataLabels.style.width
											) ||
											(t.dataLabel.getBBox().width > e &&
												(t.dataLabel.css({ width: Math.round(0.7 * e) + "px" }),
												(t.dataLabel.shortened = !0))))
									: ((t.dataLabel = t.dataLabel.destroy()),
									  t.dataLabels &&
											1 === t.dataLabels.length &&
											delete t.dataLabels));
						}),
						r.forEach(function (t, e) {
							var i,
								o,
								r,
								s,
								n,
								a = t.length,
								h = [];
							if (a)
								for (
									v.sortByAngle(t, e - 0.5),
										0 < v.maxLabelDistance &&
											((i = Math.max(0, A - T - v.maxLabelDistance)),
											(n = Math.min(A + T + v.maxLabelDistance, x.plotHeight)),
											t.forEach(function (t) {
												0 < t.labelDistance &&
													t.dataLabel &&
													((t.top = Math.max(0, A - T - t.labelDistance)),
													(t.bottom = Math.min(
														A + T + t.labelDistance,
														x.plotHeight
													)),
													(s = t.dataLabel.getBBox().height || 21),
													(t.distributeBox = {
														target: t.labelPosition.natural.y - t.top + s / 2,
														size: s,
														rank: t.y,
													}),
													h.push(t.distributeBox));
											}),
											O(h, (n = n + s - i), n / 5)),
										m = 0;
									m < a;
									m++
								) {
									if (
										((l = t[m]),
										(d = l.labelPosition),
										(c = l.dataLabel),
										(g = !1 === l.visible ? "hidden" : "inherit"),
										(o = d.natural.y),
										(f = o),
										h &&
											j(l.distributeBox) &&
											(void 0 === l.distributeBox.pos
												? (g = "hidden")
												: ((p = l.distributeBox.size),
												  (f = L.radialDistributionY(l)))),
										delete l.positionIndex,
										b.justify)
									)
										u = L.justify(l, T, w);
									else
										switch (b.alignTo) {
											case "connectors":
												u = L.alignToConnectors(t, e, k, M);
												break;
											case "plotEdges":
												u = L.alignToPlotEdges(c, e, k, M);
												break;
											default:
												u = L.radialDistributionX(v, l, f, o);
										}
									(c._attr = { visibility: g, align: d.alignment }),
										(y = l.options.dataLabels || {}),
										(c._pos = {
											x:
												u +
												B(y.x, b.x) +
												({ left: S, right: -S }[d.alignment] || 0),
											y: f + B(y.y, b.y) - 10,
										}),
										(d.final.x = u),
										(d.final.y = f),
										B(b.crop, !0) &&
											((d = c.getBBox().width),
											(r = null),
											u - d < S && 1 === e
												? ((r = Math.round(d - u + S)),
												  (P[3] = Math.max(r, P[3])))
												: k - S < u + d &&
												  0 === e &&
												  ((r = Math.round(u + d - k + S)),
												  (P[1] = Math.max(r, P[1]))),
											f - p / 2 < 0
												? (P[0] = Math.max(Math.round(p / 2 - f), P[0]))
												: C < f + p / 2 &&
												  (P[2] = Math.max(Math.round(f + p / 2 - C), P[2])),
											(c.sideOverflow = r));
								}
						}),
						(0 !== D(P) && !this.verifyDataLabelOverflow(P)) ||
							(this.placeDataLabels(),
							this.points.forEach(function (t) {
								var e;
								(y = I(b, t.options.dataLabels)),
									(i = B(y.connectorWidth, 1)) &&
										((e = void 0),
										(o = t.connector),
										(c = t.dataLabel) &&
										c._pos &&
										t.visible &&
										0 < t.labelDistance
											? ((g = c._attr.visibility),
											  (e = !o) &&
													((t.connector = o =
														x.renderer
															.path()
															.addClass(
																"highcharts-data-label-connector  highcharts-color-" +
																	t.colorIndex +
																	(t.className ? " " + t.className : "")
															)
															.add(v.dataLabelsGroup)),
													x.styledMode ||
														o.attr({
															"stroke-width": i,
															stroke: y.connectorColor || t.color || "#666666",
														})),
											  o[e ? "attr" : "animate"]({ d: t.getConnectorPath() }),
											  o.attr("visibility", g))
											: o && (t.connector = o.destroy()));
							})));
				}
				function p() {
					this.points.forEach(function (t) {
						var e,
							i = t.dataLabel;
						i &&
							t.visible &&
							((e = i._pos)
								? (i.sideOverflow &&
										((i._attr.width = Math.max(
											i.getBBox().width - i.sideOverflow,
											0
										)),
										i.css({
											width: i._attr.width + "px",
											textOverflow:
												(this.options.dataLabels.style || {}).textOverflow ||
												"ellipsis",
										}),
										(i.shortened = !0)),
								  i.attr(i._attr),
								  i[i.moved ? "animate" : "attr"](e),
								  (i.moved = !0))
								: i && i.attr({ y: -9999 })),
							delete t.distributeBox;
					}, this);
				}
				function u(t) {
					var e = this.center,
						i = this.options,
						o = i.center,
						r = i.minSize || 80,
						s = r,
						n = null !== i.size;
					return (
						n ||
							(null !== o[0]
								? (s = Math.max(e[2] - Math.max(t[1], t[3]), r))
								: ((s = Math.max(e[2] - t[1] - t[3], r)),
								  (e[0] += (t[3] - t[1]) / 2)),
							null !== o[1]
								? (s = l(s, r, e[2] - Math.max(t[0], t[2])))
								: ((s = l(s, r, e[2] - t[0] - t[2])),
								  (e[1] += (t[0] - t[2]) / 2)),
							s < e[2]
								? ((e[2] = s),
								  (e[3] = Math.min(
										i.thickness
											? Math.max(0, s - 2 * i.thickness)
											: Math.max(0, c(i.innerSize || 0, s)),
										s
								  )),
								  this.translate(e),
								  this.drawDataLabels && this.drawDataLabels())
								: (n = !0)),
						n
					);
				}
				return (
					(s = s || {}),
					(n = []),
					(a = {
						radialDistributionY: function (t) {
							return t.top + t.distributeBox.pos;
						},
						radialDistributionX: function (t, e, i, o) {
							return t.getX(
								i < e.top + 2 || i > e.bottom - 2 ? o : i,
								e.half,
								e
							);
						},
						justify: function (t, e, i) {
							return i[0] + (t.half ? -1 : 1) * (e + t.labelDistance);
						},
						alignToPlotEdges: function (t, e, i, o) {
							t = t.getBBox().width;
							return e ? t + o : i - t - o;
						},
						alignToConnectors: function (t, e, i, o) {
							var r,
								s = 0;
							return (
								t.forEach(function (t) {
									(r = t.dataLabel.getBBox().width), s < r && (s = r);
								}),
								e ? s + o : i - s - o
							);
						},
					}),
					(s.compose = function (t) {
						e.compose(E),
							-1 === n.indexOf(t) &&
								(n.push(t),
								((t = t.prototype).dataLabelPositioners = a),
								(t.alignDataLabel = h),
								(t.drawDataLabels = d),
								(t.placeDataLabels = p),
								(t.verifyDataLabelOverflow = u));
					}),
					s
				);
			}
		),
		e(
			t,
			"Extensions/OverlappingDataLabels.js",
			[t["Core/Chart/Chart.js"], t["Core/Utilities.js"]],
			function (t, e) {
				var i = e.addEvent,
					u = e.fireEvent,
					s = e.isArray,
					f = e.isNumber,
					n = e.objectEach,
					a = e.pick;
				function g(t, e) {
					var i,
						o,
						r = !1;
					return (
						t &&
							((o = t.newOpacity),
							t.oldOpacity !== o &&
								(t.alignAttr && t.placed
									? (t[o ? "removeClass" : "addClass"](
											"highcharts-data-label-hidden"
									  ),
									  (i = function () {
											e.styledMode ||
												t.css({ pointerEvents: o ? "auto" : "none" });
									  }),
									  (r = !0),
									  (t.alignAttr.opacity = o),
									  t[t.isOld ? "animate" : "attr"](t.alignAttr, null, i),
									  u(e, "afterHideOverlappingLabel"))
									: t.attr({ opacity: o })),
							(t.isOld = !0)),
						r
					);
				}
				i(t, "render", function () {
					var o = this,
						r = [];
					(this.labelCollectors || []).forEach(function (t) {
						r = r.concat(t());
					}),
						(this.yAxis || []).forEach(function (t) {
							t.stacking &&
								t.options.stackLabels &&
								!t.options.stackLabels.allowOverlap &&
								n(t.stacking.stacks, function (t) {
									n(t, function (t) {
										t.label && r.push(t.label);
									});
								});
						}),
						(this.series || []).forEach(function (t) {
							var e = t.options.dataLabels;
							t.visible &&
								(!1 !== e.enabled || t._hasPointLabels) &&
								((e = function (t) {
									return t.forEach(function (i) {
										i.visible &&
											(s(i.dataLabels)
												? i.dataLabels
												: i.dataLabel
												? [i.dataLabel]
												: []
											).forEach(function (t) {
												var e = t.options;
												(t.labelrank = a(
													e.labelrank,
													i.labelrank,
													i.shapeArgs && i.shapeArgs.height
												)),
													e.allowOverlap
														? ((t.oldOpacity = t.opacity),
														  (t.newOpacity = 1),
														  g(t, o))
														: r.push(t);
											});
									});
								})(t.nodes || []),
								e(t.points));
						}),
						this.hideOverlappingLabels(r);
				}),
					(t.prototype.hideOverlappingLabels = function (t) {
						for (
							var e,
								i,
								o,
								r,
								s,
								n,
								a,
								h = this,
								l = t.length,
								c = h.renderer,
								d = !1,
								p = 0;
							p < l;
							p++
						)
							(e = t[p]) &&
								((e.oldOpacity = e.opacity),
								(e.newOpacity = 1),
								(e.absoluteBox = (function (t) {
									var e,
										i,
										o,
										r,
										s = (!t.box && t.padding) || 0,
										n = 0,
										a = 0;
									if (t && (!t.alignAttr || t.placed))
										return (
											(e = t.alignAttr || { x: t.attr("x"), y: t.attr("y") }),
											(i = t.parentGroup),
											t.width ||
												((o = t.getBBox()),
												(t.width = o.width),
												(t.height = o.height),
												(n = c.fontMetrics(null, t.element).h)),
											(o = t.width - 2 * s),
											(r = { left: "0", center: "0.5", right: "1" }[
												t.alignValue
											])
												? (a = +r * o)
												: f(t.x) &&
												  Math.round(t.x) !== t.translateX &&
												  (a = t.x - t.translateX),
											{
												x: e.x + (i.translateX || 0) + s - (a || 0),
												y: e.y + (i.translateY || 0) + s - n,
												width: t.width - 2 * s,
												height: t.height - 2 * s,
											}
										);
								})(e)));
						for (
							t.sort(function (t, e) {
								return (e.labelrank || 0) - (t.labelrank || 0);
							}),
								p = 0;
							p < l;
							p++
						)
							for (s = (o = t[p]) && o.absoluteBox, i = p + 1; i < l; ++i)
								(r = t[i]),
									(a = r && r.absoluteBox),
									s &&
										a &&
										o !== r &&
										0 !== o.newOpacity &&
										0 !== r.newOpacity &&
										"hidden" !== o.visibility &&
										"hidden" !== r.visibility &&
										((n = s),
										(a = a).x >= n.x + n.width ||
											a.x + a.width <= n.x ||
											a.y >= n.y + n.height ||
											a.y + a.height <= n.y ||
											((o.labelrank < r.labelrank ? o : r).newOpacity = 0));
						t.forEach(function (t) {
							g(t, h) && (d = !0);
						}),
							d && u(h, "afterHideAllOverlappingLabels");
					});
			}
		),
		e(t, "Core/Responsive.js", [t["Core/Utilities.js"]], function (t) {
			var e,
				i = t.extend,
				a = t.find,
				h = t.isArray,
				l = t.isObject,
				c = t.merge,
				d = t.objectEach,
				o = t.pick,
				p = t.splat,
				u = t.uniqueKey,
				r = ((e = e || {}), []),
				s =
					((e.compose = function (t) {
						return (
							-1 === r.indexOf(t) && (r.push(t), i(t.prototype, s.prototype)), t
						);
					}),
					(n.prototype.currentOptions = function (t) {
						var a = this,
							e = {};
						return (
							(function i(t, o, r, s) {
								var n;
								d(t, function (t, e) {
									if (!s && -1 < a.collectionsWithUpdate.indexOf(e) && o[e])
										for (
											t = p(t), r[e] = [], n = 0;
											n < Math.max(t.length, o[e].length);
											n++
										)
											o[e][n] &&
												(void 0 === t[n]
													? (r[e][n] = o[e][n])
													: ((r[e][n] = {}), i(t[n], o[e][n], r[e][n], s + 1)));
									else
										l(t)
											? ((r[e] = h(t) ? [] : {}), i(t, o[e] || {}, r[e], s + 1))
											: void 0 === o[e]
											? (r[e] = null)
											: (r[e] = o[e]);
								});
							})(t, this.options, e, 0),
							e
						);
					}),
					(n.prototype.matchResponsiveRule = function (t, e) {
						var i = t.condition;
						(
							i.callback ||
							function () {
								return (
									this.chartWidth <= o(i.maxWidth, Number.MAX_VALUE) &&
									this.chartHeight <= o(i.maxHeight, Number.MAX_VALUE) &&
									this.chartWidth >= o(i.minWidth, 0) &&
									this.chartHeight >= o(i.minHeight, 0)
								);
							}
						).call(this) && e.push(t._id);
					}),
					(n.prototype.setResponsive = function (t, e) {
						var i = this,
							o = this.options.responsive,
							r = this.currentResponsive,
							s = [],
							e =
								(!e &&
									o &&
									o.rules &&
									o.rules.forEach(function (t) {
										void 0 === t._id && (t._id = u()),
											i.matchResponsiveRule(t, s);
									}, this),
								c.apply(
									void 0,
									s
										.map(function (e) {
											return a((o || {}).rules || [], function (t) {
												return t._id === e;
											});
										})
										.map(function (t) {
											return t && t.chartOptions;
										})
								)),
							n =
								((e.isResponsiveOptions = !0),
								(s = s.toString() || void 0),
								r && r.ruleIds);
						s !== n &&
							(r && this.update(r.undoOptions, t, !0),
							s
								? (((n = this.currentOptions(e)).isResponsiveOptions = !0),
								  (this.currentResponsive = {
										ruleIds: s,
										mergedOptions: e,
										undoOptions: n,
								  }),
								  this.update(e, t, !0))
								: (this.currentResponsive = void 0));
					}),
					n);
			function n() {}
			return e;
		}),
		e(
			t,
			"masters/highcharts.src.js",
			[
				t["Core/Globals.js"],
				t["Core/Utilities.js"],
				t["Core/Defaults.js"],
				t["Core/Animation/Fx.js"],
				t["Core/Animation/AnimationUtilities.js"],
				t["Core/Renderer/HTML/AST.js"],
				t["Core/FormatUtilities.js"],
				t["Core/Renderer/RendererUtilities.js"],
				t["Core/Renderer/SVG/SVGElement.js"],
				t["Core/Renderer/SVG/SVGRenderer.js"],
				t["Core/Renderer/HTML/HTMLElement.js"],
				t["Core/Renderer/HTML/HTMLRenderer.js"],
				t["Core/Axis/Axis.js"],
				t["Core/Axis/DateTimeAxis.js"],
				t["Core/Axis/LogarithmicAxis.js"],
				t["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
				t["Core/Axis/Tick.js"],
				t["Core/Tooltip.js"],
				t["Core/Series/Point.js"],
				t["Core/Pointer.js"],
				t["Core/MSPointer.js"],
				t["Core/Legend/Legend.js"],
				t["Core/Chart/Chart.js"],
				t["Core/Axis/Stacking/StackingAxis.js"],
				t["Core/Axis/Stacking/StackItem.js"],
				t["Core/Series/Series.js"],
				t["Core/Series/SeriesRegistry.js"],
				t["Series/Column/ColumnSeries.js"],
				t["Series/Column/ColumnDataLabel.js"],
				t["Series/Pie/PieSeries.js"],
				t["Series/Pie/PieDataLabel.js"],
				t["Core/Series/DataLabel.js"],
				t["Core/Responsive.js"],
				t["Core/Color/Color.js"],
				t["Core/Time.js"],
			],
			function (
				t,
				e,
				i,
				o,
				r,
				s,
				n,
				a,
				h,
				l,
				c,
				d,
				p,
				u,
				f,
				g,
				m,
				y,
				v,
				x,
				b,
				S,
				k,
				C,
				M,
				w,
				T,
				A,
				P,
				L,
				O,
				E,
				D,
				j,
				I
			) {
				return (
					(t.animate = r.animate),
					(t.animObject = r.animObject),
					(t.getDeferredAnimation = r.getDeferredAnimation),
					(t.setAnimation = r.setAnimation),
					(t.stop = r.stop),
					(t.timers = o.timers),
					(t.AST = s),
					(t.Axis = p),
					(t.Chart = k),
					(t.chart = k.chart),
					(t.Fx = o),
					(t.Legend = S),
					(t.PlotLineOrBand = g),
					(t.Point = v),
					(t.Pointer = b.isRequired() ? b : x),
					(t.Series = w),
					(t.StackItem = M),
					(t.SVGElement = h),
					(t.SVGRenderer = l),
					(t.Tick = m),
					(t.Time = I),
					(t.Tooltip = y),
					(t.Color = j),
					(t.color = j.parse),
					d.compose(l),
					c.compose(h),
					(t.defaultOptions = i.defaultOptions),
					(t.getOptions = i.getOptions),
					(t.time = i.defaultTime),
					(t.setOptions = i.setOptions),
					(t.dateFormat = n.dateFormat),
					(t.format = n.format),
					(t.numberFormat = n.numberFormat),
					(t.addEvent = e.addEvent),
					(t.arrayMax = e.arrayMax),
					(t.arrayMin = e.arrayMin),
					(t.attr = e.attr),
					(t.clearTimeout = e.clearTimeout),
					(t.correctFloat = e.correctFloat),
					(t.createElement = e.createElement),
					(t.css = e.css),
					(t.defined = e.defined),
					(t.destroyObjectProperties = e.destroyObjectProperties),
					(t.discardElement = e.discardElement),
					(t.distribute = a.distribute),
					(t.erase = e.erase),
					(t.error = e.error),
					(t.extend = e.extend),
					(t.extendClass = e.extendClass),
					(t.find = e.find),
					(t.fireEvent = e.fireEvent),
					(t.getMagnitude = e.getMagnitude),
					(t.getStyle = e.getStyle),
					(t.inArray = e.inArray),
					(t.isArray = e.isArray),
					(t.isClass = e.isClass),
					(t.isDOMElement = e.isDOMElement),
					(t.isFunction = e.isFunction),
					(t.isNumber = e.isNumber),
					(t.isObject = e.isObject),
					(t.isString = e.isString),
					(t.keys = e.keys),
					(t.merge = e.merge),
					(t.normalizeTickInterval = e.normalizeTickInterval),
					(t.objectEach = e.objectEach),
					(t.offset = e.offset),
					(t.pad = e.pad),
					(t.pick = e.pick),
					(t.pInt = e.pInt),
					(t.relativeLength = e.relativeLength),
					(t.removeEvent = e.removeEvent),
					(t.seriesType = T.seriesType),
					(t.splat = e.splat),
					(t.stableSort = e.stableSort),
					(t.syncTimeout = e.syncTimeout),
					(t.timeUnits = e.timeUnits),
					(t.uniqueKey = e.uniqueKey),
					(t.useSerialIds = e.useSerialIds),
					(t.wrap = e.wrap),
					P.compose(A),
					E.compose(w),
					u.compose(p),
					f.compose(p),
					O.compose(L),
					g.compose(p),
					D.compose(k),
					C.compose(p, k, w),
					t
				);
			}
		),
		(t["masters/highcharts.src.js"]._modules = t)["masters/highcharts.src.js"]
	);
});
